diff --git a/.env.example b/.env.example
index fb13348..d257e2a 100644
--- a/.env.example
+++ b/.env.example
@@ -1,4 +1,4 @@
-# Myna Flutter Environment Configuration
+# Parasto Flutter Environment Configuration
 # Copy this file to .env and fill in your values
 # NEVER commit .env to version control
 
@@ -7,8 +7,8 @@ SUPABASE_URL=https://your-project.supabase.co
 SUPABASE_ANON_KEY=your-anon-key-here
 
 # App Configuration
-APP_NAME=Myna
-APP_NAME_FA=مینا
+APP_NAME=Parasto
+APP_NAME_FA=پرستو
 
 # Storage Buckets
 AUDIO_BUCKET=audiobook-audio
diff --git a/.metadata b/.metadata
index d044da8..fb51cb0 100644
--- a/.metadata
+++ b/.metadata
@@ -18,21 +18,6 @@ migration:
     - platform: android
       create_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
       base_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
-    - platform: ios
-      create_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
-      base_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
-    - platform: linux
-      create_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
-      base_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
-    - platform: macos
-      create_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
-      base_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
-    - platform: web
-      create_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
-      base_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
-    - platform: windows
-      create_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
-      base_revision: dec2ee5c1f98f8e84a7d5380c05eb8a3d0a81668
 
   # User provided section
 
diff --git a/android/app/proguard-rules.pro b/android/app/proguard-rules.pro
index ef83a04..9c71f57 100644
--- a/android/app/proguard-rules.pro
+++ b/android/app/proguard-rules.pro
@@ -1,5 +1,9 @@
 # Flutter specific ProGuard rules
 
+# Audio Service - keep classes needed for background media notification
+-keep class com.ryanheise.audioservice.** { *; }
+-dontwarn com.ryanheise.audioservice.**
+
 # Stripe SDK - suppress warnings for push provisioning classes
 -dontwarn com.stripe.android.pushProvisioning.PushProvisioningActivity$g
 -dontwarn com.stripe.android.pushProvisioning.PushProvisioningActivityStarter$Args
diff --git a/android/app/src/main/AndroidManifest.xml b/android/app/src/main/AndroidManifest.xml
index cc6de7b..ad418a0 100644
--- a/android/app/src/main/AndroidManifest.xml
+++ b/android/app/src/main/AndroidManifest.xml
@@ -4,9 +4,11 @@
     <uses-permission android:name="android.permission.WAKE_LOCK"/>
     <uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>
     <uses-permission android:name="android.permission.FOREGROUND_SERVICE_MEDIA_PLAYBACK"/>
+    <!-- Required for Android 13+ (API 33+) to show media notification -->
+    <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>
 
     <application
-        android:label="مینا"
+        android:label="Parasto"
         android:name="${applicationName}"
         android:icon="@mipmap/ic_launcher">
         <activity
diff --git a/android/app/src/main/kotlin/com/myna/audiobook/MainActivity.kt b/android/app/src/main/kotlin/com/myna/audiobook/MainActivity.kt
index 515fd1d..bd2bc93 100644
--- a/android/app/src/main/kotlin/com/myna/audiobook/MainActivity.kt
+++ b/android/app/src/main/kotlin/com/myna/audiobook/MainActivity.kt
@@ -1,5 +1,187 @@
 package com.myna.audiobook
 
-import io.flutter.embedding.android.FlutterActivity
+import android.app.NotificationChannel
+import android.app.NotificationManager
+import android.content.Intent
+import android.content.pm.PackageManager
+import android.net.Uri
+import android.os.Build
+import android.provider.Settings
+import androidx.core.app.NotificationManagerCompat
+import androidx.core.content.ContextCompat
+import io.flutter.embedding.android.FlutterFragmentActivity
+import io.flutter.embedding.engine.FlutterEngine
+import io.flutter.plugin.common.MethodChannel
 
-class MainActivity: FlutterActivity()
+// NOTE: Must extend FlutterFragmentActivity (not FlutterActivity) for audio_service
+// to show media notifications and lockscreen controls on Android.
+// See: https://pub.dev/packages/audio_service#android-setup
+class MainActivity: FlutterFragmentActivity() {
+
+    private val CHANNEL = "com.myna.audiobook/notification_diagnostics"
+
+    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {
+        super.configureFlutterEngine(flutterEngine)
+
+        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler { call, result ->
+            when (call.method) {
+                "getNotificationDiagnostics" -> {
+                    val diagnostics = getNotificationDiagnostics()
+                    result.success(diagnostics)
+                }
+                "openChannelSettings" -> {
+                    val channelId = call.argument<String>("channelId") ?: "app.myna.audio"
+                    val opened = openChannelSettings(channelId)
+                    result.success(opened)
+                }
+                "openAppNotificationSettings" -> {
+                    val opened = openAppNotificationSettings()
+                    result.success(opened)
+                }
+                else -> {
+                    result.notImplemented()
+                }
+            }
+        }
+    }
+
+    /**
+     * Collects notification-related diagnostics for debugging lockscreen/notification issues.
+     * Returns a Map with:
+     * - sdkInt: Android SDK version
+     * - notifEnabled: App-level notifications enabled
+     * - postNotifGranted: POST_NOTIFICATIONS permission granted (Android 13+)
+     * - channelExists: Whether the audio channel exists
+     * - channelImportance: Importance level (0-5)
+     * - channelImportanceName: Human-readable importance
+     * - channelBlocked: Whether channel is blocked by user
+     * - channelLockscreenVisibility: Lockscreen visibility setting
+     * - channelCanShowBadge: Whether channel can show badge
+     */
+    private fun getNotificationDiagnostics(): Map<String, Any?> {
+        val notificationManager = getSystemService(NOTIFICATION_SERVICE) as NotificationManager
+        val notificationManagerCompat = NotificationManagerCompat.from(this)
+
+        val sdkInt = Build.VERSION.SDK_INT
+
+        // App-level notifications enabled
+        val notifEnabled = notificationManagerCompat.areNotificationsEnabled()
+
+        // POST_NOTIFICATIONS permission (Android 13+ / SDK 33+)
+        val postNotifGranted = if (sdkInt >= 33) {
+            ContextCompat.checkSelfPermission(
+                this,
+                android.Manifest.permission.POST_NOTIFICATIONS
+            ) == PackageManager.PERMISSION_GRANTED
+        } else {
+            true // Not required on older versions
+        }
+
+        // Channel-specific diagnostics
+        val channelId = "app.myna.audio"
+        var channelExists = false
+        var channelImportance = -1
+        var channelImportanceName = "unknown"
+        var channelBlocked = false
+        var channelLockscreenVisibility = -999
+        var channelCanShowBadge = false
+
+        if (sdkInt >= Build.VERSION_CODES.O) {
+            val channel: NotificationChannel? = notificationManager.getNotificationChannel(channelId)
+            channelExists = channel != null
+
+            if (channel != null) {
+                channelImportance = channel.importance
+                channelImportanceName = importanceToName(channel.importance)
+
+                // On SDK 28+ we can check if channel is blocked
+                if (sdkInt >= Build.VERSION_CODES.P) {
+                    channelBlocked = notificationManager.getNotificationChannel(channelId)
+                        ?.importance == NotificationManager.IMPORTANCE_NONE
+                }
+
+                channelLockscreenVisibility = channel.lockscreenVisibility
+                channelCanShowBadge = channel.canShowBadge()
+            }
+        } else {
+            // Pre-Oreo: no channels, just check if notifications are enabled
+            channelExists = true // Concept doesn't exist
+            channelImportance = 3 // Default importance
+            channelImportanceName = "default_preO"
+        }
+
+        return mapOf(
+            "sdkInt" to sdkInt,
+            "notifEnabled" to notifEnabled,
+            "postNotifGranted" to postNotifGranted,
+            "channelExists" to channelExists,
+            "channelImportance" to channelImportance,
+            "channelImportanceName" to channelImportanceName,
+            "channelBlocked" to channelBlocked,
+            "channelLockscreenVisibility" to channelLockscreenVisibility,
+            "channelCanShowBadge" to channelCanShowBadge
+        )
+    }
+
+    /**
+     * Convert NotificationManager importance int to human-readable name.
+     */
+    private fun importanceToName(importance: Int): String {
+        return when (importance) {
+            NotificationManager.IMPORTANCE_NONE -> "NONE"
+            NotificationManager.IMPORTANCE_MIN -> "MIN"
+            NotificationManager.IMPORTANCE_LOW -> "LOW"
+            NotificationManager.IMPORTANCE_DEFAULT -> "DEFAULT"
+            NotificationManager.IMPORTANCE_HIGH -> "HIGH"
+            NotificationManager.IMPORTANCE_MAX -> "MAX"
+            else -> "UNKNOWN($importance)"
+        }
+    }
+
+    /**
+     * Open system settings for a specific notification channel.
+     * Only works on Android O (API 26) and above.
+     * Returns true if the intent was launched, false otherwise.
+     */
+    private fun openChannelSettings(channelId: String): Boolean {
+        return try {
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+                val intent = Intent(Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS).apply {
+                    putExtra(Settings.EXTRA_APP_PACKAGE, packageName)
+                    putExtra(Settings.EXTRA_CHANNEL_ID, channelId)
+                }
+                startActivity(intent)
+                true
+            } else {
+                // Fall back to app notification settings on older Android
+                openAppNotificationSettings()
+            }
+        } catch (e: Exception) {
+            // If channel settings fail, try app notification settings
+            openAppNotificationSettings()
+        }
+    }
+
+    /**
+     * Open system settings for app-level notifications.
+     * Returns true if the intent was launched, false otherwise.
+     */
+    private fun openAppNotificationSettings(): Boolean {
+        return try {
+            val intent = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+                Intent(Settings.ACTION_APP_NOTIFICATION_SETTINGS).apply {
+                    putExtra(Settings.EXTRA_APP_PACKAGE, packageName)
+                }
+            } else {
+                // For older Android versions, open app details
+                Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
+                    data = Uri.fromParts("package", packageName, null)
+                }
+            }
+            startActivity(intent)
+            true
+        } catch (e: Exception) {
+            false
+        }
+    }
+}
diff --git a/android/app/src/main/res/mipmap-hdpi/ic_launcher.png b/android/app/src/main/res/mipmap-hdpi/ic_launcher.png
index db77bb4..733b7c6 100644
Binary files a/android/app/src/main/res/mipmap-hdpi/ic_launcher.png and b/android/app/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/android/app/src/main/res/mipmap-mdpi/ic_launcher.png b/android/app/src/main/res/mipmap-mdpi/ic_launcher.png
index 17987b7..1ab7e5a 100644
Binary files a/android/app/src/main/res/mipmap-mdpi/ic_launcher.png and b/android/app/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/android/app/src/main/res/mipmap-xhdpi/ic_launcher.png b/android/app/src/main/res/mipmap-xhdpi/ic_launcher.png
index 09d4391..28459b0 100644
Binary files a/android/app/src/main/res/mipmap-xhdpi/ic_launcher.png and b/android/app/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/android/app/src/main/res/mipmap-xxhdpi/ic_launcher.png b/android/app/src/main/res/mipmap-xxhdpi/ic_launcher.png
index d5f1c8d..075df18 100644
Binary files a/android/app/src/main/res/mipmap-xxhdpi/ic_launcher.png and b/android/app/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/android/app/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/android/app/src/main/res/mipmap-xxxhdpi/ic_launcher.png
index 4d6372e..aeae82f 100644
Binary files a/android/app/src/main/res/mipmap-xxxhdpi/ic_launcher.png and b/android/app/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/android/build/reports/problems/problems-report.html b/android/build/reports/problems/problems-report.html
deleted file mode 100644
index 17b674a..0000000
--- a/android/build/reports/problems/problems-report.html
+++ /dev/null
@@ -1,663 +0,0 @@
-<!DOCTYPE html>
-
-<html lang="en">
-<head>
-    <!-- Required meta tags -->
-    <meta charset="utf-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
-
-                    <style type="text/css">
-                /*! normalize.css v7.0.0 | MIT License | github.com/necolas/normalize.css */
-html {
-    line-height: 1.15;
-    -ms-text-size-adjust: 100%;
-    -webkit-text-size-adjust: 100%
-}
-
-body {
-    margin: 0
-}
-
-article, aside, footer, header, nav, section {
-    display: block
-}
-
-h1 {
-    font-size: 2em;
-    margin: .67em 0
-}
-
-figcaption, figure, main {
-    display: block
-}
-
-figure {
-    margin: 1em 40px
-}
-
-hr {
-    box-sizing: content-box;
-    height: 0;
-    overflow: visible
-}
-
-pre {
-    font-family: monospace, monospace;
-    font-size: 1em
-}
-
-a {
-    background-color: transparent;
-    -webkit-text-decoration-skip: objects
-}
-
-abbr[title] {
-    border-bottom: none;
-    text-decoration: underline;
-    text-decoration: underline dotted
-}
-
-b, strong {
-    font-weight: inherit
-}
-
-b, strong {
-    font-weight: bolder
-}
-
-code, kbd, samp {
-    font-family: monospace, monospace;
-    font-size: 1em
-}
-
-dfn {
-    font-style: italic
-}
-
-mark {
-    background-color: #ff0;
-    color: #000
-}
-
-small {
-    font-size: 80%
-}
-
-sub, sup {
-    font-size: 75%;
-    line-height: 0;
-    position: relative;
-    vertical-align: baseline
-}
-
-sub {
-    bottom: -.25em
-}
-
-sup {
-    top: -.5em
-}
-
-audio, video {
-    display: inline-block
-}
-
-audio:not([controls]) {
-    display: none;
-    height: 0
-}
-
-img {
-    border-style: none
-}
-
-svg:not(:root) {
-    overflow: hidden
-}
-
-button, input, optgroup, select, textarea {
-    font-family: sans-serif;
-    font-size: 100%;
-    line-height: 1.15;
-    margin: 0
-}
-
-button, input {
-    overflow: visible
-}
-
-button, select {
-    text-transform: none
-}
-
-[type=reset], [type=submit], button, html [type=button] {
-    -webkit-appearance: button
-}
-
-[type=button]::-moz-focus-inner, [type=reset]::-moz-focus-inner, [type=submit]::-moz-focus-inner, button::-moz-focus-inner {
-    border-style: none;
-    padding: 0
-}
-
-[type=button]:-moz-focusring, [type=reset]:-moz-focusring, [type=submit]:-moz-focusring, button:-moz-focusring {
-    outline: 1px dotted ButtonText
-}
-
-fieldset {
-    padding: .35em .75em .625em
-}
-
-legend {
-    box-sizing: border-box;
-    color: inherit;
-    display: table;
-    max-width: 100%;
-    padding: 0;
-    white-space: normal
-}
-
-progress {
-    display: inline-block;
-    vertical-align: baseline
-}
-
-textarea {
-    overflow: auto
-}
-
-[type=checkbox], [type=radio] {
-    box-sizing: border-box;
-    padding: 0
-}
-
-[type=number]::-webkit-inner-spin-button, [type=number]::-webkit-outer-spin-button {
-    height: auto
-}
-
-[type=search] {
-    -webkit-appearance: textfield;
-    outline-offset: -2px
-}
-
-[type=search]::-webkit-search-cancel-button, [type=search]::-webkit-search-decoration {
-    -webkit-appearance: none
-}
-
-::-webkit-file-upload-button {
-    -webkit-appearance: button;
-    font: inherit
-}
-
-details, menu {
-    display: block
-}
-
-summary {
-    display: list-item
-}
-
-canvas {
-    display: inline-block
-}
-
-template {
-    display: none
-}
-
-[hidden] {
-    display: none
-}
-
-/* configuration cache styles */
-
-.report-wrapper {
-    margin: 0;
-    padding: 0 24px;
-}
-
-.gradle-logo {
-    width: 32px;
-    height: 24px;
-    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAYCAYAAACbU/80AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAGAAAAAA915G0AAAD5klEQVRIDbVWC0xTZxT+emmhVUEeA1/ROh/tFAFFGK7oJisIKsNVoOwBbJPowEWHzikRxeiMRpwwjDWRBHQLIzOmiRhe22BT40TitiyaMBQFfMEeLMIEaSmk+/+rvd7be4no6Elu7n++c/5zzv845/wyOyG4iGyDgzCdNOPLM9W41n4bnmNUiHo5DNsz0hGsmcV6lbkyAOOWXJjrz4qWp1C4o3z/LqzWL4VcJB1FIHmZHn/f78a6pDcxbeIEfNvQiPwTZbDZBpC24zOEaGfDpTsgtZby6u+QlrubFWUY3nh6AH39/ahr/Bn1jZfxW3ML2js60dtvgbtcQVblj8CZM7A0PBSrol6Ft+c4KZ8iTB1nwN0//8IEP9/hA2i924Gir0/iq8oa/NvbJzLiDKiUSqTE6pGVbEBY4BxnsYAPSnwXTa3tLCZ5BF3dPdAkGNHzoFcwcaRMnC4CeZkZiAgKFE252nITC1Pew9Dj5GNEGgS4Rbb5eZ1Te7UXG6FLX4cV6zeh5kIDaDpSunL9Boyf5nLOpwT4Sx+BxWrFK8QAnTAapPRQwofcj86uLoG59cbVEOzA0NAQNh38Atn5RSjY8rFAmc/I3dyQvOx1PsSNVy7Roa3ajHDePbBYLSLn1MaGd5KFAXy07xAOl59C6elK+I73hIHcbGd6wXs8qkyH8FZcjLOI5X/9/TrOnLsAldJDUu4As1NToFFPe3IEpm/M2HigwCFnU6t4Zw6Ck1JhGRhgcXq5juXloKyqFnlHirmz5CaNcEAv59kSE9wVikcB3O78A/MSU0Fznk/H9+yAetJEnPr+B8RFLsLcGS8ia28+qQuX+WrPNNZOV+Nc6VH4+3iz89g0pEaLzRUiQ3LGDWsM8Qidq2WL0PGKKlgf74ZIeQTAfFJ6a44WIsDXh9OW/dPdY58aawC9KK6kpOgolO7JxViVSuBGXnvxksudZ5F0O5yzGYxMJnBOGaau4fnPU2RNAtCFBKFoa7akczaAptY2iWmjB33+yQa4kZwfjpi2ex3Dyf43vuAljWQ/4Btmei1WPj+q45hF4U+1J4fEizCEvNf0EWHoIW244sfzoN1RipaT2kDfdjfv3MNpojdISjmfIheE8Fnp8WR9vJ2Zr+O+bYUmO+kJ9KnIUtf9bnvY2x9wcqrrvnCJvfL8Tw4V9v9LU7PdKzJaoNdy645AR4ph1JMncZHRKrVvYyYY5kmP8iO1v2T3dk6HDtYmrgJtOnwKnaPFrg8z+BBX7QSgEyOPJfX9Qd9DFs40GgTOHbrBs2ch4bXFuEG2mmFkeD9hpUMk+NMXEe0TNtsg/Ly94DVurEAuxfwHC1WiVbe0U7MAAAAASUVORK5CYII=");
-    background-size: contain;
-}
-
-.header {
-    display: flex;
-    flex-wrap: wrap;
-    position: fixed;
-    top: 0;
-    left: 0;
-    width: 100%;
-    padding: 24px 24px 0 24px;
-    background-color: white;
-    z-index: 1;
-}
-
-.learn-more {
-    margin-left: auto;
-    align-self: center;
-    font-size: 0.875rem;
-    font-weight: normal;
-}
-
-.title {
-    display: flex;
-    align-items: center;
-    padding: 18px 0 24px 0;
-    flex: 1 0 100%;
-}
-
-.content {
-    font-size: 0.875rem;
-    padding: 240px 0 48px;
-    overflow-x: auto;
-    white-space: nowrap;
-}
-
-.content ol:first-of-type {
-    margin: 0;
-}
-
-.tree-btn {
-    cursor: pointer;
-    display: inline-block;
-    width: 16px;
-    height: 16px;
-    background-size: contain;
-    background-repeat: no-repeat;
-    vertical-align: middle;
-    margin-top: -0.2em;
-}
-
-.tree-btn.collapsed {
-    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 192 512"><path d="M166.9 264.5l-117.8 116c-4.7 4.7-12.3 4.7-17 0l-7.1-7.1c-4.7-4.7-4.7-12.3 0-17L127.3 256 25.1 155.6c-4.7-4.7-4.7-12.3 0-17l7.1-7.1c4.7-4.7 12.3-4.7 17 0l117.8 116c4.6 4.7 4.6 12.3-.1 17z" fill="%23999999" stroke="%23999999"/></svg>');
-}
-
-.tree-btn.expanded {
-    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 512"><path d="M119.5 326.9L3.5 209.1c-4.7-4.7-4.7-12.3 0-17l7.1-7.1c4.7-4.7 12.3-4.7 17 0L128 287.3l100.4-102.2c4.7-4.7 12.3-4.7 17 0l7.1 7.1c4.7 4.7 4.7 12.3 0 17L136.5 327c-4.7 4.6-12.3 4.6-17-.1z" fill="%23999999" stroke="%23999999"/></svg>');
-}
-
-ul .tree-btn {
-    margin-right: 3px;
-}
-
-.leaf-icon {
-    display: inline-block;
-    width: 16px;
-    height: 16px;
-    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 512"><path d="M32 256 H224" stroke="%23999999" stroke-width="48" stroke-linecap="round"/></svg>');
-    background-size: contain;
-    background-repeat: no-repeat;
-    vertical-align: middle;
-    margin-top: -0.2em;
-}
-
-.invisible-text {
-    user-select: all; /* Allow the text to be selectable */
-    color: transparent; /* Hide the text */
-    text-indent: -9999px; /* Move the text out of view */
-    position: relative;
-    white-space: pre; /* Preserve meaningful whitespace in the invisible text for copying */
-}
-
-.text-for-copy {
-    display: inline-block;
-}
-
-.enum-icon {
-    display: inline-block;
-    width: 16px;
-    height: 16px;
-    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024"><circle cx="512" cy="512" r="200" /></svg>');
-    background-size: contain;
-    background-repeat: no-repeat;
-    vertical-align: middle;
-    margin-inline-start: 0.5ex;
-    margin-inline-end: 0.5ex;
-    margin-top: -0.2em;
-}
-
-.error-icon {
-    display: inline-block;
-    width: 16px;
-    height: 16px;
-    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path d="M193.94 256L296.5 153.44l21.15-21.15c3.12-3.12 3.12-8.19 0-11.31l-22.63-22.63c-3.12-3.12-8.19-3.12-11.31 0L160 222.06 36.29 98.34c-3.12-3.12-8.19-3.12-11.31 0L2.34 120.97c-3.12 3.12-3.12 8.19 0 11.31L126.06 256 2.34 379.71c-3.12 3.12-3.12 8.19 0 11.31l22.63 22.63c3.12 3.12 8.19 3.12 11.31 0L160 289.94 262.56 392.5l21.15 21.15c3.12 3.12 8.19 3.12 11.31 0l22.63-22.63c3.12-3.12 3.12-8.19 0-11.31L193.94 256z" fill="%23FC461E" stroke="%23FC461E"/></svg>');
-    background-size: contain;
-    background-repeat: no-repeat;
-    vertical-align: middle;
-    margin-inline-start: 0.5ex;
-    margin-inline-end: 0.5ex;
-    margin-top: -0.2em;
-}
-
-.advice-icon {
-    display: inline-block;
-    width: 16px;
-    height: 16px;
-    background-image: url('data:image/svg+xml;utf8,<svg width="800px" height="800px" viewBox="-4.93 0 122.88 122.88" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  style="enable-background:new 0 0 113.01 122.88" xml:space="preserve"><g><path d="M44.13,102.06c-1.14,0.03-2.14-0.81-2.3-1.96c-0.17-1.2,0.64-2.31,1.82-2.54c-1.3-7.37-4.85-11.43-8.6-15.72 c-2.92-3.34-5.95-6.81-8.34-11.92c-2.35-5.03-3.64-10.23-3.6-15.63c0.05-5.4,1.42-10.96,4.4-16.71c0.02-0.04,0.04-0.07,0.06-0.11 l0,0c3.91-6.62,9.38-11.04,15.47-13.52c5.11-2.09,10.66-2.8,16.1-2.3c5.42,0.5,10.73,2.2,15.37,4.94 c5.9,3.49,10.75,8.67,13.42,15.21c1.44,3.54,2.42,7.49,2.54,11.82c0.12,4.31-0.62,8.96-2.61,13.88 c-2.66,6.59-6.18,10.68-9.47,14.51c-3.03,3.53-5.85,6.81-7.42,11.84c0.89,0.21,1.59,0.94,1.73,1.9c0.17,1.24-0.7,2.39-1.94,2.56 l-0.77,0.11c-0.14,1.09-0.23,2.26-0.27,3.51l0.25-0.04c1.24-0.17,2.39,0.7,2.56,1.94c0.17,1.24-0.7,2.39-1.94,2.56l-0.78,0.11 c0.01,0.15,0.02,0.3,0.03,0.45l0,0c0.07,0.88,0.08,1.73,0.03,2.54l0.13-0.02c1.25-0.15,2.38,0.74,2.54,1.98 c0.15,1.25-0.74,2.38-1.98,2.54l-1.68,0.21c-1.2,3.11-3.34,5.48-5.87,6.94c-1.74,1.01-3.67,1.59-5.61,1.71 c-1.97,0.12-3.96-0.25-5.78-1.13c-2.08-1.02-3.94-2.71-5.29-5.14c-0.65-0.33-1.13-0.97-1.23-1.75c-0.04-0.31-0.01-0.61,0.07-0.89 c-0.39-1.16-0.68-2.43-0.87-3.83l-0.07,0.01c-1.24,0.17-2.39-0.7-2.56-1.94c-0.17-1.24,0.7-2.39,1.94-2.56l0.54-0.08 C44.19,104.32,44.18,103.16,44.13,102.06L44.13,102.06z M2.18,58.86C1.01,58.89,0.04,57.98,0,56.81c-0.04-1.17,0.88-2.14,2.05-2.18 l8.7-0.3c1.17-0.04,2.14,0.88,2.18,2.05c0.04,1.17-0.88,2.14-2.05,2.18L2.18,58.86L2.18,58.86z M110.68,50.25 c1.16-0.12,2.2,0.73,2.32,1.89c0.12,1.16-0.73,2.2-1.89,2.32l-8.66,0.91c-1.16,0.12-2.2-0.73-2.32-1.89 c-0.12-1.16,0.73-2.2,1.89-2.32L110.68,50.25L110.68,50.25z M94.91,14.78c0.65-0.97,1.96-1.23,2.93-0.58 c0.97,0.65,1.23,1.96,0.58,2.93l-4.84,7.24c-0.65,0.97-1.96,1.23-2.93,0.58c-0.97-0.65-1.23-1.96-0.58-2.93L94.91,14.78 L94.91,14.78z M57.63,2.06c0.03-1.17,1-2.09,2.16-2.06c1.17,0.03,2.09,1,2.06,2.16l-0.22,8.7c-0.03,1.17-1,2.09-2.16,2.06 c-1.17-0.03-2.09-1-2.06-2.16L57.63,2.06L57.63,2.06z M13.88,15.53c-0.86-0.8-0.9-2.14-0.11-2.99c0.8-0.86,2.14-0.9,2.99-0.11 l6.37,5.94c0.86,0.8,0.9,2.14,0.11,2.99c-0.8,0.86-2.14,0.9-2.99,0.11L13.88,15.53L13.88,15.53z M47.88,96.95l18.49-2.63 c1.59-6.7,5.05-10.73,8.8-15.08c3.08-3.58,6.36-7.4,8.76-13.34c1.76-4.35,2.41-8.43,2.31-12.19c-0.1-3.75-0.96-7.21-2.24-10.34 c-2.3-5.63-6.51-10.11-11.65-13.15c-4.11-2.43-8.8-3.94-13.59-4.37c-4.77-0.44-9.64,0.19-14.13,2.02 c-5.26,2.15-9.99,5.97-13.39,11.72c-2.64,5.12-3.86,10.02-3.9,14.73c-0.04,4.74,1.11,9.33,3.2,13.8c2.13,4.56,4.97,7.8,7.69,10.92 C42.47,83.9,46.48,88.49,47.88,96.95L47.88,96.95z M65.62,99.02l-17.27,2.45c0.05,1.1,0.07,2.25,0.05,3.47l17.05-2.42 C65.47,101.29,65.52,100.12,65.62,99.02L65.62,99.02z M48.49,109.52c0.12,0.92,0.3,1.76,0.53,2.54l16.55-2.04 c0.11-0.86,0.13-1.77,0.05-2.74l0,0l0-0.02l-0.01-0.17L48.49,109.52L48.49,109.52z M51.37,116.36c0.64,0.67,1.35,1.19,2.1,1.55 c1.15,0.56,2.42,0.79,3.67,0.72c1.29-0.08,2.57-0.47,3.74-1.15c1.1-0.64,2.09-1.53,2.88-2.65L51.37,116.36L51.37,116.36z"/></g></svg>');
-    background-size: contain;
-    background-repeat: no-repeat;
-    vertical-align: middle;
-    margin-inline-start: 0.5ex;
-    margin-inline-end: 0.5ex;
-    margin-top: -0.2em;
-}
-
-.warning-icon {
-    display: inline-block;
-    width: 13px;
-    height: 13px;
-    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M270.2 160h35.5c3.4 0 6.1 2.8 6 6.2l-7.5 196c-.1 3.2-2.8 5.8-6 5.8h-20.5c-3.2 0-5.9-2.5-6-5.8l-7.5-196c-.1-3.4 2.6-6.2 6-6.2zM288 388c-15.5 0-28 12.5-28 28s12.5 28 28 28 28-12.5 28-28-12.5-28-28-28zm281.5 52L329.6 24c-18.4-32-64.7-32-83.2 0L6.5 440c-18.4 31.9 4.6 72 41.6 72H528c36.8 0 60-40 41.5-72zM528 480H48c-12.3 0-20-13.3-13.9-24l240-416c6.1-10.6 21.6-10.7 27.7 0l240 416c6.2 10.6-1.5 24-13.8 24z" fill="%23DEAD22" stroke="%23DEAD22"/></svg>');
-    background-size: contain;
-    background-repeat: no-repeat;
-    vertical-align: middle;
-    margin-inline-start: 0.3ex;
-    margin-inline-end: 1.1ex;
-    margin-top: -0.1em;
-}
-
-.documentation-button {
-    cursor: pointer;
-    display: inline-block;
-    width: 13px;
-    height: 13px;
-    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M256 340c-15.464 0-28 12.536-28 28s12.536 28 28 28 28-12.536 28-28-12.536-28-28-28zm7.67-24h-16c-6.627 0-12-5.373-12-12v-.381c0-70.343 77.44-63.619 77.44-107.408 0-20.016-17.761-40.211-57.44-40.211-29.144 0-44.265 9.649-59.211 28.692-3.908 4.98-11.054 5.995-16.248 2.376l-13.134-9.15c-5.625-3.919-6.86-11.771-2.645-17.177C185.658 133.514 210.842 116 255.67 116c52.32 0 97.44 29.751 97.44 80.211 0 67.414-77.44 63.849-77.44 107.408V304c0 6.627-5.373 12-12 12zM256 40c118.621 0 216 96.075 216 216 0 119.291-96.61 216-216 216-119.244 0-216-96.562-216-216 0-119.203 96.602-216 216-216m0-32C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8z" fill="%23999999" stroke="%23999999"/></svg>');
-    background-size: contain;
-    background-repeat: no-repeat;
-    vertical-align: middle;
-    margin-inline-start: 0.5ex;
-    margin-inline-end: 0.5ex;
-    margin-top: -0.2em;
-}
-
-.documentation-button::selection {
-    color: transparent;
-}
-
-.documentation-button:hover {
-    color: transparent;
-}
-
-.copy-button {
-    cursor: pointer;
-    display: inline-block;
-    width: 12px;
-    height: 12px;
-    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M433.941 193.941l-51.882-51.882A48 48 0 0 0 348.118 128H320V80c0-26.51-21.49-48-48-48h-66.752C198.643 13.377 180.858 0 160 0s-38.643 13.377-45.248 32H48C21.49 32 0 53.49 0 80v288c0 26.51 21.49 48 48 48h80v48c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48V227.882a48 48 0 0 0-14.059-33.941zm-22.627 22.627a15.888 15.888 0 0 1 4.195 7.432H352v-63.509a15.88 15.88 0 0 1 7.431 4.195l51.883 51.882zM160 30c9.941 0 18 8.059 18 18s-8.059 18-18 18-18-8.059-18-18 8.059-18 18-18zM48 384c-8.822 0-16-7.178-16-16V80c0-8.822 7.178-16 16-16h66.752c6.605 18.623 24.389 32 45.248 32s38.643-13.377 45.248-32H272c8.822 0 16 7.178 16 16v48H176c-26.51 0-48 21.49-48 48v208H48zm352 96H176c-8.822 0-16-7.178-16-16V176c0-8.822 7.178-16 16-16h144v72c0 13.2 10.8 24 24 24h72v208c0 8.822-7.178 16-16 16z" fill="%23999999" stroke="%23999999"/></svg>');
-    background-size: contain;
-    background-repeat: no-repeat;
-    vertical-align: middle;
-    margin-inline-start: 0.5ex;
-    margin-top: -0.2em;
-}
-
-.groups{
-    display: flex;
-    border-bottom: 1px solid #EDEEEF;
-    flex: 1 0 100%;
-}
-
-.uncategorized {
-    display: flex;
-    border-top: 4px solid #EDEEEF;
-    flex: 1 0 100%;
-}
-
-.group-selector {
-    padding: 0 52px 24px 0;
-    font-size: 0.9rem;
-    font-weight: bold;
-    color: #999999;
-    cursor: pointer;
-}
-
-.group-selector__count {
-    margin: 0 8px;
-    border-radius: 8px;
-    background-color: #999;
-    color: #fff;
-    padding: 1px 8px 2px;
-    font-size: 0.75rem;
-}
-
-.group-selector--active {
-    color: #02303A;
-    cursor: auto;
-}
-
-.group-selector--active .group-selector__count {
-    background-color: #686868;
-}
-
-.group-selector--disabled {
-    cursor: not-allowed;
-}
-
-.accordion-header {
-    cursor: pointer;
-}
-
-.container {
-    padding-left: 0.5em;
-    padding-right: 0.5em;
-}
-
-.stacktrace {
-    border-radius: 4px;
-    overflow-x: auto;
-    padding: 0.5rem;
-    margin-bottom: 0;
-    min-width: 1000px;
-}
-
-/* Lato (bold, regular) */
-@font-face {
-    font-display: swap;
-    font-family: Lato;
-    font-weight: 500;
-    font-style: normal;
-    src: url("https://assets.gradle.com/lato/fonts/lato-semibold/lato-semibold.woff2") format("woff2"),
-    url("https://assets.gradle.com/lato/fonts/lato-semibold/lato-semibold.woff") format("woff");
-}
-
-@font-face {
-    font-display: swap;
-    font-family: Lato;
-    font-weight: bold;
-    font-style: normal;
-    src: url("https://assets.gradle.com/lato/fonts/lato-bold/lato-bold.woff2") format("woff2"),
-    url("https://assets.gradle.com/lato/fonts/lato-bold/lato-bold.woff") format("woff");
-}
-
-* {
-    -webkit-box-sizing: border-box;
-    -moz-box-sizing: border-box;
-    box-sizing: border-box;
-}
-
-html,
-body {
-    margin: 0;
-    padding: 0;
-}
-
-html {
-    font-family: "Lato", "Helvetica Neue", Arial, sans-serif;
-    font-size: 16px;
-    font-weight: 400;
-    line-height: 1.5;
-}
-
-body {
-    color: #02303A;
-    background-color: #ffffff;
-    -webkit-text-size-adjust: 100%;
-    -ms-text-size-adjust: 100%;
-    -webkit-font-smoothing: antialiased;
-}
-
-
-/* typography */
-h1, h2, h3, h4, h5, h6 {
-    color: #02303A;
-    text-rendering: optimizeLegibility;
-    margin: 0;
-}
-
-h1 {
-    font-size: 1rem;
-}
-
-h2 {
-    font-size: 0.9rem;
-}
-
-h3 {
-    font-size: 1.125rem;
-}
-
-h4, h5, h6 {
-    font-size: 0.875rem;
-}
-
-h1 code {
-    font-weight: bold;
-}
-
-ul, ol, dl {
-    list-style-position: outside;
-    line-height: 1.6;
-    padding: 0;
-    margin: 0 0 0 20px;
-    list-style-type: none;
-}
-
-li {
-    line-height: 2;
-}
-
-a {
-    color: #1DA2BD;
-    text-decoration: none;
-    transition: all 0.3s ease, visibility 0s;
-}
-
-a:hover {
-    color: #35c1e4;
-}
-
-/* code */
-code, pre {
-    font-family: Inconsolata, Monaco, "Courier New", monospace;
-    font-style: normal;
-    font-variant-ligatures: normal;
-    font-variant-caps: normal;
-    font-variant-numeric: normal;
-    font-variant-east-asian: normal;
-    font-weight: normal;
-    font-stretch: normal;
-    color: #686868;
-}
-
-*:not(pre) > code {
-    letter-spacing: 0;
-    padding: 0.1em 0.5ex;
-    text-rendering: optimizeSpeed;
-    word-spacing: -0.15em;
-    word-wrap: break-word;
-}
-
-pre {
-    font-size: 0.75rem;
-    line-height: 1.8;
-    margin-top: 0;
-    margin-bottom: 1.5em;
-    padding: 1rem;
-}
-
-pre code {
-    background-color: transparent;
-    color: inherit;
-    line-height: 1.8;
-    font-size: 100%;
-    padding: 0;
-}
-
-a code {
-    color: #1BA8CB;
-}
-
-pre.code, pre.programlisting, pre.screen, pre.tt {
-    background-color: #f7f7f8;
-    border-radius: 4px;
-    font-size: 1em;
-    line-height: 1.45;
-    margin-bottom: 1.25em;
-    overflow-x: auto;
-    padding: 1rem;
-}
-
-li em, p em {
-    padding: 0 1px;
-}
-
-code em, tt em {
-    text-decoration: none;
-}
-
-code + .copy-button {
-    margin-inline-start: 0.2ex;
-}
-
-.java-exception {
-    font-size: 0.75rem;
-    padding-left: 24px;
-}
-
-.java-exception ul {
-    margin: 0;
-    line-height: inherit;
-}
-
-.java-exception code {
-    white-space: pre;
-}
-
-.java-exception-part-toggle {
-    user-select: none;
-    cursor: pointer;
-    border-radius: 2px;
-    padding: 0.1em 0.2em;
-    background: azure;
-    color: #686868;
-}
-
-                </style>
-    <!-- Inconsolata is used as a default monospace font in the report. -->
-    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inconsolata:400,700" />
-
-    <title>Gradle Configuration Cache</title>
-</head>
-<body>
-
-<div id="playground"></div>
-
-<div class="report" id="report">
-    Loading...
-</div>
-
-<script type="text/javascript">
-function configurationCacheProblems() { return (
-// begin-report-data
-{"diagnostics":[{"locations":[{"pluginId":"com.android.internal.application"}],"problem":[{"text":"Declaring client module dependencies has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 9.0."}],"contextualLabel":"Declaring client module dependencies has been deprecated.","documentationLink":"https://docs.gradle.org/8.11.1/userguide/upgrading_version_8.html#declaring_client_module_dependencies","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"declaring-client-module-dependencies","displayName":"Declaring client module dependencies has been deprecated."}],"solutions":[[{"text":"Please use component metadata rules instead."}]]},{"locations":[{"pluginId":"kotlin-android"}],"problem":[{"text":"The org.gradle.api.plugins.Convention type has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 9.0."}],"contextualLabel":"The org.gradle.api.plugins.Convention type has been deprecated.","documentationLink":"https://docs.gradle.org/8.11.1/userguide/upgrading_version_8.html#deprecated_access_to_conventions","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"the-org-gradle-api-plugins-convention-type-has-been-deprecated","displayName":"The org.gradle.api.plugins.Convention type has been deprecated."}]},{"locations":[{"pluginId":"kotlin-android"}],"problem":[{"text":"The org.gradle.api.plugins.Convention type has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 9.0."}],"contextualLabel":"The org.gradle.api.plugins.Convention type has been deprecated.","documentationLink":"https://docs.gradle.org/8.11.1/userguide/upgrading_version_8.html#deprecated_access_to_conventions","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"the-org-gradle-api-plugins-convention-type-has-been-deprecated","displayName":"The org.gradle.api.plugins.Convention type has been deprecated."}]},{"locations":[{"pluginId":"kotlin-android"}],"problem":[{"text":"The org.gradle.api.plugins.Convention type has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 9.0."}],"contextualLabel":"The org.gradle.api.plugins.Convention type has been deprecated.","documentationLink":"https://docs.gradle.org/8.11.1/userguide/upgrading_version_8.html#deprecated_access_to_conventions","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"the-org-gradle-api-plugins-convention-type-has-been-deprecated","displayName":"The org.gradle.api.plugins.Convention type has been deprecated."}]},{"locations":[{"pluginId":"kotlin-android"}],"problem":[{"text":"The org.gradle.api.plugins.Convention type has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 9.0."}],"contextualLabel":"The org.gradle.api.plugins.Convention type has been deprecated.","documentationLink":"https://docs.gradle.org/8.11.1/userguide/upgrading_version_8.html#deprecated_access_to_conventions","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"the-org-gradle-api-plugins-convention-type-has-been-deprecated","displayName":"The org.gradle.api.plugins.Convention type has been deprecated."}]},{"locations":[{"pluginId":"kotlin-android"}],"problem":[{"text":"The org.gradle.api.plugins.Convention type has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 9.0."}],"contextualLabel":"The org.gradle.api.plugins.Convention type has been deprecated.","documentationLink":"https://docs.gradle.org/8.11.1/userguide/upgrading_version_8.html#deprecated_access_to_conventions","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"the-org-gradle-api-plugins-convention-type-has-been-deprecated","displayName":"The org.gradle.api.plugins.Convention type has been deprecated."}]},{"locations":[{"pluginId":"kotlin-android"}],"problem":[{"text":"The org.gradle.api.plugins.Convention type has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 9.0."}],"contextualLabel":"The org.gradle.api.plugins.Convention type has been deprecated.","documentationLink":"https://docs.gradle.org/8.11.1/userguide/upgrading_version_8.html#deprecated_access_to_conventions","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"the-org-gradle-api-plugins-convention-type-has-been-deprecated","displayName":"The org.gradle.api.plugins.Convention type has been deprecated."}]},{"locations":[{"pluginId":"kotlin-android"}],"problem":[{"text":"The org.gradle.api.plugins.Convention type has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 9.0."}],"contextualLabel":"The org.gradle.api.plugins.Convention type has been deprecated.","documentationLink":"https://docs.gradle.org/8.11.1/userguide/upgrading_version_8.html#deprecated_access_to_conventions","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"the-org-gradle-api-plugins-convention-type-has-been-deprecated","displayName":"The org.gradle.api.plugins.Convention type has been deprecated."}]},{"locations":[{"pluginId":"kotlin-android"}],"problem":[{"text":"The org.gradle.api.plugins.Convention type has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 9.0."}],"contextualLabel":"The org.gradle.api.plugins.Convention type has been deprecated.","documentationLink":"https://docs.gradle.org/8.11.1/userguide/upgrading_version_8.html#deprecated_access_to_conventions","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"the-org-gradle-api-plugins-convention-type-has-been-deprecated","displayName":"The org.gradle.api.plugins.Convention type has been deprecated."}]},{"locations":[{"pluginId":"kotlin-android"}],"problem":[{"text":"The org.gradle.api.plugins.Convention type has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 9.0."}],"contextualLabel":"The org.gradle.api.plugins.Convention type has been deprecated.","documentationLink":"https://docs.gradle.org/8.11.1/userguide/upgrading_version_8.html#deprecated_access_to_conventions","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"the-org-gradle-api-plugins-convention-type-has-been-deprecated","displayName":"The org.gradle.api.plugins.Convention type has been deprecated."}]},{"locations":[{"pluginId":"kotlin-android"}],"problem":[{"text":"The org.gradle.api.plugins.Convention type has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 9.0."}],"contextualLabel":"The org.gradle.api.plugins.Convention type has been deprecated.","documentationLink":"https://docs.gradle.org/8.11.1/userguide/upgrading_version_8.html#deprecated_access_to_conventions","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"the-org-gradle-api-plugins-convention-type-has-been-deprecated","displayName":"The org.gradle.api.plugins.Convention type has been deprecated."}]},{"locations":[{"pluginId":"kotlin-android"}],"problem":[{"text":"The org.gradle.api.plugins.Convention type has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 9.0."}],"contextualLabel":"The org.gradle.api.plugins.Convention type has been deprecated.","documentationLink":"https://docs.gradle.org/8.11.1/userguide/upgrading_version_8.html#deprecated_access_to_conventions","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"the-org-gradle-api-plugins-convention-type-has-been-deprecated","displayName":"The org.gradle.api.plugins.Convention type has been deprecated."}]},{"locations":[{"pluginId":"kotlin-android"}],"problem":[{"text":"The org.gradle.api.plugins.Convention type has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 9.0."}],"contextualLabel":"The org.gradle.api.plugins.Convention type has been deprecated.","documentationLink":"https://docs.gradle.org/8.11.1/userguide/upgrading_version_8.html#deprecated_access_to_conventions","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"the-org-gradle-api-plugins-convention-type-has-been-deprecated","displayName":"The org.gradle.api.plugins.Convention type has been deprecated."}]},{"locations":[{"pluginId":"kotlin-android"}],"problem":[{"text":"The org.gradle.api.plugins.Convention type has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 9.0."}],"contextualLabel":"The org.gradle.api.plugins.Convention type has been deprecated.","documentationLink":"https://docs.gradle.org/8.11.1/userguide/upgrading_version_8.html#deprecated_access_to_conventions","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"the-org-gradle-api-plugins-convention-type-has-been-deprecated","displayName":"The org.gradle.api.plugins.Convention type has been deprecated."}]},{"locations":[{"pluginId":"kotlin-android"}],"problem":[{"text":"The org.gradle.api.plugins.Convention type has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 9.0."}],"contextualLabel":"The org.gradle.api.plugins.Convention type has been deprecated.","documentationLink":"https://docs.gradle.org/8.11.1/userguide/upgrading_version_8.html#deprecated_access_to_conventions","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"the-org-gradle-api-plugins-convention-type-has-been-deprecated","displayName":"The org.gradle.api.plugins.Convention type has been deprecated."}]},{"locations":[{"pluginId":"kotlin-android"}],"problem":[{"text":"The org.gradle.api.plugins.Convention type has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 9.0."}],"contextualLabel":"The org.gradle.api.plugins.Convention type has been deprecated.","documentationLink":"https://docs.gradle.org/8.11.1/userguide/upgrading_version_8.html#deprecated_access_to_conventions","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"the-org-gradle-api-plugins-convention-type-has-been-deprecated","displayName":"The org.gradle.api.plugins.Convention type has been deprecated."}]},{"locations":[{"pluginId":"kotlin-android"}],"problem":[{"text":"The org.gradle.api.plugins.Convention type has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 9.0."}],"contextualLabel":"The org.gradle.api.plugins.Convention type has been deprecated.","documentationLink":"https://docs.gradle.org/8.11.1/userguide/upgrading_version_8.html#deprecated_access_to_conventions","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"the-org-gradle-api-plugins-convention-type-has-been-deprecated","displayName":"The org.gradle.api.plugins.Convention type has been deprecated."}]},{"locations":[{"pluginId":"com.android.internal.library"}],"problem":[{"text":"Declaring client module dependencies has been deprecated."}],"severity":"WARNING","problemDetails":[{"text":"This is scheduled to be removed in Gradle 9.0."}],"contextualLabel":"Declaring client module dependencies has been deprecated.","documentationLink":"https://docs.gradle.org/8.11.1/userguide/upgrading_version_8.html#declaring_client_module_dependencies","problemId":[{"name":"deprecation","displayName":"Deprecation"},{"name":"declaring-client-module-dependencies","displayName":"Declaring client module dependencies has been deprecated."}],"solutions":[[{"text":"Please use component metadata rules instead."}]]}],"problemsReport":{"totalProblemCount":18,"buildName":"android","requestedTasks":"assembleRelease","documentationLink":"https://docs.gradle.org/8.11.1/userguide/problems-report.html","documentationLinkCaption":"Problem report"}}
-// end-report-data
-);}
-</script>
-                <script type="text/javascript">
-                !function(n,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports["configuration-cache-report"]=t():n["configuration-cache-report"]=t()}(this,(()=>(({70:function(){void 0===ArrayBuffer.isView&&(ArrayBuffer.isView=function(n){return null!=n&&null!=n.__proto__&&n.__proto__.__proto__===Int8Array.prototype.__proto__}),void 0===Math.imul&&(Math.imul=function(n,t){return(4294901760&n)*(65535&t)+(65535&n)*(0|t)|0}),this["configuration-cache-report"]=function(n){"use strict";var t,r,i,e,u,o,f,s,c,a,h,l,_,v,d,g,w,b,p,m,k,q,y,B,C,x,j,P,I,S,z,E,T,L,N,A,M,F,D,O,R,H,$,G,U,V,Q,Z,Y,W,K,X,J,nn,tn,rn,en,un,on,fn,sn,cn,an,hn,ln,_n,vn,dn,gn,wn,bn,pn,mn,kn,qn,yn,Bn,Cn,xn,jn,Pn,In,Sn,zn=Math.imul,En=ArrayBuffer.isView;function Tn(n,t){if(!(t>=0))throw ou(re("Requested element count "+t+" is less than zero."));return function(n,t){if(!(t>=0))throw ou(re("Requested element count "+t+" is less than zero."));if(0===t)return bt();if(t>=n.length)return An(n);if(1===t)return dr(n[0]);var r=0,i=Lr(),e=0,u=n.length;n:for(;e<u;){var o=n[e];if(e=e+1|0,i.d(o),(r=r+1|0)===t)break n}return i}(n,Wn(n.length-t|0,0))}function Ln(n){return n.length-1|0}function Nn(n,t){if(null==t){var r=0,i=n.length-1|0;if(r<=i)do{var e=r;if(r=r+1|0,null==n[e])return e}while(r<=i)}else{var u=0,o=n.length-1|0;if(u<=o)do{var f=u;if(u=u+1|0,ue(t,n[f]))return f}while(u<=o)}return-1}function An(n){switch(n.length){case 0:return bt();case 1:return dr(n[0]);default:return function(n){return Nr(function(n){return new qt(n,!1)}(n))}(n)}}function Mn(n,t,r,i,e,u,o){return t=t===A?", ":t,r=r===A?"":r,i=i===A?"":i,e=e===A?-1:e,u=u===A?"...":u,o=o===A?null:o,Fn(n,wi(),t,r,i,e,u,o).toString()}function Fn(n,t,r,i,e,u,o,f){r=r===A?", ":r,i=i===A?"":i,e=e===A?"":e,u=u===A?-1:u,o=o===A?"...":o,f=f===A?null:f,t.e(i);var s=0,c=n.f();n:for(;c.g();){var a=c.h();if((s=s+1|0)>1&&t.e(r),!(u<0||s<=u))break n;Vt(t,a,f)}return u>=0&&s>u&&t.e(o),t.e(e),t}function Dn(n){if(n.i())throw pu("List is empty.");return n.j(0)}function On(n){return new Zn(n)}function Rn(n){if(Ge(n,Ei)){var t;switch(n.k()){case 0:t=bt();break;case 1:t=dr(Ge(n,zi)?n.j(0):n.f().h());break;default:t=$n(n)}return t}return pt(Un(n))}function Hn(n){if(Ge(n,Ei)&&n.k()<=1)return Rn(n);var t=Un(n);return function(n){var t=(n.k()/2|0)-1|0;if(t<0)return hr();var r=mt(n),i=0;if(i<=t)do{var e=i;i=i+1|0;var u=n.j(e);n.f4(e,n.j(r)),n.f4(r,u),r=r-1|0}while(e!==t)}(t),t}function $n(n){return Nr(n)}function Gn(n,t){if(!(t>=0))throw ou(re("Requested element count "+t+" is less than zero."));if(0===t)return bt();var r=n.k();if(t>=r)return Rn(n);if(1===t)return dr(Vn(n));var i=Lr();if(Ge(n,hi)){var e=r-t|0;if(e<r)do{var u=e;e=e+1|0,i.d(n.j(u))}while(e<r)}else for(var o=n.l(r-t|0);o.g();){var f=o.h();i.d(f)}return i}function Un(n){return Ge(n,Ei)?$n(n):Qn(n,Tr())}function Vn(n){if(n.i())throw pu("List is empty.");return n.j(mt(n))}function Qn(n,t){for(var r=n.f();r.g();){var i=r.h();t.d(i)}return t}function Zn(n){this.n_1=n}function Yn(n,t){return n>t?t:n}function Wn(n,t){return n<t?t:n}function Kn(n,t){return Gt().q(n,t,-1)}function Xn(n,t){return new zt(n,t)}function Jn(n){var t=n.f();if(!t.g())return bt();var r=t.h();if(!t.g())return dr(r);var i=Tr();for(i.d(r);t.g();)i.d(t.h());return i}function nt(n){this.r_1=n}function tt(n,t){this.s_1=n,this.t_1=t}function rt(){}function it(n){this.x_1=n,this.w_1=0}function et(n,t){this.a1_1=n,it.call(this,n),ot().b1(t,this.a1_1.k()),this.w_1=t}function ut(){t=this}function ot(){return null==t&&new ut,t}function ft(){ot(),rt.call(this)}function st(n){this.h1_1=n}function ct(n,t){return t===n?"(this Map)":Di(t)}function at(n,t){var r;n:{for(var i=n.o().f();i.g();){var e=i.h();if(ue(e.j1(),t)){r=e;break n}}r=null}return r}function ht(){r=this}function lt(){return null==r&&new ht,r}function _t(n){this.q1_1=n,rt.call(this)}function vt(){lt(),this.n1_1=null,this.o1_1=null}function dt(){i=this}function gt(){return null==i&&new dt,i}function wt(n){return n.length>0?Je(n):bt()}function bt(){return null==e&&new kt,e}function pt(n){switch(n.k()){case 0:return bt();case 1:return dr(n.j(0));default:return n}}function mt(n){return n.k()-1|0}function kt(){e=this,this.z1_1=new ve(-1478467534,-1720727600)}function qt(n,t){this.b2_1=n,this.c2_1=t}function yt(){u=this}function Bt(){return null==u&&new yt,u}function Ct(n,t){return Ge(n,Ei)?n.k():t}function xt(n,t){if(Ge(t,Ei))return n.m(t);for(var r=!1,i=t.f();i.g();){var e=i.h();n.d(e)&&(r=!0)}return r}function jt(){}function Pt(n,t){this.h2_1=n,this.g2_1=n.i2_1.l(function(n,t){if(!(0<=t&&t<=n.k()))throw su("Position index "+t+" must be in range ["+De(0,n.k())+"].");return n.k()-t|0}(n,t))}function It(n){ft.call(this),this.i2_1=n}function St(n){this.k2_1=n,this.j2_1=n.l2_1.f()}function zt(n,t){this.l2_1=n,this.m2_1=t}function Et(n){for(;n.n2_1.g();){var t=n.n2_1.h();if(n.q2_1.t2_1(t)===n.q2_1.s2_1)return n.p2_1=t,n.o2_1=1,hr()}n.o2_1=0}function Tt(n){this.q2_1=n,this.n2_1=n.r2_1.f(),this.o2_1=-1,this.p2_1=null}function Lt(n,t,r){t=t===A||t,this.r2_1=n,this.s2_1=t,this.t2_1=r}function Nt(){return null==o&&new At,o}function At(){o=this,this.u2_1=new ve(1993859828,793161749)}function Mt(n,t,r){return Ft(Ft(n,r)-Ft(t,r)|0,r)}function Ft(n,t){var r=n%t|0;return r>=0?r:r+t|0}function Dt(){f=this,this.p_1=new Rt(1,0)}function Ot(){return null==f&&new Dt,f}function Rt(n,t){Ot(),Ut.call(this,n,t,1)}function Ht(n,t,r){jt.call(this),this.d3_1=r,this.e3_1=t,this.f3_1=this.d3_1>0?n<=t:n>=t,this.g3_1=this.f3_1?n:this.e3_1}function $t(){s=this}function Gt(){return null==s&&new $t,s}function Ut(n,t,r){if(Gt(),0===r)throw ou("Step must be non-zero.");if(r===_r().MIN_VALUE)throw ou("Step must be greater than Int.MIN_VALUE to avoid overflow on negation.");this.z2_1=n,this.a3_1=function(n,t,r){var i;if(r>0)i=n>=t?t:t-Mt(t,n,r)|0;else{if(!(r<0))throw ou("Step is zero.");i=n<=t?t:t+Mt(n,t,0|-r)|0}return i}(n,t,r),this.b3_1=r}function Vt(n,t,r){null!=r?n.e(r(t)):null==t||Qe(t)?n.e(t):t instanceof Si?n.i3(t.h3_1):n.e(Di(t))}function Qt(n,t,r){if(n===t)return!0;if(!(r=r!==A&&r))return!1;var i=pi(n),e=pi(t);return i===e||ue(new Si(Qi(ji(i).toLowerCase(),0)),new Si(Qi(ji(e).toLowerCase(),0)))}function Zt(n){return Yi(n)-1|0}function Yt(n,t,r,i){return r=r===A?0:r,(i=i!==A&&i)||"string"!=typeof n?Wt(n,t,r,Yi(n),i):n.indexOf(t,r)}function Wt(n,t,r,i,e,u){var o=(u=u!==A&&u)?Kn(Yn(r,Zt(n)),Wn(i,0)):De(Wn(r,0),Yn(i,Yi(n)));if("string"==typeof n&&"string"==typeof t){var f=o.z2_1,s=o.a3_1,c=o.b3_1;if(c>0&&f<=s||c<0&&s<=f)do{var a=f;if(f=f+c|0,Ci(t,0,n,a,Yi(t),e))return a}while(a!==s)}else{var h=o.z2_1,l=o.a3_1,_=o.b3_1;if(_>0&&h<=l||_<0&&l<=h)do{var v=h;if(h=h+_|0,nr(t,0,n,v,Yi(t),e))return v}while(v!==l)}return-1}function Kt(n){var t=0,r=Yi(n)-1|0,i=!1;n:for(;t<=r;){var e=mi(Qi(n,i?r:t));if(i){if(!e)break n;r=r-1|0}else e?t=t+1|0:i=!0}return Wi(n,t,r+1|0)}function Xt(n,t){return re(Wi(n,t.y2(),t.c3()+1|0))}function Jt(n,t,r,i,e){r=r===A?0:r,i=i!==A&&i,tr(e=e===A?0:e);var u,o,f=Je(t);return new er(n,r,e,(u=f,o=i,function(n,t){var r=function(n,t,r,i){if(!i&&1===t.k()){var e=function(n){if(Ge(n,zi))return function(n){var t;switch(n.k()){case 0:throw pu("List is empty.");case 1:t=n.j(0);break;default:throw ou("List has more than one element.")}return t}(n);var t=n.f();if(!t.g())throw pu("Collection is empty.");var r=t.h();if(t.g())throw ou("Collection has more than one element.");return r}(t),u=Yt(n,e,r);return u<0?null:or(u,e)}var o=De(Wn(r,0),Yi(n));if("string"==typeof n){var f=o.z2_1,s=o.a3_1,c=o.b3_1;if(c>0&&f<=s||c<0&&s<=f)do{var a,h=f;f=f+c|0;n:{for(var l=t.f();l.g();){var _=l.h();if(Ci(_,0,n,h,_.length,i)){a=_;break n}}a=null}if(null!=a)return or(h,a)}while(h!==s)}else{var v=o.z2_1,d=o.a3_1,g=o.b3_1;if(g>0&&v<=d||g<0&&d<=v)do{var w,b=v;v=v+g|0;n:{for(var p=t.f();p.g();){var m=p.h();if(nr(m,0,n,b,m.length,i)){w=m;break n}}w=null}if(null!=w)return or(b,w)}while(b!==d)}return null}(n,u,t,o);return null==r?null:or(r.t3_1,r.u3_1.length)}))}function nr(n,t,r,i,e,u){if(i<0||t<0||t>(Yi(n)-e|0)||i>(Yi(r)-e|0))return!1;var o=0;if(o<e)do{var f=o;if(o=o+1|0,!Qt(Qi(n,t+f|0),Qi(r,i+f|0),u))return!1}while(o<e);return!0}function tr(n){if(!(n>=0))throw ou(re("Limit must be non-negative, but was "+n))}function rr(n){if(n.l3_1<0)n.j3_1=0,n.m3_1=null;else{var t;if(n.o3_1.r3_1>0?(n.n3_1=n.n3_1+1|0,t=n.n3_1>=n.o3_1.r3_1):t=!1,t||n.l3_1>Yi(n.o3_1.p3_1))n.m3_1=De(n.k3_1,Zt(n.o3_1.p3_1)),n.l3_1=-1;else{var r=n.o3_1.s3_1(n.o3_1.p3_1,n.l3_1);if(null==r)n.m3_1=De(n.k3_1,Zt(n.o3_1.p3_1)),n.l3_1=-1;else{var i=r.v3(),e=r.w3();n.m3_1=function(n,t){return t<=_r().MIN_VALUE?Ot().p_1:De(n,t-1|0)}(n.k3_1,i),n.k3_1=i+e|0,n.l3_1=n.k3_1+(0===e?1:0)|0}}n.j3_1=1}}function ir(n){this.o3_1=n,this.j3_1=-1,this.k3_1=function(n,t,r){if(0>r)throw ou("Cannot coerce value to an empty range: maximum "+r+" is less than minimum 0.");return n<0?0:n>r?r:n}(n.q3_1,0,Yi(n.p3_1)),this.l3_1=this.k3_1,this.m3_1=null,this.n3_1=0}function er(n,t,r,i){this.p3_1=n,this.q3_1=t,this.r3_1=r,this.s3_1=i}function ur(n,t){this.t3_1=n,this.u3_1=t}function or(n,t){return new ur(n,t)}function fr(){}function sr(){}function cr(){}function ar(){c=this}function hr(){return null==c&&new ar,c}function lr(){a=this,this.MIN_VALUE=-2147483648,this.MAX_VALUE=2147483647,this.SIZE_BYTES=4,this.SIZE_BITS=32}function _r(){return null==a&&new lr,a}function vr(n){for(var t=[],r=n.f();r.g();)t.push(r.h());return t}function dr(n){return 0===(t=[n]).length?Tr():Nr(new qt(t,!0));var t}function gr(n){return n<0&&function(){throw ku("Index overflow has happened.")}(),n}function wr(n){return void 0!==n.toArray?n.toArray():vr(n)}function br(n){return function(n,t){for(var r=0,i=n.length;r<i;){var e=n[r];r=r+1|0,t.d(e)}return t}(t=[n],(r=t.length,i=se(fe(Qr)),function(n,t,r){Sr.call(r),Qr.call(r),r.y5_1=function(n){return Gr(n,0,se(fe(Ur)))}(n)}(r,0,i),i));var t,r,i}function pr(){rt.call(this)}function mr(n){this.j4_1=n,this.h4_1=0,this.i4_1=-1}function kr(n,t){this.n4_1=n,mr.call(this,n),ot().b1(t,this.n4_1.k()),this.h4_1=t}function qr(){pr.call(this),this.o4_1=0}function yr(n){this.r4_1=n}function Br(n){this.s4_1=n}function Cr(n,t){this.t4_1=n,this.u4_1=t}function xr(){Sr.call(this)}function jr(n){this.x4_1=n,Sr.call(this)}function Pr(n){this.e5_1=n,pr.call(this)}function Ir(){vt.call(this),this.c5_1=null,this.d5_1=null}function Sr(){pr.call(this)}function zr(){h=this;var n=Lr();n.c_1=!0,this.i5_1=n}function Er(){return null==h&&new zr,h}function Tr(){return n=se(fe(Mr)),t=[],Mr.call(n,t),n;var n,t}function Lr(n){return t=se(fe(Mr)),r=[],Mr.call(t,r),t;var t,r}function Nr(n){return function(n,t){var r;return r=wr(n),Mr.call(t,r),t}(n,se(fe(Mr)))}function Ar(n,t){return ot().e1(t,n.k()),t}function Mr(n){Er(),qr.call(this),this.b_1=n,this.c_1=!1}function Fr(n,t,r,i,e){if(r===i)return n;var u=(r+i|0)/2|0,o=Fr(n,t,r,u,e),f=Fr(n,t,u+1|0,i,e),s=o===t?n:t,c=r,a=u+1|0,h=r;if(h<=i)do{var l=h;if(h=h+1|0,c<=u&&a<=i){var _=o[c],v=f[a];e.compare(_,v)<=0?(s[l]=_,c=c+1|0):(s[l]=v,a=a+1|0)}else c<=u?(s[l]=o[c],c=c+1|0):(s[l]=f[a],a=a+1|0)}while(l!==i);return s}function Dr(n,t){return(3&n)-(3&t)|0}function Or(){_=this}function Rr(n){this.n5_1=n,xr.call(this)}function Hr(n){return function(n,t){Ir.call(t),Ur.call(t),t.t5_1=n,t.u5_1=n.w5()}(new Xr((null==_&&new Or,_)),n),n}function $r(){return Hr(se(fe(Ur)))}function Gr(n,t,r){if(Hr(r),!(n>=0))throw ou(re("Negative initial capacity: "+n));if(!(t>=0))throw ou(re("Non-positive load factor: "+t));return r}function Ur(){this.v5_1=null}function Vr(n,t){return Sr.call(t),Qr.call(t),t.y5_1=n,t}function Qr(){}function Zr(n,t){var r=Wr(n,n.h6_1.m5(t));if(null==r)return null;var i=r;if(null!=i&&Ue(i))return Yr(i,n,t);var e=i;return n.h6_1.l5(e.j1(),t)?e:null}function Yr(n,t,r){var i;n:{for(var e=0,u=n.length;e<u;){var o=n[e];if(e=e+1|0,t.h6_1.l5(o.j1(),r)){i=o;break n}}i=null}return i}function Wr(n,t){var r=n.i6_1[t];return void 0===r?null:r}function Kr(n){this.g6_1=n,this.z5_1=-1,this.a6_1=Object.keys(n.i6_1),this.b6_1=-1,this.c6_1=null,this.d6_1=!1,this.e6_1=-1,this.f6_1=null}function Xr(n){this.h6_1=n,this.i6_1=this.k6(),this.j6_1=0}function Jr(){}function ni(n){this.n6_1=n,this.l6_1=null,this.m6_1=null,this.m6_1=this.n6_1.y6_1.v6_1}function ti(){v=this;var n,t=(oi(0,0,n=se(fe(fi))),n);t.x6_1=!0,this.e7_1=t}function ri(){return null==v&&new ti,v}function ii(n,t,r){this.d7_1=n,Cr.call(this,t,r),this.b7_1=null,this.c7_1=null}function ei(n){this.y6_1=n,xr.call(this)}function ui(){return Hr(n=se(fe(fi))),fi.call(n),n.w6_1=$r(),n;var n}function oi(n,t,r){return Gr(n,t,r),fi.call(r),r.w6_1=$r(),r}function fi(){ri(),this.v6_1=null,this.x6_1=!1}function si(){d=this;var n=ci(0),t=n.y5_1;(t instanceof fi?t:le()).j5(),this.f7_1=n}function ci(n){return function(n,t){return function(n,t,r){Vr(function(n,t){return oi(n,t,se(fe(fi)))}(n,t),r),ai.call(r)}(n,0,t),t}(n,se(fe(ai)))}function ai(){null==d&&new si}function hi(){}function li(){}function _i(n){li.call(this),this.k7_1=n}function vi(){di.call(this)}function di(){li.call(this),this.m7_1=""}function gi(){if(!w){w=!0;var n="undefined"!=typeof process&&process.versions&&!!process.versions.node;g=n?new _i(process.stdout):new vi}}function wi(){return n=se(fe(bi)),bi.call(n,""),n;var n}function bi(n){this.o7_1=void 0!==n?n:""}function pi(n){var t=ji(n).toUpperCase();return t.length>1?n:Qi(t,0)}function mi(n){return function(n){return 9<=n&&n<=13||28<=n&&n<=32||160===n||n>4096&&(5760===n||8192<=n&&n<=8202||8232===n||8233===n||8239===n||8287===n||12288===n)}(n)}function ki(){b=this,this.q7_1=new RegExp("[\\\\^$*+?.()|[\\]{}]","g"),this.r7_1=new RegExp("[\\\\$]","g"),this.s7_1=new RegExp("\\$","g")}function qi(){return null==b&&new ki,b}function yi(n,t){qi(),this.v7_1=n,this.w7_1=function(n){if(Ge(n,Ei)){var t;switch(n.k()){case 0:t=Nt();break;case 1:t=br(Ge(n,zi)?n.j(0):n.f().h());break;default:t=Qn(n,ci(n.k()))}return t}return function(n){switch(n.k()){case 0:return Nt();case 1:return br(n.f().h());default:return n}}(Qn(n,(r=se(fe(ai)),Vr(ui(),r),ai.call(r),r)));var r}(t),this.x7_1=new RegExp(n,Mn(t,"","gu",A,A,A,Bi)),this.y7_1=null,this.z7_1=null}function Bi(n){return n.d8_1}function Ci(n,t,r,i,e,u){return nr(n,t,r,i,e,u=u!==A&&u)}function xi(n,t){return n-t|0}function ji(n){return String.fromCharCode(n)}function Pi(){p=this,this.e8_1=0,this.f8_1=65535,this.g8_1=55296,this.h8_1=56319,this.i8_1=56320,this.j8_1=57343,this.k8_1=55296,this.l8_1=57343,this.m8_1=2,this.n8_1=16}function Ii(){return null==p&&new Pi,p}function Si(n){Ii(),this.h3_1=n}function zi(){}function Ei(){}function Ti(){}function Li(){}function Ni(){}function Ai(){}function Mi(){m=this}function Fi(n,t){null==m&&new Mi,this.p8_1=n,this.q8_1=t}function Di(n){var t=null==n?null:re(n);return null==t?"null":t}function Oi(n){return new Ri(n)}function Ri(n){this.t8_1=n,this.s8_1=0}function Hi(){return Vi(),k}function $i(){return Vi(),q}function Gi(){return Vi(),y}function Ui(){return Vi(),B}function Vi(){x||(x=!0,k=new ArrayBuffer(8),q=new Float64Array(Hi()),new Float32Array(Hi()),y=new Int32Array(Hi()),$i()[0]=-1,B=0!==Gi()[0]?1:0,C=1-Ui()|0)}function Qi(n,t){var r;if(Zi(n)){var i,e=n.charCodeAt(t);if(Ii(),e<0?i=!0:(Ii(),i=e>65535),i)throw ou("Invalid Char code: "+e);r=Fe(e)}else r=n.y3(t);return r}function Zi(n){return"string"==typeof n}function Yi(n){return Zi(n)?n.length:n.x3()}function Wi(n,t,r){return Zi(n)?n.substring(t,r):n.z3(t,r)}function Ki(n){return re(n)}function Xi(n,t){var r;switch(typeof n){case"number":r="number"==typeof t?Ji(n,t):t instanceof ve?Ji(n,t.w8()):ne(n,t);break;case"string":case"boolean":r=ne(n,t);break;default:r=function(n,t){return n.a4(t)}(n,t)}return r}function Ji(n,t){var r;if(n<t)r=-1;else if(n>t)r=1;else if(n===t){var i;if(0!==n)i=0;else{var e=1/n;i=e===1/t?0:e<0?-1:1}r=i}else r=n!=n?t!=t?0:1:-1;return r}function ne(n,t){return n<t?-1:n>t?1:0}function te(n){if(!("kotlinHashCodeValue$"in n)){var t=4294967296*Math.random()|0,r=new Object;r.value=t,r.enumerable=!1,Object.defineProperty(n,"kotlinHashCodeValue$",r)}return n.kotlinHashCodeValue$}function re(n){return null==n?"null":function(n){return!!He(n)||En(n)}(n)?"[...]":n.toString()}function ie(n){if(null==n)return 0;var t;switch(typeof n){case"object":t="function"==typeof n.hashCode?n.hashCode():te(n);break;case"function":t=te(n);break;case"number":t=function(n){return Vi(),(0|n)===n?Me(n):($i()[0]=n,zn(Gi()[(Vi(),C)],31)+Gi()[Ui()]|0)}(n);break;case"boolean":t=n?1:0;break;default:t=ee(String(n))}return t}function ee(n){var t=0,r=0,i=n.length-1|0;if(r<=i)do{var e=r;r=r+1|0;var u=n.charCodeAt(e);t=zn(t,31)+u|0}while(e!==i);return t}function ue(n,t){return null==n?null==t:null!=t&&("object"==typeof n&&"function"==typeof n.equals?n.equals(t):n!=n?t!=t:"number"==typeof n&&"number"==typeof t?n===t&&(0!==n||1/n==1/t):n===t)}function oe(n,t){null!=Error.captureStackTrace?Error.captureStackTrace(n,t):n.stack=(new Error).stack}function fe(n){return n.prototype}function se(n){return Object.create(n)}function ce(n,t,r){Error.call(n),function(n,t,r){var i=Ke(Object.getPrototypeOf(n));if(!(1&i)){var e;if(null==t){var u;if(null!==t){var o=null==r?null:r.toString();u=null==o?A:o}else u=A;e=u}else e=t;n.message=e}2&i||(n.cause=r),n.name=Object.getPrototypeOf(n).constructor.name}(n,t,r)}function ae(n){var t;return null==n?function(){throw xu()}():t=n,t}function he(){throw Pu()}function le(){throw Su()}function _e(){j=this,this.x8_1=new ve(0,-2147483648),this.y8_1=new ve(-1,2147483647),this.z8_1=8,this.a9_1=64}function ve(n,t){null==j&&new _e,cr.call(this),this.u8_1=n,this.v8_1=t}function de(){return Ae(),P}function ge(){return Ae(),I}function we(){return Ae(),S}function be(){return Ae(),E}function pe(){return Ae(),T}function me(n,t){if(Ae(),Ce(n,t))return 0;var r=Pe(n),i=Pe(t);return r&&!i?-1:!r&&i?1:Pe(qe(n,t))?-1:1}function ke(n,t){Ae();var r=n.v8_1>>>16|0,i=65535&n.v8_1,e=n.u8_1>>>16|0,u=65535&n.u8_1,o=t.v8_1>>>16|0,f=65535&t.v8_1,s=t.u8_1>>>16|0,c=0,a=0,h=0,l=0;return c=(c=c+((a=(a=a+((h=(h=h+((l=l+(u+(65535&t.u8_1)|0)|0)>>>16|0)|0)+(e+s|0)|0)>>>16|0)|0)+(i+f|0)|0)>>>16|0)|0)+(r+o|0)|0,new ve((h&=65535)<<16|(l&=65535),(c&=65535)<<16|(a&=65535))}function qe(n,t){return Ae(),ke(n,t.e9())}function ye(n,t){if(Ae(),Ie(n))return de();if(Ie(t))return de();if(Ce(n,be()))return Se(t)?be():de();if(Ce(t,be()))return Se(n)?be():de();if(Pe(n))return Pe(t)?ye(ze(n),ze(t)):ze(ye(ze(n),t));if(Pe(t))return ze(ye(n,ze(t)));if(Ee(n,pe())&&Ee(t,pe()))return Te(Be(n)*Be(t));var r=n.v8_1>>>16|0,i=65535&n.v8_1,e=n.u8_1>>>16|0,u=65535&n.u8_1,o=t.v8_1>>>16|0,f=65535&t.v8_1,s=t.u8_1>>>16|0,c=65535&t.u8_1,a=0,h=0,l=0,_=0;return l=l+((_=_+zn(u,c)|0)>>>16|0)|0,_&=65535,h=(h=h+((l=l+zn(e,c)|0)>>>16|0)|0)+((l=(l&=65535)+zn(u,s)|0)>>>16|0)|0,l&=65535,a=(a=(a=a+((h=h+zn(i,c)|0)>>>16|0)|0)+((h=(h&=65535)+zn(e,s)|0)>>>16|0)|0)+((h=(h&=65535)+zn(u,f)|0)>>>16|0)|0,h&=65535,a=a+(((zn(r,c)+zn(i,s)|0)+zn(e,f)|0)+zn(u,o)|0)|0,new ve(l<<16|_,(a&=65535)<<16|h)}function Be(n){return Ae(),4294967296*n.v8_1+function(n){return Ae(),n.u8_1>=0?n.u8_1:4294967296+n.u8_1}(n)}function Ce(n,t){return Ae(),n.v8_1===t.v8_1&&n.u8_1===t.u8_1}function xe(n,t){if(Ae(),t<2||36<t)throw _u("radix out of range: "+t);if(Ie(n))return"0";if(Pe(n)){if(Ce(n,be())){var r=je(t),i=n.d9(r),e=qe(ye(i,r),n).g9();return xe(i,t)+e.toString(t)}return"-"+xe(ze(n),t)}for(var u=2===t?31:t<=10?9:t<=21?7:t<=35?6:5,o=Te(Math.pow(t,u)),f=n,s="";;){var c=f.d9(o),a=qe(f,ye(c,o)).g9().toString(t);if(Ie(f=c))return a+s;for(;a.length<u;)a="0"+a;s=a+s}}function je(n){return Ae(),new ve(n,n<0?-1:0)}function Pe(n){return Ae(),n.v8_1<0}function Ie(n){return Ae(),0===n.v8_1&&0===n.u8_1}function Se(n){return Ae(),!(1&~n.u8_1)}function ze(n){return Ae(),n.e9()}function Ee(n,t){return Ae(),me(n,t)<0}function Te(n){if(Ae(),(t=n)!=t)return de();if(n<=-0x8000000000000000)return be();if(n+1>=0x8000000000000000)return Ae(),z;if(n<0)return ze(Te(-n));var t,r=4294967296;return new ve(n%r|0,n/r|0)}function Le(n,t){return Ae(),me(n,t)>0}function Ne(n,t){return Ae(),me(n,t)>=0}function Ae(){L||(L=!0,P=je(0),I=je(1),S=je(-1),z=new ve(-1,2147483647),E=new ve(0,-2147483648),T=je(16777216))}function Me(n){return n instanceof ve?n.g9():function(n){return n>2147483647?2147483647:n<-2147483648?-2147483648:0|n}(n)}function Fe(n){var t;return t=function(n){return n<<16>>16}(Me(n)),function(n){return 65535&n}(t)}function De(n,t){return new Rt(n,t)}function Oe(n,t,r,i){return Re("class",n,t,r,i,null)}function Re(n,t,r,i,e,u){return{kind:n,simpleName:t,associatedObjectKey:r,associatedObjects:i,suspendArity:e,$kClass$:A,iid:u}}function He(n){return Array.isArray(n)}function $e(n,t,r,i,e,u,o,f){null!=i&&(n.prototype=Object.create(i.prototype),n.prototype.constructor=n);var s=r(t,u,o,null==f?[]:f);n.$metadata$=s,null!=e&&((null!=s.iid?n:n.prototype).$imask$=function(n){for(var t=1,r=[],i=0,e=n.length;i<e;){var u=n[i];i=i+1|0;var o=t,f=u.prototype.$imask$,s=null==f?u.$imask$:f;null!=s&&(r.push(s),o=s.length);var c=u.$metadata$.iid,a=null==c?null:(l=void 0,v=1<<(31&(h=c)),(l=new Int32Array(1+(h>>5)|0))[_=h>>5]=l[_]|v,l);null!=a&&(r.push(a),o=Math.max(o,a.length)),o>t&&(t=o)}var h,l,_,v;return function(n,t){for(var r=0,i=new Int32Array(n);r<n;){for(var e=r,u=0,o=0,f=t.length;o<f;){var s=t[o];o=o+1|0,e<s.length&&(u|=s[e])}i[e]=u,r=r+1|0}return i}(t,r)}(e))}function Ge(n,t){return function(n,t){var r=n.$imask$;return null!=r&&function(n,t){var r=t>>5;if(r>n.length)return!1;var i=1<<(31&t);return!!(n[r]&i)}(r,t)}(n,t.$metadata$.iid)}function Ue(n){return!!He(n)&&!n.$type$}function Ve(n){var t;switch(typeof n){case"string":case"number":case"boolean":case"function":t=!0;break;default:t=n instanceof Object}return t}function Qe(n){return"string"==typeof n||Ge(n,fr)}function Ze(n,t,r,i){return Re("interface",n,t,r,i,(null==N&&(N=0),N=Ye()+1|0,Ye()))}function Ye(){if(null!=N)return N;!function(){throw Eu("lateinit property iid has not been initialized")}()}function We(n,t,r,i){return Re("object",n,t,r,i,null)}function Ke(n){var t=n.constructor,r=null==t?null:t.$metadata$,i=null==r?null:r.errorInfo;if(null!=i)return i;var e,u=0;if(Xe(n,"message")&&(u|=1),Xe(n,"cause")&&(u|=2),3!==u){var o=(e=n,Object.getPrototypeOf(e));o!=Error.prototype&&(u|=Ke(o))}return null!=r&&(r.errorInfo=u),u}function Xe(n,t){return n.hasOwnProperty(t)}function Je(n){return new Mr(n)}function nu(n,t,r){for(var i=new Int32Array(r),e=0,u=0,o=0,f=0,s=n.length;f<s;){var c=Qi(n,f);f=f+1|0;var a=t[c];if(u|=(31&a)<<o,a<32){var h=e;e=h+1|0,i[h]=u,u=0,o=0}else o=o+5|0}return i}function tu(n,t){for(var r=0,i=n.length-1|0,e=-1,u=0;r<=i;)if(t>(u=n[e=(r+i|0)/2|0]))r=e+1|0;else{if(t===u)return e;i=e-1|0}return e-(t<u?1:0)|0}function ru(){M=this;var n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",t=new Int32Array(128),r=0,i=Yi(n)-1|0;if(r<=i)do{var e=r;r=r+1|0,t[Qi(n,e)]=e}while(r<=i);var u=nu("hCgBpCQGYHZH5BRpBPPPPPPRMP5BPPlCPP6BkEPPPPcPXPzBvBrB3BOiDoBHwD+E3DauCnFmBmB2D6E1BlBTiBmBlBP5BhBiBrBvBjBqBnBPRtBiCmCtBlB0BmB5BiB7BmBgEmChBZgCoEoGVpBSfRhBPqKQ2BwBYoFgB4CJuTiEvBuCuDrF5DgEgFlJ1DgFmBQtBsBRGsB+BPiBlD1EIjDPRPPPQPPPPPGQSQS/DxENVNU+B9zCwBwBPPCkDPNnBPqDYY1R8B7FkFgTgwGgwUwmBgKwBuBScmEP/BPPPPPPrBP8B7F1B/ErBqC6B7BiBmBfQsBUwCw/KwqIwLwETPcPjQgJxFgBlBsD",t,222),o=new Int32Array(u.length),f=0,s=u.length-1|0;if(f<=s)do{var c=f;f=f+1|0,o[c]=0===c?u[c]:o[c-1|0]+u[c]|0}while(f<=s);this.h9_1=o,this.i9_1=nu("aaMBXHYH5BRpBPPPPPPRMP5BPPlCPPzBDOOPPcPXPzBvBjB3BOhDmBBpB7DoDYxB+EiBP1DoExBkBQhBekBPmBgBhBctBiBMWOOXhCsBpBkBUV3Ba4BkB0DlCgBXgBtD4FSdBfPhBPpKP0BvBXjEQ2CGsT8DhBtCqDpFvD1D3E0IrD2EkBJrBDOBsB+BPiBlB1EIjDPPPPPPPPPPPGPPMNLsBNPNPKCvBvBPPCkDPBmBPhDXXgD4B6FzEgDguG9vUtkB9JcuBSckEP/BPPPPPPBPf4FrBjEhBpC3B5BKaWPrBOwCk/KsCuLqDHPbPxPsFtEaaqDL",t,222),this.j9_1=nu("GFjgggUHGGFFZZZmzpz5qB6s6020B60ptltB6smt2sB60mz22B1+vv+8BZZ5s2850BW5q1ymtB506smzBF3q1q1qB1q1q1+Bgii4wDTm74g3KiggxqM60q1q1Bq1o1q1BF1qlrqrBZ2q5wprBGFZWWZGHFsjiooLowgmOowjkwCkgoiIk7ligGogiioBkwkiYkzj2oNoi+sbkwj04DghhkQ8wgiYkgoioDsgnkwC4gikQ//v+85BkwvoIsgoyI4yguI0whiwEowri4CoghsJowgqYowgm4DkwgsY/nwnzPowhmYkg6wI8yggZswikwHgxgmIoxgqYkwgk4DkxgmIkgoioBsgssoBgzgyI8g9gL8g9kI0wgwJoxgkoC0wgioFkw/wI0w53iF4gioYowjmgBHGq1qkgwBF1q1q8qBHwghuIwghyKk0goQkwgoQk3goQHGFHkyg0pBgxj6IoinkxDswno7Ikwhz9Bo0gioB8z48Rwli0xN0mpjoX8w78pDwltoqKHFGGwwgsIHFH3q1q16BFHWFZ1q10q1B2qlwq1B1q10q1B2q1yq1B6q1gq1Biq1qhxBir1qp1Bqt1q1qB1g1q1+B//3q16B///q1qBH/qlqq9Bholqq9B1i00a1q10qD1op1HkwmigEigiy6Cptogq1Bixo1kDq7/j00B2qgoBWGFm1lz50B6s5q1+BGWhggzhwBFFhgk4//Bo2jigE8wguI8wguI8wgugUog1qoB4qjmIwwi2KgkYHHH4lBgiFWkgIWoghssMmz5smrBZ3q1y50B5sm7gzBtz1smzB5smz50BqzqtmzB5sgzqzBF2/9//5BowgoIwmnkzPkwgk4C8ys65BkgoqI0wgy6FghquZo2giY0ghiIsgh24B4ghsQ8QF/v1q1OFs0O8iCHHF1qggz/B8wg6Iznv+//B08QgohsjK0QGFk7hsQ4gB",t,222)}function iu(){return null==M&&new ru,M}function eu(){F=this,this.k9_1=new Int32Array([170,186,688,704,736,837,890,7468,7544,7579,8305,8319,8336,8560,9424,11388,42652,42864,43e3,43868]),this.l9_1=new Int32Array([1,1,9,2,5,1,1,63,1,37,1,1,13,16,26,2,2,1,2,4])}function uu(){return null==F&&new eu,F}function ou(n){var t=function(n,t){return gu(n,t),fu.call(t),t}(n,se(fe(fu)));return oe(t,ou),t}function fu(){oe(this,fu)}function su(n){var t=function(n,t){return gu(n,t),cu.call(t),t}(n,se(fe(cu)));return oe(t,su),t}function cu(){oe(this,cu)}function au(n){var t=function(n,t){return gu(n,t),hu.call(t),t}(n,se(fe(hu)));return oe(t,au),t}function hu(){oe(this,hu)}function lu(n,t){return ce(t,n),vu.call(t),t}function _u(n){var t=lu(n,se(fe(vu)));return oe(t,_u),t}function vu(){oe(this,vu)}function du(n){return function(n){ce(n),vu.call(n)}(n),wu.call(n),n}function gu(n,t){return lu(n,t),wu.call(t),t}function wu(){oe(this,wu)}function bu(){var n,t=(du(n=se(fe(mu))),mu.call(n),n);return oe(t,bu),t}function pu(n){var t=function(n,t){return gu(n,t),mu.call(t),t}(n,se(fe(mu)));return oe(t,pu),t}function mu(){oe(this,mu)}function ku(n){var t=function(n,t){return gu(n,t),qu.call(t),t}(n,se(fe(qu)));return oe(t,ku),t}function qu(){oe(this,qu)}function yu(){var n,t=(du(n=se(fe(Cu))),Cu.call(n),n);return oe(t,yu),t}function Bu(n){var t=function(n,t){return gu(n,t),Cu.call(t),t}(n,se(fe(Cu)));return oe(t,Bu),t}function Cu(){oe(this,Cu)}function xu(){var n,t=(du(n=se(fe(ju))),ju.call(n),n);return oe(t,xu),t}function ju(){oe(this,ju)}function Pu(){var n,t=(du(n=se(fe(Iu))),Iu.call(n),n);return oe(t,Pu),t}function Iu(){oe(this,Iu)}function Su(){var n,t=(du(n=se(fe(zu))),zu.call(n),n);return oe(t,Su),t}function zu(){oe(this,zu)}function Eu(n){var t=function(n,t){return gu(n,t),Tu.call(t),t}(n,se(fe(Tu)));return oe(t,Eu),t}function Tu(){oe(this,Tu)}function Lu(n,t){var r,i=n.className;return(r="(^|.*\\s+)"+t+"($|\\s+.*)",function(n,t){return yi.call(t,n,Nt()),t}(r,se(fe(yi)))).a8(i)}function Nu(n,t){this.o9_1=n,this.p9_1=t}function Au(n){this.q9_1=n}function Mu(n,t,r){var i,e=Mf(),u=Yu(),o=Af().ga(t),f=Yu();if(0===Yi(r))i=Tf();else{var s=n.ia_1,c=null==s?null:new Au(s).v9(r,"Copy reference to the clipboard");i=null==c?Tf():c}return e.ja([u,o,f,i])}function Fu(n){n=n===A?null:n,this.ia_1=n}function Du(n,t,r){Zu.call(this),this.ma_1=n,this.na_1=t,this.oa_1=r}function Ou(n,t){this.ra_1=n,this.sa_1=t}function Ru(n,t){Zu.call(this),this.va_1=n,this.wa_1=t}function Hu(n,t){Zu.call(this),this.xa_1=n,this.ya_1=t}function $u(n){Zu.call(this),this.za_1=n}function Gu(n){Zu.call(this),this.ab_1=n}function Uu(n){Zu.call(this),this.bb_1=n}function Vu(n,t){Zu.call(this),this.cb_1=n,this.db_1=t}function Qu(n){Zu.call(this),this.eb_1=n}function Zu(){}function Yu(){return to(),D}function Wu(){return to(),O}function Ku(){return to(),R}function Xu(){return to(),H}function Ju(n){return to(),Mf().fb(Xf(no),n)}function no(n){return to(),n.gb(["invisible-text","text-for-copy"]),hr()}function to(){$||($=!0,D=Ju("`"),O=Ju(" "),R=Ju("("),H=Ju(")"))}function ro(n,t){Zu.call(this),this.hb_1=n,this.ib_1=t}function io(n){Zu.call(this),this.jb_1=n}function eo(n,t){Zu.call(this),this.kb_1=n,this.lb_1=t}function uo(n){Zu.call(this),this.mb_1=n}function oo(n){Zu.call(this),this.nb_1=n}function fo(n){Zu.call(this),this.ob_1=n}function so(n,t,r){Zu.call(this),this.pb_1=n,this.qb_1=t,this.rb_1=r}function co(n){Zu.call(this),this.sb_1=n}function ao(n){Zu.call(this),this.tb_1=n}function ho(n){return n.xb_1.vb_1.k()}function lo(){if(Z)return hr();Z=!0,G=new mo("Inputs",0,"Build configuration inputs"),U=new mo("ByMessage",1,"Problems grouped by message"),V=new mo("ByLocation",2,"Problems grouped by location"),Q=new mo("IncompatibleTasks",3,"Incompatible tasks")}function _o(n){bc.call(this),this.yb_1=n}function vo(n){bc.call(this),this.ac_1=n}function go(n){bc.call(this),this.bc_1=n}function wo(n){bc.call(this),this.cc_1=n}function bo(n){ko.call(this),this.dc_1=n}function po(n,t,r,i,e,u,o,f){this.ec_1=n,this.fc_1=t,this.gc_1=r,this.hc_1=i,this.ic_1=e,this.jc_1=u,this.kc_1=o,this.lc_1=f}function mo(n,t,r){Fi.call(this,n,t),this.qc_1=r}function ko(){mc.call(this)}function qo(n,t){var r=Nf(),i=Xf(To),e=Nf().y9(Xf(Lo),[]),u=function(n,t){var r,i=Nf(),e=Xf(Do),u=Mf().ga("Learn more about the "),o=Hf();return i.y9(e,[u,o.fb(Xf((r=t,function(n){return n.bd(r.tc_1),hr()})),t.sc_1),Mf().ga(".")])}(0,t.gc_1),o=Nf().y9(Xf(No),[Bo(0,t)]),f=Nf();return r.y9(i,[e,u,o,f.y9(Xf(Ao),[Po(0,Oo(),t.lc_1,ho(t.jc_1)),Po(0,Ro(),t.lc_1,ho(t.hc_1)),Po(0,Ho(),t.lc_1,ho(t.ic_1)),Po(0,$o(),t.lc_1,ho(t.kc_1))])])}function yo(n,t){var r,i,e=Nf(),u=Xf(Mo);switch(t.lc_1.q8_1){case 0:r=So(0,t.jc_1,((i=function(n){return new go(n)}).callableName="<init>",i));break;case 3:r=So(0,t.kc_1,function(){var n=function(n){return new wo(n)};return n.callableName="<init>",n}());break;case 1:r=So(0,t.hc_1,function(){var n=function(n){return new vo(n)};return n.callableName="<init>",n}());break;case 2:r=So(0,t.ic_1,function(){var n=function(n){return new _o(n)};return n.callableName="<init>",n}());break;default:he()}return e.y9(u,[r])}function Bo(n,t){return Nf().ja([jo(0,t),Co(0,t)])}function Co(n,t){for(var r=Nf(),i=t.fc_1,e=Tr(),u=0,o=i.f();o.g();){var f=o.h(),s=u;u=s+1|0,xt(e,0===gr(s)?dr(xo(Uo(),f)):wt([$f().ja([]),xo(Uo(),f)]))}return r.ha(e)}function xo(n,t){return Ff().ja([Cc(t)])}function jo(n,t){return Lf().ja([yc().ka(t.ec_1)])}function Po(n,t,r,i){var e,u,o;return Nf().y9(Xf((e=i,u=t,o=r,function(n){return n.t9("group-selector"),0===e?(n.t9("group-selector--disabled"),hr()):u.equals(o)?(n.t9("group-selector--active"),hr()):(n.u9(function(n){return function(t){return new bo(n)}}(u)),hr()),hr()})),[Mf().rc(t.qc_1,[Io(0,i)])])}function Io(n,t){return Mf().y9(Xf(Fo),[Wu(),Ku(),Mf().ga(""+t),Xu()])}function So(n,t,r){return function(n,t,r){var i,e=Nf(),u=Df();return e.ja([u.ha(ks(t,(i=r,function(n){var t,r=n.cd().ub_1;return r instanceof Ru?zc(i,(Uo(),(t=function(n){return zo(0,n)}).callableName="viewNode",t),n,r.va_1,r.wa_1,kc()):r instanceof Hu?zc(i,function(){var n=function(n){return zo(0,n)};return n.callableName="viewNode",n}(Uo()),n,r.xa_1,r.ya_1,qc()):r instanceof ro?zc(i,function(){var n=function(n){return zo(0,n)};return n.callableName="viewNode",n}(Uo()),n,r.hb_1,r.ib_1,A,Io(Uo(),n.cd().vb_1.k())):r instanceof Du?Sc(i,n,r):zc(i,function(){var n=function(n){return zo(0,n)};return n.callableName="viewNode",n}(Uo()),n,r)})))])}(0,t.xb_1.uc().vc(),r)}function zo(n,t){var r;return t instanceof io?xc((r=t,function(n){return n.ed("project "),n.fd(r.jb_1),hr()})):t instanceof so?xc(function(n){return function(t){return t.ed(n.pb_1+" "),t.fd(n.qb_1),t.ed(" of "),t.fd(n.rb_1),hr()}}(t)):t instanceof fo?xc(function(n){return function(t){return t.ed("system property "),t.fd(n.ob_1),hr()}}(t)):t instanceof eo?xc(function(n){return function(t){return t.ed("task "),t.fd(n.kb_1),t.ed(" of type "),t.fd(n.lb_1),hr()}}(t)):t instanceof oo?xc(function(n){return function(t){return t.ed("bean of type "),t.fd(n.nb_1),hr()}}(t)):t instanceof co?xc(function(n){return function(t){return t.ed(n.sb_1),hr()}}(t)):t instanceof ao?xc(function(n){return function(t){return t.ed("class "),t.fd(n.tb_1),hr()}}(t)):t instanceof Qu?xc(function(n){return function(t){return t.ed(n.eb_1),hr()}}(t)):t instanceof $u?Cc(t.za_1):t instanceof Vu?Vo(t):Mf().ga(re(t))}function Eo(n){return n.t9("report-wrapper"),hr()}function To(n){return n.t9("header"),hr()}function Lo(n){return n.t9("gradle-logo"),hr()}function No(n){return n.t9("title"),hr()}function Ao(n){return n.t9("groups"),hr()}function Mo(n){return n.t9("content"),hr()}function Fo(n){return n.t9("group-selector__count"),hr()}function Do(n){return n.t9("learn-more"),hr()}function Oo(){return lo(),G}function Ro(){return lo(),U}function Ho(){return lo(),V}function $o(){return lo(),Q}function Go(){Y=this}function Uo(){return null==Y&&new Go,Y}function Vo(n){var t;return Hf().fb(Xf((t=n,function(n){return n.t9("documentation-button"),n.bd(t.cb_1),hr()})),n.db_1)}function Qo(n,t,r){this.kd_1=n,this.ld_1=t,this.md_1=r}function Zo(n,t,r){this.nd_1=n,this.od_1=t,this.pd_1=r}function Yo(n,t){for(var r=_f(n),i=t.trace,e=Lr(i.length),u=0,o=i.length;u<o;){var f,s=i[u];u=u+1|0,f=Xo(s),e.d(f)}return new Qo(t,r,e)}function Wo(n,t){var r,i=null==(r=t.kd_1.error)?null:Jo(r);null==i||n.d(i)}function Ko(n){return function(n,t,r){var i=null==n.error?null:new Ru(t,r);return null==i?new Hu(t,r):i}(n.kd_1,new $u(n.ld_1),rf(n.kd_1))}function Xo(n){var t;switch(n.kind){case"Project":t=new io(n.path);break;case"Task":t=new eo(n.path,n.type);break;case"TaskPath":t=new uo(n.path);break;case"Bean":t=new oo(n.type);break;case"Field":t=new so("field",n.name,n.declaringType);break;case"InputProperty":t=new so("input property",n.name,n.task);break;case"OutputProperty":t=new so("output property",n.name,n.task);break;case"SystemProperty":t=new fo(n.name);break;case"PropertyUsage":t=new so("property",n.name,n.from);break;case"BuildLogic":t=new co(n.location);break;case"BuildLogicClass":t=new ao(n.type);break;default:t=new Qu("Gradle runtime")}return t}function Jo(n){var t=n.parts;if(null==t){var r=n.summary;return null==r?null:new $u(_f(r))}for(var i=n.summary,e=null==i?null:_f(i),u=Tr(),o=Oi(t);o.g();){var f=tf(o.h());null==f||u.d(f)}for(var s=Mn(u,"\n"),c=Tr(),a=Oi(t);a.g();){var h=nf(a.h());null==h||c.d(h)}return new Du(e,s,c)}function nf(n){var t=tf(n);if(null==t)return null;var r,i,e=Jn(new Lt(function(n,t,r,i){var e;return Xn(Jt(n,["\r\n","\n","\r"],A,r=r!==A&&r,i=i===A?0:i),(e=n,function(n){return Xt(e,n)}))}(t),!0,hf));return new Ou(e,(r=!(null==n.internalText),i=e.k(),r&&i>1?bs():null))}function tf(n){var t=n.text;return null==t?n.internalText:t}function rf(n){var t=n.documentationLink;return null==t?null:new Vu(t,"")}function ef(n,t){return new ss(uf(n,xf().sd(t),bs()))}function uf(n,t,r){return new ms(n,function(n,t){var r,i=Xn(On(n.o()),Pf);return Jn(Xn(new tt(i,new of(lf)),(r=t,function(n){return uf(n.v3(),n.w3().wd_1,r)})))}(t,1===jf(t)?ps():bs()),0===jf(t)?bs():r)}function of(n){this.td_1=n}function ff(n){var t=Tr(),r=n.ld_1,i=Dn(r.ca_1).fa_1,e=re(Kt(Qe(i)?i:le())),u=r.vd(function(n,t){var r;if(!(t>=0))throw ou(re("Requested element count "+t+" is less than zero."));if(0===t)return Rn(n);if(Ge(n,Ei)){var i=n.k()-t|0;if(i<=0)return bt();if(1===i)return dr(function(n){if(Ge(n,zi))return Vn(n);var t=n.f();if(!t.g())throw pu("Collection is empty.");for(var r=t.h();t.g();)r=t.h();return r}(n));if(r=Lr(),Ge(n,zi)){if(Ge(n,hi)){var e=t,u=n.k();if(e<u)do{var o=e;e=e+1|0,r.d(n.j(o))}while(e<u)}else for(var f=n.l(t);f.g();){var s=f.h();r.d(s)}return r}}else r=Tr();for(var c=0,a=n.f();a.g();){var h=a.h();c>=t?r.d(h):c=c+1|0}return pt(r)}(r.ca_1,1));return t.d(new ro(new Qu(e),rf(n.kd_1))),t.d(new $u(u)),t.m(n.md_1),t.j5()}function sf(n){var t=Tr(),r=n.ld_1,i=r.vd(r.ca_1);return t.d(new Hu(new $u(i),rf(n.kd_1))),t.j5()}function cf(n){var t=Tr();return t.d(Ko(n)),t.m(n.md_1),Wo(t,n),t.j5()}function af(n){var t=Tr();return t.m(new It(n.md_1)),t.d(Ko(n)),Wo(t,n),t.j5()}function hf(n){return Yi(n)>0}function lf(n,t){return function(n,t){return n===t?0:null==n?-1:null==t?1:Xi(null!=n&&("string"==(i=typeof(r=n))||"boolean"===i||function(n){return"number"==typeof n||n instanceof ve}(r)||Ge(r,sr))?n:le(),t);var r,i}(Di(n.v3()),Di(t.v3()))}function _f(n){var t;return yf().qd((t=n,function(n){for(var r=t,i=0,e=r.length;i<e;){var u=r[i];i=i+1|0;var o=u.text;null==o||n.ed(o);var f=u.name;null==f||(n.fd(f),hr())}return hr()}))}function vf(n,t){return(0!==(r=n)?r.toString():"No")+" "+df(t,n)+" "+gf(n)+" found";var r}function df(n,t){return t<2?n:n+"s"}function gf(n){return n<=1?"was":"were"}function wf(n,t){this.sc_1=n,this.tc_1=t}function bf(n){mf.call(this),this.fa_1=n}function pf(n,t){mf.call(this),this.da_1=n,this.ea_1=t}function mf(){}function kf(){this.dd_1=Tr()}function qf(){W=this}function yf(){return null==W&&new qf,W}function Bf(n){yf(),this.ca_1=n}function Cf(){K=this}function xf(){return null==K&&new Cf,K}function jf(n){return n.k()}function Pf(n){var t=n.j1(),r=n.i1();return or(t,new If(Ge(r,Li)?r:le()))}function If(n){xf(),this.wd_1=n}function Sf(n,t,r){var i;Ef(t,n,r),i="Component mounted at #"+n.id+".",gi(),(gi(),g).j7(i)}function zf(n){var t=document.getElementById(n);if(null==t)throw au("'"+n+"' element missing");return t}function Ef(n,t,r){var i,e,u;i=n.z9(r),e=t,u=function(n,t,r){return function(i){return Ef(n,r,n.ba(i,t)),hr()}}(n,r,t),os(),e.innerHTML="",es(e,i,u)}function Tf(){return os(),X}function Lf(){return os(),J}function Nf(){return os(),nn}function Af(){return os(),tn}function Mf(){return os(),rn}function Ff(){return os(),en}function Df(){return os(),un}function Of(){return os(),on}function Rf(){return os(),fn}function Hf(){return os(),sn}function $f(){return os(),cn}function Gf(n){this.x9_1=n}function Uf(){an=this}function Vf(){return null==an&&new Uf,an}function Qf(){hn=this,Kf.call(this)}function Zf(){return null==hn&&new Qf,hn}function Yf(n,t,r,i){t=t===A?bt():t,r=r===A?null:r,i=i===A?bt():i,Kf.call(this),this.be_1=n,this.ce_1=t,this.de_1=r,this.ee_1=i}function Wf(){}function Kf(){Vf()}function Xf(n){os();var t,r=Tr();return n(new Jf((t=r,function(n){return t.d(n),hr()}))),r}function Jf(n){this.r9_1=n}function ns(n,t){is.call(this),this.fe_1=n,this.ge_1=t}function ts(n){is.call(this),this.he_1=n}function rs(n,t){is.call(this),this.ie_1=n,this.je_1=t}function is(){}function es(n,t,r){if(os(),t instanceof Yf)!function(n,t,r){var i=function(n,t,r){var i=n.createElement(t);return r(i),i}(ae(n.ownerDocument),t,r);n.appendChild(i)}(n,t.be_1,(e=t,u=r,function(n){for(var t=e.ce_1.f();t.g();)us(n,t.h(),u);var r=e.de_1;null==r||function(n,t){n.appendChild(ae(n.ownerDocument).createTextNode(t))}(n,r);for(var i=e.ee_1.f();i.g();)es(n,i.h(),u);return hr()}));else if(t instanceof Wf){var i=t instanceof Wf?t:le();es(n,i.ke_1,function(n,t){return function(r){return n(t.le_1(r)),hr()}}(r,i))}else if(ue(t,Zf()))return hr();var e,u}function us(n,t,r){var i,e;os(),t instanceof rs?n.setAttribute(t.ie_1,t.je_1):t instanceof ts?function(n,t){for(var r=Tr(),i=0,e=t.length;i<e;){var u=t[i];i=i+1|0,Lu(n,u)||r.d(u)}var o=r;if(!o.i()){var f=n.className,s=re(Kt(Qe(f)?f:le())),c=wi();c.p7(s),0!==Yi(s)&&c.p7(" "),Fn(o,c," "),n.className=c.toString()}}(n,[t.he_1]):t instanceof ns&&n.addEventListener(t.fe_1,(i=r,e=t,function(n){return n.stopPropagation(),i(e.ge_1(n)),hr()}))}function os(){ln||(ln=!0,X=Zf(),new Gf("hr"),J=new Gf("h1"),new Gf("h2"),nn=new Gf("div"),new Gf("pre"),tn=new Gf("code"),rn=new Gf("span"),en=new Gf("small"),un=new Gf("ol"),on=new Gf("ul"),fn=new Gf("li"),sn=new Gf("a"),cn=new Gf("br"),new Gf("p"))}function fs(n){cs.call(this),this.ne_1=n}function ss(n){this.xb_1=n}function cs(){}function as(n){return n.me(A,A,n.wb_1.ad())}function hs(){_n=this}function ls(){return null==_n&&new hs,_n}function _s(){if(gn)return hr();gn=!0,vn=new gs("Collapsed",0),dn=new gs("Expanded",1)}function vs(n){ws.call(this),this.ve_1=n}function ds(n,t,r){ws.call(this),this.se_1=n,this.te_1=t,this.ue_1=r}function gs(n,t){Fi.call(this,n,t)}function ws(){}function bs(){return _s(),vn}function ps(){return _s(),dn}function ms(n,t,r){t=t===A?bt():t,r=r===A?bs():r,this.ub_1=n,this.vb_1=t,this.wb_1=r}function ks(n,t){return Jn(Xn(n,(r=t,function(n){return function(n,t){var r,i=n.cd(),e=Rf(),u=t(n),o=i.vb_1;r=null==(i.wb_1.equals(ps())&&!o.i()?o:null)?null:function(n,t){return Of().ha(function(n,t){return ks(n.vc(),t)}(n,t))}(n,t);var f=r;return e.ja([u,null==f?Tf():f])}(n,r)})));var r}function qs(){if(kn)return hr();kn=!0,bn=new ys("ByMessage",0,"Messages"),pn=new ys("ByGroup",1,"Group"),mn=new ys("ByFileLocation",2,"Locations")}function ys(n,t,r){Fi.call(this,n,t),this.cf_1=r}function Bs(n,t,r,i){var e,u,o=n.v1(t);if(null==o){var f=Tr(),s=or(new ms(new Hs(yf().qd((u=t,function(n){return n.fd(u),hr()}))),f,ps()),f);n.h5(t,s),e=s}else e=o;e.u3_1.d(Ps(r,i))}function Cs(n,t,r,i){var e;if(t=t===A?Tr():t,r=r===A?ui():r,i===A){var u=wn;wn=u+1|0,e=u}else e=i;i=e,this.df_1=n,this.ef_1=t,this.ff_1=r,this.gf_1=i}function xs(n,t){if(t.i())return null;for(var r,i=n,e=null,u=t.f();u.g();){var o=u.h();r=e;var f,s=i,c=o.displayName+" ("+o.name+")",a=s.v1(c);if(null==a){var h=Tr(),l=new Cs(new ms(new Hs(yf().qd(Ls(o))),h,ps()),h);s.h5(c,l),f=l}else f=a;e=f,null==r||ae(r).ef_1.u(ae(e).df_1)||ae(r).ef_1.d(ae(e).df_1),i=ae(e).ff_1}return e}function js(n){for(var t=n.problemId,r=Lr(t.length),i=0,e=t.length;i<e;){var u,o=t[i];i=i+1|0,u=o.name,r.d(u)}return Mn(r,":")}function Ps(n,t,r){var i=function(n,t,r){t=t===A?null:t;var i=zs(function(n,t){return n&&null!=t.contextualLabel?ae(t.contextualLabel):Is(t)}(r=r!==A&&r,n),t).j5();return Ss(n,new $u(i))}(n,t=t===A?null:t,r=r!==A&&r),e=function(n,t,r){r=r!==A&&r;var i,e=n.problemDetails;if(null==e)i=null;else{var u,o=e[0].text,f=null==o?null:function(n,t,r,i){if(r=r!==A&&r,i=i===A?0:i,1===t.length){var e=t[0];if(0!==Yi(e))return function(n,t,r,i){tr(i);var e=0,u=Yt(n,t,e,r);if(-1===u||1===i)return dr(re(n));var o,f=i>0,s=Lr(f&&Yn(i,10));n:do{var c;if(c=re(Wi(n,e,u)),s.d(c),e=u+t.length|0,f&&s.k()===(i-1|0))break n;u=Yt(n,t,e,r)}while(-1!==u);return o=re(Wi(n,e,Yi(n))),s.d(o),s}(n,e,r,i)}for(var u=function(n){return new nt(n)}(Jt(n,t,A,r,i)),o=Lr(Ct(u,10)),f=u.f();f.g();){var s;s=Xt(n,f.h()),o.d(s)}return o}(o,["\n"]);if(null==f)u=null;else{for(var s=Lr(Ct(f,10)),c=f.f();c.g();){var a,h=c.h();a=Ts(n)?yf().qd(Ns(h)):yf().rd(h),s.d(a)}u=s}var l,_=u;if(null==_)l=null;else{for(var v=Lr(Ct(_,10)),d=_.f();d.g();){var g;g=new ms(new $u(d.h())),v.d(g)}l=v}var w=null==l?null:$n(l);i=null==w?Tr():w}var b=i,p=null==b?Tr():b;r||null==n.contextualLabel||p.d(new ms(new $u(yf().rd(ae(n.contextualLabel)))));var m=function(n){var t=n.solutions;if(null==t||0===t.length)return null;for(var r=new Uu(yf().rd("Solutions")),i=ae(n.solutions),e=Lr(i.length),u=0,o=i.length;u<o;){var f,s=i[u];u=u+1|0,f=new ms(new Gu(_f(s))),e.d(f)}return new ms(r,e)}(n);null==m||p.d(m);var k=n.error,q=null==k?null:Jo(k);null==q||p.d(new ms(q));var y,B=function(n){for(var t=null,r=function(n,t){if(!(t>=0))throw ou(re("Requested element count "+t+" is less than zero."));return function(n,t){if(!(t>=0))throw ou(re("Requested element count "+t+" is less than zero."));if(0===t)return bt();var r=n.length;if(t>=r)return An(n);if(1===t)return dr(n[r-1|0]);var i=Lr(),e=r-t|0;if(e<r)do{var u=e;e=e+1|0,i.d(n[u])}while(e<r);return i}(n,Wn(n.length-t|0,0))}(n.problemId.slice(),1).f();r.g();){var i=r.h(),e=t,u=new Hs(yf().qd(Ms(i))),o=null==e?null:dr(e);t=new ms(u,null==o?bt():o)}return t}(n);if(null==B||p.d(B),t){var C=n.locations;y=!(null==C||0===C.length)}else y=!1;return y&&p.d(function(n){var t,r=n.locations;if(null==r)t=null;else{for(var i=Lr(r.length),e=Oi(r);e.g();){var u,o=e.h();u=new ms(new $u(yf().qd(As(o)))),i.d(u)}t=i}var f=t;return new ms(new Qu("Locations"),null==f?bt():f)}(n)),p}(n,null==t,r);return new ms(i,e)}function Is(n){return function(n){if(0===n.length)throw pu("Array is empty.");return n[Ln(n)]}(n.problemId).displayName}function Ss(n,t){var r;switch(n.severity){case"WARNING":var i=n.documentationLink;r=new Hu(t,null==i?null:new Vu(i,""));break;case"ERROR":var e=n.documentationLink;r=new Ru(t,null==e?null:new Vu(e,""));break;case"ADVICE":var u=n.documentationLink;r=new $s(t,null==u?null:new Vu(u,""));break;default:console.error("no severity "+n.severity),r=t}return r}function zs(n,t){t=t===A?null:t;var r,i=new kf;if(i.ed(n),null==t);else{if(null!=t.line){var e=Es(t);i.xd(e+(null==(r=t).line||null==r.length?"":"-"+r.length),""+t.path+e)}var u=t.taskPath;null==u||i.fd(u);var o=t.pluginId;null!=o&&i.fd(o)}return i}function Es(n){var t;if(null==n.line)t=null;else{var r,i=":"+n.line,e=n.column;t=i+(null==(r=null==e?null:":"+e)?"":r)}return null==t?"":t}function Ts(n){var t,r,i=n.problemId;n:{for(var e=0,u=i.length;e<u;){var o=i[e];if(e=e+1|0,"compilation"===o.name){r=o;break n}}r=null}if(null!=r){var f,s=n.problemId;n:{for(var c=0,a=s.length;c<a;){var h=s[c];if(c=c+1|0,"java"===h.name){f=h;break n}}f=null}t=!(null==f)}else t=!1;return t}function Ls(n){return function(t){return t.ed(n.displayName),t.fd(n.name),hr()}}function Ns(n){return function(t){return t.xd(function(n,t,r,i){i=i!==A&&i;var e=new RegExp(qi().t7(" "),i?"gui":"gu"),u=qi().u7(" ");return n.replace(e,u)}(n),""),hr()}}function As(n){return function(t){return t.ed("- "),t.fd(""+n.path+Es(n)),hr()}}function Ms(n){return function(t){return t.ed(n.displayName),t.fd(n.name),hr()}}function Fs(){return qs(),bn}function Ds(){return qs(),pn}function Os(){return qs(),mn}function Rs(n){Gs.call(this),this.hf_1=n}function Hs(n,t){t=t!==A&&t,Gs.call(this),this.if_1=n,this.jf_1=t}function $s(n,t){Zu.call(this),this.kf_1=n,this.lf_1=t}function Gs(){Zu.call(this)}function Us(n){bc.call(this),this.mf_1=n}function Vs(n){bc.call(this),this.nf_1=n}function Qs(n){bc.call(this),this.of_1=n}function Zs(n){Ws.call(this),this.pf_1=n}function Ys(n,t,r,i,e,u,o,f){this.qf_1=n,this.rf_1=t,this.sf_1=r,this.tf_1=i,this.uf_1=e,this.vf_1=u,this.wf_1=o,this.xf_1=f}function Ws(){mc.call(this)}function Ks(n,t){var r=Tr();ho(t.tf_1)>0&&r.d(ic(0,Fs(),t.xf_1,t.wf_1)),ho(t.uf_1)>0&&r.d(ic(0,Ds(),t.xf_1,t.wf_1)),ho(t.vf_1)>0&&r.d(ic(0,Os(),t.xf_1,t.wf_1));var i=Nf(),e=Xf(fc),u=Nf().y9(Xf(sc),[]),o=function(n,t){var r,i=Nf(),e=Xf(_c),u=Mf().ga("Learn more about "),o=Hf();return i.y9(e,[u,o.fb(Xf((r=t,function(n){return n.bd(r.tc_1),hr()})),t.sc_1),Mf().ga(".")])}(0,t.sf_1),f=Nf().y9(Xf(cc),[Js(0,t)]),s=Nf();return i.y9(e,[u,o,f,s.zd(Xf(ac),r)])}function Xs(n,t){var r,i,e=Nf(),u=Xf(hc);switch(t.xf_1.q8_1){case 0:r=ec(0,t.tf_1,((i=function(n){return new Us(n)}).callableName="<init>",i));break;case 1:r=ec(0,t.uf_1,function(){var n=function(n){return new Vs(n)};return n.callableName="<init>",n}());break;case 2:r=ec(0,t.vf_1,function(){var n=function(n){return new Qs(n)};return n.callableName="<init>",n}());break;default:he()}return e.y9(u,[r])}function Js(n,t){return Nf().ja([rc(0,t),nc(0,t)])}function nc(n,t){for(var r=Nf(),i=t.rf_1,e=Tr(),u=0,o=i.f();o.g();){var f=o.h(),s=u;u=s+1|0,xt(e,0===gr(s)?dr(tc(dc(),f)):wt([$f().ja([]),tc(dc(),f)]))}return r.ha(e)}function tc(n,t){return Ff().ja([Cc(t)])}function rc(n,t){return Lf().ja([yc().ka(t.qf_1)])}function ic(n,t,r,i){var e,u,o,f;return Nf().y9(Xf((e=i,u=t,o=r,function(n){return n.t9("group-selector"),0===e?(n.t9("group-selector--disabled"),hr()):u.equals(o)?(n.t9("group-selector--active"),hr()):(n.u9(function(n){return function(t){return new Zs(n)}}(u)),hr()),hr()})),[Mf().rc(t.cf_1,[(f=i,Mf().y9(Xf(lc),[Wu(),Ku(),Mf().ga(""+f),Xu()]))])])}function ec(n,t,r){return function(n,t,r){var i,e=Nf(),u=Df();return e.ja([u.ha(ks(t,(i=r,function(n){return function(n,t,r,i){var e,u;return t instanceof Rs?Cc(yf().rd(t.hf_1)):t instanceof Hs?Nf().y9(Xf((u=t,function(n){return u.jf_1&&(n.t9("uncategorized"),hr()),hr()})),[Nf().ja([jc(r,i),Cc(t.if_1)])]):t instanceof Du?Sc(i,r,t):t instanceof $u?Cc(t.za_1):t instanceof Gu?Nf().ja([(Hc(),xn),Cc(t.ab_1)]):t instanceof Uu?Nf().ja([jc(r,i),Cc(t.bb_1)]):t instanceof Ru?zc(i,((e=function(n){return uc(0,n)}).callableName="viewIt",e),r,t.va_1,t.wa_1,kc()):t instanceof $s?zc(i,function(){var n=function(n){return uc(0,n)};return n.callableName="viewIt",n}(),r,t.kf_1,t.lf_1,(Hc(),Bn)):t instanceof Hu?zc(i,function(){var n=function(n){return uc(0,n)};return n.callableName="viewIt",n}(),r,t.xa_1,t.ya_1,qc()):t instanceof Qu?Nf().ja([jc(r,i),Cc(yf().rd(t.eb_1))]):Mf().ga("Unknown node type viewNode: "+t)}(dc(),n.cd().ub_1,n,i)})))])}(0,t.xb_1.uc().vc(),r)}function uc(n,t){var r;if(t instanceof Vu)r=Vo(t);else if(t instanceof Qu)r=Cc(yf().rd(t.eb_1));else if(t instanceof $u)r=Cc(t.za_1);else{var i="Unknown node type viewIt: "+t;console.error(i),r=Mf().ga(i)}return r}function oc(n){return n.t9("report-wrapper"),hr()}function fc(n){return n.t9("header"),hr()}function sc(n){return n.t9("gradle-logo"),hr()}function cc(n){return n.t9("title"),hr()}function ac(n){return n.t9("groups"),hr()}function hc(n){return n.t9("content"),hr()}function lc(n){return n.t9("group-selector__count"),hr()}function _c(n){return n.t9("learn-more"),hr()}function vc(){qn=this,document.title="Gradle Problem Report"}function dc(){return null==qn&&new vc,qn}function gc(n,t,r){return n.pe(t.zb().oe(),r)}function wc(n){mc.call(this),this.hd_1=n}function bc(){mc.call(this)}function pc(n,t){mc.call(this),this.wc_1=n,this.xc_1=t}function mc(){}function kc(){return Hc(),yn}function qc(){return Hc(),Cn}function yc(){return Hc(),jn}function Bc(){return Hc(),Pn}function Cc(n){return Hc(),Bc().ka(n)}function xc(n){return Hc(),Bc().ka(yf().qd(n))}function jc(n,t){return Hc(),n.cd().ye()?Ec(n,t):function(n){return Hc(),Mf().fb(Xf(Oc),Tc(n))}(n)}function Pc(n,t,r,i){var e,u,o;return Hc(),Mf().fb(Xf((e=r,u=t,o=i,function(n){return n.t9("java-exception-part-toggle"),n.u9(function(n,t){return function(r){return new pc(n,t())}}(u,o)),n.s9("Click to "+function(n){var t;switch(Hc(),n.q8_1){case 0:t="show";break;case 1:t="hide";break;default:he()}return t}(e)),hr()})),"("+n+" internal "+df("line",n)+" "+function(n){var t;switch(Hc(),n.q8_1){case 0:t="hidden";break;case 1:t="shown";break;default:he()}return t}(r)+")")}function Ic(n,t){t=t===A?Tf():t,Hc();for(var r=Of(),i=Lr(Ct(n,10)),e=0,u=n.f();u.g();){var o,f=e;e=f+1|0,s=u.h(),c=(c=0===gr(f)?t:Tf())===A?Tf():c,Hc(),o=Rf().ja([Af().ga(s),c]),i.d(o)}var s,c;return r.ha(i)}function Sc(n,t,r){Hc();var i,e,u,o=Nf(),f=Ec(t,n),s=Mf().ga("Exception"),c=Mf().ja([(Hc(),In).v9(r.na_1,"Copy exception to the clipboard")]),a=null==r.ma_1?null:Mf().ga(" "),h=null==a?Tf():a,l=r.ma_1,_=null==l?null:Cc(l),v=null==_?Tf():_;switch(t.cd().wb_1.q8_1){case 0:i=Tf();break;case 1:i=function(n,t){Hc();for(var r=Nf(),i=Xf(Rc),e=n.oa_1,u=Lr(Ct(e,10)),o=0,f=e.f();f.g();){var s,c=f.h(),a=o;o=a+1|0;var h,l=gr(a);if(null!=c.sa_1){var _,v=Pc(c.ra_1.k(),l,c.sa_1,t),d=c.sa_1;switch(null==d?-1:d.q8_1){case 0:_=Ic(Gn(c.ra_1,1),v);break;case 1:_=Ic(c.ra_1,v);break;default:he()}h=_}else h=Ic(c.ra_1);s=h,u.d(s)}return r.zd(i,u)}(r,(e=n,u=t,function(){return e(new fs(u))}));break;default:he()}return o.ja([f,s,c,h,v,i])}function zc(n,t,r,i,e,u,o){e=e===A?null:e,u=u===A?Tf():u,o=o===A?Tf():o,Hc();var f=Nf(),s=jc(r,n),c=t(i),a=null==e?null:t(e);return f.ja([s,u,c,null==a?Tf():a,o])}function Ec(n,t){var r,i;return Hc(),Mf().fb(Xf((r=n,i=t,function(n){return n.gb(["invisible-text","tree-btn"]),r.cd().wb_1===bs()&&(n.t9("collapsed"),hr()),r.cd().wb_1===ps()&&(n.t9("expanded"),hr()),n.s9("Click to "+function(n){var t;switch(Hc(),n.q8_1){case 0:t="expand";break;case 1:t="collapse";break;default:he()}return t}(r.cd().wb_1)),n.u9(function(n,t){return function(r){return n(new fs(t))}}(i,r)),hr()})),Tc(n))}function Tc(n){return Hc(),function(n,t){var r;if(!(t>=0))throw ou(re("Count 'n' must be non-negative, but was "+t+"."));switch(t){case 0:r="";break;case 1:r=re(n);break;default:var i="";if(0!==Yi(n))for(var e=re(n),u=t;1&~u||(i+=e),0!=(u=u>>>1|0);)e+=e;return i}return r}("    ",n.we()-1|0)+"- "}function Lc(n){return Hc(),n.gb(["invisible-text","error-icon"]),hr()}function Nc(n){return Hc(),n.gb(["invisible-text","advice-icon"]),hr()}function Ac(n){return Hc(),n.gb(["invisible-text","warning-icon"]),hr()}function Mc(n){return Hc(),n.gb(["invisible-text","enum-icon"]),hr()}function Fc(n){return Hc(),new wc(n)}function Dc(n){return Hc(),new wc(n)}function Oc(n){return Hc(),n.gb(["invisible-text","leaf-icon"]),hr()}function Rc(n){return Hc(),n.t9("java-exception"),hr()}function Hc(){if(!Sn){Sn=!0;var n=Mf();yn=n.fb(Xf(Lc),"[error] ");var t=Mf();Bn=t.fb(Xf(Nc),"[advice] ");var r=Mf();Cn=r.fb(Xf(Ac),"[warn]  ");var i=Mf();xn=i.fb(Xf(Mc),"[enum]  "),jn=new Fu,Pn=new Fu(Fc),In=new Au(Dc)}}return $e(Zn,A,Oe),$e(nt,A,Oe),$e(tt,A,Oe),$e(Ei,"Collection",Ze),$e(rt,"AbstractCollection",Oe,A,[Ei]),$e(it,"IteratorImpl",Oe),$e(et,"ListIteratorImpl",Oe,it),$e(ut,"Companion",We),$e(zi,"List",Ze,A,[Ei]),$e(ft,"AbstractList",Oe,rt,[rt,zi]),$e(st,A,Oe),$e(ht,"Companion",We),$e(_t,A,Oe,rt),$e(Li,"Map",Ze),$e(vt,"AbstractMap",Oe,A,[Li]),$e(dt,"Companion",We),$e(hi,"RandomAccess",Ze),$e(kt,"EmptyList",We,A,[zi,hi]),$e(qt,"ArrayAsCollection",Oe,A,[Ei]),$e(yt,"EmptyIterator",We),$e(jt,"IntIterator",Oe),$e(Pt,A,Oe),$e(It,"ReversedListReadOnly",Oe,ft),$e(St,A,Oe),$e(zt,"TransformingSequence",Oe),$e(Tt,A,Oe),$e(Lt,"FilteringSequence",Oe),$e(Ai,"Set",Ze,A,[Ei]),$e(At,"EmptySet",We,A,[Ai]),$e(Dt,"Companion",We),$e(Ut,"IntProgression",Oe),$e(Rt,"IntRange",Oe,Ut),$e(Ht,"IntProgressionIterator",Oe,jt),$e($t,"Companion",We),$e(ir,A,Oe),$e(er,"DelimitedRangesSequence",Oe),$e(ur,"Pair",Oe),$e(fr,"CharSequence",Ze),$e(sr,"Comparable",Ze),$e(cr,"Number",Oe),$e(ar,"Unit",We),$e(lr,"IntCompanionObject",We),$e(pr,"AbstractMutableCollection",Oe,rt,[rt,Ei]),$e(mr,"IteratorImpl",Oe),$e(kr,"ListIteratorImpl",Oe,mr),$e(qr,"AbstractMutableList",Oe,pr,[pr,Ei,zi]),$e(yr,A,Oe),$e(Br,A,Oe),$e(Ti,"Entry",Ze),$e(Ni,"MutableEntry",Ze,A,[Ti]),$e(Cr,"SimpleEntry",Oe,A,[Ni]),$e(Sr,"AbstractMutableSet",Oe,pr,[pr,Ei,Ai]),$e(xr,"AbstractEntrySet",Oe,Sr),$e(jr,A,Oe,Sr),$e(Pr,A,Oe,pr),$e(Ir,"AbstractMutableMap",Oe,vt,[vt,Li]),$e(zr,"Companion",We),$e(Mr,"ArrayList",Oe,qr,[qr,Ei,zi,hi]),$e(Or,"HashCode",We),$e(Rr,"EntrySet",Oe,xr),$e(Ur,"HashMap",Oe,Ir,[Ir,Li]),$e(Qr,"HashSet",Oe,Sr,[Sr,Ei,Ai]),$e(Kr,A,Oe),$e(Jr,"InternalMap",Ze),$e(Xr,"InternalHashCodeMap",Oe,A,[Jr]),$e(ni,"EntryIterator",Oe),$e(ti,"Companion",We),$e(ii,"ChainEntry",Oe,Cr),$e(ei,"EntrySet",Oe,xr),$e(fi,"LinkedHashMap",Oe,Ur,[Ur,Li]),$e(si,"Companion",We),$e(ai,"LinkedHashSet",Oe,Qr,[Qr,Ei,Ai]),$e(li,"BaseOutput",Oe),$e(_i,"NodeJsOutput",Oe,li),$e(di,"BufferedOutput",Oe,li),$e(vi,"BufferedOutputToConsoleLog",Oe,di),$e(bi,"StringBuilder",Oe,A,[fr]),$e(ki,"Companion",We),$e(yi,"Regex",Oe),$e(Pi,"Companion",We),$e(Si,"Char",Oe,A,[sr]),$e(Mi,"Companion",We),$e(Fi,"Enum",Oe,A,[sr]),$e(Ri,A,Oe),$e(_e,"Companion",We),$e(ve,"Long",Oe,cr,[cr,sr]),$e(ru,"Letter",We),$e(eu,"OtherLowercase",We),$e(vu,"Exception",Oe,Error),$e(wu,"RuntimeException",Oe,vu),$e(fu,"IllegalArgumentException",Oe,wu),$e(cu,"IndexOutOfBoundsException",Oe,wu),$e(hu,"IllegalStateException",Oe,wu),$e(mu,"NoSuchElementException",Oe,wu),$e(qu,"ArithmeticException",Oe,wu),$e(Cu,"UnsupportedOperationException",Oe,wu),$e(ju,"NullPointerException",Oe,wu),$e(Iu,"NoWhenBranchMatchedException",Oe,wu),$e(zu,"ClassCastException",Oe,wu),$e(Tu,"UninitializedPropertyAccessException",Oe,wu),$e(Nu,"Model",Oe),$e(Au,"CopyButtonComponent",Oe),$e(Fu,"PrettyTextComponent",Oe),$e(Zu,"ProblemNode",Oe),$e(Du,"Exception",Oe,Zu),$e(Ou,"StackTracePart",Oe),$e(Ru,"Error",Oe,Zu),$e(Hu,"Warning",Oe,Zu),$e($u,"Message",Oe,Zu),$e(Gu,"ListElement",Oe,Zu),$e(Uu,"TreeNode",Oe,Zu),$e(Vu,"Link",Oe,Zu),$e(Qu,"Label",Oe,Zu),$e(ro,"Info",Oe,Zu),$e(io,"Project",Oe,Zu),$e(eo,"Task",Oe,Zu),$e(uo,"TaskPath",Oe,Zu),$e(oo,"Bean",Oe,Zu),$e(fo,"SystemProperty",Oe,Zu),$e(so,"Property",Oe,Zu),$e(co,"BuildLogic",Oe,Zu),$e(ao,"BuildLogicClass",Oe,Zu),$e(mc,"BaseIntent",Oe),$e(bc,"TreeIntent",Oe,mc),$e(_o,"TaskTreeIntent",Oe,bc),$e(vo,"MessageTreeIntent",Oe,bc),$e(go,"InputTreeIntent",Oe,bc),$e(wo,"IncompatibleTaskTreeIntent",Oe,bc),$e(ko,"Intent",Oe,mc),$e(bo,"SetTab",Oe,ko),$e(po,"Model",Oe),$e(mo,"Tab",Oe,Fi),$e(Go,"ConfigurationCacheReportPage",We),$e(Qo,"ImportedProblem",Oe),$e(Zo,"ImportedDiagnostics",Oe),$e(of,"sam$kotlin_Comparator$0",Oe),$e(wf,"LearnMore",Oe),$e(mf,"Fragment",Oe),$e(bf,"Text",Oe,mf),$e(pf,"Reference",Oe,mf),$e(kf,"Builder",Oe),$e(qf,"Companion",We),$e(Bf,"PrettyText",Oe),$e(Cf,"Companion",We),$e(If,"Trie",Oe),$e(Gf,"ViewFactory",Oe),$e(Uf,"Companion",We),$e(Kf,"View",Oe),$e(Qf,"Empty",We,Kf),$e(Yf,"Element",Oe,Kf),$e(Wf,"MappedView",Oe,Kf),$e(Jf,"Attributes",Oe),$e(is,"Attribute",Oe),$e(ns,"OnEvent",Oe,is),$e(ts,"ClassName",Oe,is),$e(rs,"Named",Oe,is),$e(cs,"Intent",Oe),$e(fs,"Toggle",Oe,cs),$e(ss,"Model",Oe),$e(hs,"TreeView",We),$e(ws,"Focus",Oe),$e(vs,"Original",Oe,ws),$e(ds,"Child",Oe,ws),$e(gs,"ViewState",Oe,Fi),$e(ms,"Tree",Oe),$e(ys,"Tab",Oe,Fi),$e(Cs,"ProblemNodeGroup",Oe),$e(Gs,"ProblemApiNode",Oe,Zu),$e(Rs,"Text",Oe,Gs),$e(Hs,"ProblemId",Oe,Gs),$e($s,"Advice",Oe,Zu),$e(Us,"MessageTreeIntent",Oe,bc),$e(Vs,"ProblemIdTreeIntent",Oe,bc),$e(Qs,"FileLocationTreeIntent",Oe,bc),$e(Ws,"Intent",Oe,mc),$e(Zs,"SetTab",Oe,Ws),$e(Ys,"Model",Oe),$e(vc,"ProblemsReportPage",We),$e(wc,"Copy",Oe,mc),$e(pc,"ToggleStackTracePart",Oe,mc),fe(Zn).f=function(){return this.n_1.f()},fe(nt).f=function(){return this.r_1.f()},fe(tt).f=function(){var n,t,r=function(n,t){for(var r=n.f();r.g();){var i=r.h();t.d(i)}return t}(this.s_1,Tr());return n=r,t=this.t_1,function(n,t){if(n.k()<=1)return hr();var r=wr(n);!function(n,t){if(function(){if(null!=l)return l;l=!1;var n=[],t=0;if(t<600)do{var r=t;t=t+1|0,n.push(r)}while(t<600);var i=Dr;n.sort(i);var e=1,u=n.length;if(e<u)do{var o=e;e=e+1|0;var f=n[o-1|0],s=n[o];if((3&f)==(3&s)&&f>=s)return!1}while(e<u);return l=!0,!0}()){var r=(i=t,function(n,t){return i.compare(n,t)});n.sort(r)}else!function(n,t,r,i){var e=n.length,u=function(n){var t=0,r=n.length-1|0;if(t<=r)do{var i=t;t=t+1|0,n[i]=null}while(i!==r);return n}(Array(e)),o=Fr(n,u,0,r,i);if(o!==n){var f=0;if(f<=r)do{var s=f;f=f+1|0,n[s]=o[s]}while(s!==r)}}(n,0,Ln(n),t);var i}(r,t);var i=0,e=r.length;if(i<e)do{var u=i;i=i+1|0,n.f4(u,r[u])}while(i<e)}(n,t),r.f()},fe(rt).u=function(n){var t;n:if(Ge(this,Ei)&&this.i())t=!1;else{for(var r=this.f();r.g();)if(ue(r.h(),n)){t=!0;break n}t=!1}return t},fe(rt).v=function(n){var t;n:if(Ge(n,Ei)&&n.i())t=!0;else{for(var r=n.f();r.g();){var i=r.h();if(!this.u(i)){t=!1;break n}}t=!0}return t},fe(rt).i=function(){return 0===this.k()},fe(rt).toString=function(){return Mn(this,", ","[","]",A,A,(n=this,function(t){return t===n?"(this Collection)":Di(t)}));var n},fe(rt).toArray=function(){return vr(this)},fe(it).g=function(){return this.w_1<this.x_1.k()},fe(it).h=function(){if(!this.g())throw bu();var n=this.w_1;return this.w_1=n+1|0,this.x_1.j(n)},fe(et).c1=function(){return this.w_1>0},fe(et).d1=function(){if(!this.c1())throw bu();return this.w_1=this.w_1-1|0,this.a1_1.j(this.w_1)},fe(ut).e1=function(n,t){if(n<0||n>=t)throw su("index: "+n+", size: "+t)},fe(ut).b1=function(n,t){if(n<0||n>t)throw su("index: "+n+", size: "+t)},fe(ut).f1=function(n){for(var t=1,r=n.f();r.g();){var i=r.h(),e=zn(31,t),u=null==i?null:ie(i);t=e+(null==u?0:u)|0}return t},fe(ut).g1=function(n,t){if(n.k()!==t.k())return!1;for(var r=t.f(),i=n.f();i.g();)if(!ue(i.h(),r.h()))return!1;return!0},fe(ft).f=function(){return new it(this)},fe(ft).l=function(n){return new et(this,n)},fe(ft).equals=function(n){return n===this||!(null==n||!Ge(n,zi))&&ot().g1(this,n)},fe(ft).hashCode=function(){return ot().f1(this)},fe(st).g=function(){return this.h1_1.g()},fe(st).h=function(){return this.h1_1.h().i1()},fe(ht).k1=function(n){var t=n.j1(),r=null==t?null:ie(t),i=null==r?0:r,e=n.i1(),u=null==e?null:ie(e);return i^(null==u?0:u)},fe(ht).l1=function(n){return Di(n.j1())+"="+Di(n.i1())},fe(ht).m1=function(n,t){return!(null==t||!Ge(t,Ti))&&!!ue(n.j1(),t.j1())&&ue(n.i1(),t.i1())},fe(_t).r1=function(n){return this.q1_1.s1(n)},fe(_t).u=function(n){return!(null!=n&&!Ve(n))&&this.r1(null==n||Ve(n)?n:le())},fe(_t).f=function(){return new st(this.q1_1.o().f())},fe(_t).k=function(){return this.q1_1.k()},fe(vt).t1=function(n){return!(null==at(this,n))},fe(vt).s1=function(n){var t;n:{var r=this.o();if(Ge(r,Ei)&&r.i())t=!1;else{for(var i=r.f();i.g();)if(ue(i.h().i1(),n)){t=!0;break n}t=!1}}return t},fe(vt).u1=function(n){if(null==n||!Ge(n,Ti))return!1;var t=n.j1(),r=n.i1(),i=(Ge(this,Li)?this:le()).v1(t);return!(!ue(r,i)||null==i&&!(Ge(this,Li)?this:le()).t1(t))},fe(vt).equals=function(n){if(n===this)return!0;if(null==n||!Ge(n,Li))return!1;if(this.k()!==n.k())return!1;var t;n:{var r=n.o();if(Ge(r,Ei)&&r.i())t=!0;else{for(var i=r.f();i.g();){var e=i.h();if(!this.u1(e)){t=!1;break n}}t=!0}}return t},fe(vt).v1=function(n){var t=at(this,n);return null==t?null:t.i1()},fe(vt).hashCode=function(){return ie(this.o())},fe(vt).i=function(){return 0===this.k()},fe(vt).k=function(){return this.o().k()},fe(vt).toString=function(){var n;return Mn(this.o(),", ","{","}",A,A,(n=this,function(t){return n.p1(t)}))},fe(vt).p1=function(n){return ct(this,n.j1())+"="+ct(this,n.i1())},fe(vt).w1=function(){return null==this.o1_1&&(this.o1_1=new _t(this)),ae(this.o1_1)},fe(dt).x1=function(n){for(var t=0,r=n.f();r.g();){var i=r.h(),e=t,u=null==i?null:ie(i);t=e+(null==u?0:u)|0}return t},fe(dt).y1=function(n,t){return n.k()===t.k()&&n.v(t)},fe(kt).equals=function(n){return!(null==n||!Ge(n,zi))&&n.i()},fe(kt).hashCode=function(){return 1},fe(kt).toString=function(){return"[]"},fe(kt).k=function(){return 0},fe(kt).i=function(){return!0},fe(kt).a2=function(n){return n.i()},fe(kt).v=function(n){return this.a2(n)},fe(kt).j=function(n){throw su("Empty list doesn't contain element at index "+n+".")},fe(kt).f=function(){return Bt()},fe(kt).l=function(n){if(0!==n)throw su("Index: "+n);return Bt()},fe(qt).k=function(){return this.b2_1.length},fe(qt).i=function(){return 0===this.b2_1.length},fe(qt).d2=function(n){return function(n,t){return Nn(n,t)>=0}(this.b2_1,n)},fe(qt).e2=function(n){var t;n:if(Ge(n,Ei)&&n.i())t=!0;else{for(var r=n.f();r.g();){var i=r.h();if(!this.d2(i)){t=!1;break n}}t=!0}return t},fe(qt).v=function(n){return this.e2(n)},fe(qt).f=function(){return Oi(this.b2_1)},fe(yt).g=function(){return!1},fe(yt).c1=function(){return!1},fe(yt).h=function(){throw bu()},fe(yt).d1=function(){throw bu()},fe(jt).h=function(){return this.f2()},fe(Pt).g=function(){return this.g2_1.c1()},fe(Pt).c1=function(){return this.g2_1.g()},fe(Pt).h=function(){return this.g2_1.d1()},fe(Pt).d1=function(){return this.g2_1.h()},fe(It).k=function(){return this.i2_1.k()},fe(It).j=function(n){return this.i2_1.j(function(n,t){if(!(0<=t&&t<=mt(n)))throw su("Element index "+t+" must be in range ["+De(0,mt(n))+"].");return mt(n)-t|0}(this,n))},fe(It).f=function(){return this.l(0)},fe(It).l=function(n){return new Pt(this,n)},fe(St).h=function(){return this.k2_1.m2_1(this.j2_1.h())},fe(St).g=function(){return this.j2_1.g()},fe(zt).f=function(){return new St(this)},fe(Tt).h=function(){if(-1===this.o2_1&&Et(this),0===this.o2_1)throw bu();var n=this.p2_1;return this.p2_1=null,this.o2_1=-1,null==n||Ve(n)?n:le()},fe(Tt).g=function(){return-1===this.o2_1&&Et(this),1===this.o2_1},fe(Lt).f=function(){return new Tt(this)},fe(At).equals=function(n){return!(null==n||!Ge(n,Ai))&&n.i()},fe(At).hashCode=function(){return 0},fe(At).toString=function(){return"[]"},fe(At).k=function(){return 0},fe(At).i=function(){return!0},fe(At).a2=function(n){return n.i()},fe(At).v=function(n){return this.a2(n)},fe(At).f=function(){return Bt()},fe(Rt).y2=function(){return this.z2_1},fe(Rt).c3=function(){return this.a3_1},fe(Rt).i=function(){return this.z2_1>this.a3_1},fe(Rt).equals=function(n){return n instanceof Rt&&(!(!this.i()||!n.i())||this.z2_1===n.z2_1&&this.a3_1===n.a3_1)},fe(Rt).hashCode=function(){return this.i()?-1:zn(31,this.z2_1)+this.a3_1|0},fe(Rt).toString=function(){return this.z2_1+".."+this.a3_1},fe(Ht).g=function(){return this.f3_1},fe(Ht).f2=function(){var n=this.g3_1;if(n===this.e3_1){if(!this.f3_1)throw bu();this.f3_1=!1}else this.g3_1=this.g3_1+this.d3_1|0;return n},fe($t).q=function(n,t,r){return new Ut(n,t,r)},fe(Ut).f=function(){return new Ht(this.z2_1,this.a3_1,this.b3_1)},fe(Ut).i=function(){return this.b3_1>0?this.z2_1>this.a3_1:this.z2_1<this.a3_1},fe(Ut).equals=function(n){return n instanceof Ut&&(!(!this.i()||!n.i())||this.z2_1===n.z2_1&&this.a3_1===n.a3_1&&this.b3_1===n.b3_1)},fe(Ut).hashCode=function(){return this.i()?-1:zn(31,zn(31,this.z2_1)+this.a3_1|0)+this.b3_1|0},fe(Ut).toString=function(){return this.b3_1>0?this.z2_1+".."+this.a3_1+" step "+this.b3_1:this.z2_1+" downTo "+this.a3_1+" step "+(0|-this.b3_1)},fe(ir).h=function(){if(-1===this.j3_1&&rr(this),0===this.j3_1)throw bu();var n=this.m3_1,t=n instanceof Rt?n:le();return this.m3_1=null,this.j3_1=-1,t},fe(ir).g=function(){return-1===this.j3_1&&rr(this),1===this.j3_1},fe(er).f=function(){return new ir(this)},fe(ur).toString=function(){return"("+this.t3_1+", "+this.u3_1+")"},fe(ur).v3=function(){return this.t3_1},fe(ur).w3=function(){return this.u3_1},fe(ur).hashCode=function(){var n=null==this.t3_1?0:ie(this.t3_1);return zn(n,31)+(null==this.u3_1?0:ie(this.u3_1))|0},fe(ur).equals=function(n){if(this===n)return!0;if(!(n instanceof ur))return!1;var t=n instanceof ur?n:le();return!!ue(this.t3_1,t.t3_1)&&!!ue(this.u3_1,t.u3_1)},fe(ar).toString=function(){return"kotlin.Unit"},fe(lr).b4=function(){return this.MIN_VALUE},fe(lr).c4=function(){return this.MAX_VALUE},fe(lr).d4=function(){return this.SIZE_BYTES},fe(lr).e4=function(){return this.SIZE_BITS},fe(pr).m=function(n){this.g4();for(var t=!1,r=n.f();r.g();){var i=r.h();this.d(i)&&(t=!0)}return t},fe(pr).toJSON=function(){return this.toArray()},fe(pr).g4=function(){},fe(mr).g=function(){return this.h4_1<this.j4_1.k()},fe(mr).h=function(){if(!this.g())throw bu();var n=this.h4_1;return this.h4_1=n+1|0,this.i4_1=n,this.j4_1.j(this.i4_1)},fe(kr).c1=function(){return this.h4_1>0},fe(kr).d1=function(){if(!this.c1())throw bu();return this.h4_1=this.h4_1-1|0,this.i4_1=this.h4_1,this.n4_1.j(this.i4_1)},fe(qr).d=function(n){return this.g4(),this.p4(this.k(),n),!0},fe(qr).f=function(){return new mr(this)},fe(qr).u=function(n){return this.q4(n)>=0},fe(qr).q4=function(n){var t=0,r=mt(this);if(t<=r)do{var i=t;if(t=t+1|0,ue(this.j(i),n))return i}while(i!==r);return-1},fe(qr).l=function(n){return new kr(this,n)},fe(qr).equals=function(n){return n===this||!(null==n||!Ge(n,zi))&&ot().g1(this,n)},fe(qr).hashCode=function(){return ot().f1(this)},fe(yr).g=function(){return this.r4_1.g()},fe(yr).h=function(){return this.r4_1.h().j1()},fe(Br).g=function(){return this.s4_1.g()},fe(Br).h=function(){return this.s4_1.h().i1()},fe(Cr).j1=function(){return this.t4_1},fe(Cr).i1=function(){return this.u4_1},fe(Cr).v4=function(n){var t=this.u4_1;return this.u4_1=n,t},fe(Cr).hashCode=function(){return lt().k1(this)},fe(Cr).toString=function(){return lt().l1(this)},fe(Cr).equals=function(n){return lt().m1(this,n)},fe(xr).u=function(n){return this.w4(n)},fe(jr).y4=function(n){throw Bu("Add is not supported on keys")},fe(jr).d=function(n){return this.y4(null==n||Ve(n)?n:le())},fe(jr).z4=function(n){return this.x4_1.t1(n)},fe(jr).u=function(n){return!(null!=n&&!Ve(n))&&this.z4(null==n||Ve(n)?n:le())},fe(jr).f=function(){return new yr(this.x4_1.o().f())},fe(jr).k=function(){return this.x4_1.k()},fe(jr).g4=function(){return this.x4_1.g4()},fe(Pr).f5=function(n){throw Bu("Add is not supported on values")},fe(Pr).d=function(n){return this.f5(null==n||Ve(n)?n:le())},fe(Pr).r1=function(n){return this.e5_1.s1(n)},fe(Pr).u=function(n){return!(null!=n&&!Ve(n))&&this.r1(null==n||Ve(n)?n:le())},fe(Pr).f=function(){return new Br(this.e5_1.o().f())},fe(Pr).k=function(){return this.e5_1.k()},fe(Pr).g4=function(){return this.e5_1.g4()},fe(Ir).g5=function(){return null==this.c5_1&&(this.c5_1=new jr(this)),ae(this.c5_1)},fe(Ir).w1=function(){return null==this.d5_1&&(this.d5_1=new Pr(this)),ae(this.d5_1)},fe(Ir).g4=function(){},fe(Sr).equals=function(n){return n===this||!(null==n||!Ge(n,Ai))&&gt().y1(this,n)},fe(Sr).hashCode=function(){return gt().x1(this)},fe(Mr).j5=function(){return this.g4(),this.c_1=!0,this.k()>0?this:Er().i5_1},fe(Mr).k=function(){return this.b_1.length},fe(Mr).j=function(n){var t=this.b_1[Ar(this,n)];return null==t||Ve(t)?t:le()},fe(Mr).f4=function(n,t){this.g4(),Ar(this,n);var r=this.b_1[n];this.b_1[n]=t;var i=r;return null==i||Ve(i)?i:le()},fe(Mr).d=function(n){return this.g4(),this.b_1.push(n),this.o4_1=this.o4_1+1|0,!0},fe(Mr).p4=function(n,t){this.g4(),this.b_1.splice(function(n,t){return ot().b1(t,n.k()),t}(this,n),0,t),this.o4_1=this.o4_1+1|0},fe(Mr).m=function(n){if(this.g4(),n.i())return!1;for(var t,r,i,e=(t=this,r=n.k(),i=t.k(),t.b_1.length=t.k()+r|0,i),u=0,o=n.f();o.g();){var f=o.h(),s=u;u=s+1|0;var c=gr(s);this.b_1[e+c|0]=f}return this.o4_1=this.o4_1+1|0,!0},fe(Mr).q4=function(n){return Nn(this.b_1,n)},fe(Mr).toString=function(){return n=this.b_1,t=(t=", ")===A?", ":t,r=(r="[")===A?"":r,i=(i="]")===A?"":i,e=(e=A)===A?-1:e,u=(u=A)===A?"...":u,o=(o=Ki)===A?null:o,function(n,t,r,i,e,u,o,f){r=r===A?", ":r,i=i===A?"":i,e=e===A?"":e,u=u===A?-1:u,o=o===A?"...":o,f=f===A?null:f,t.e(i);var s=0,c=0,a=n.length;n:for(;c<a;){var h=n[c];if(c=c+1|0,(s=s+1|0)>1&&t.e(r),!(u<0||s<=u))break n;Vt(t,h,f)}return u>=0&&s>u&&t.e(o),t.e(e),t}(n,wi(),t,r,i,e,u,o).toString();var n,t,r,i,e,u,o},fe(Mr).k5=function(){return[].slice.call(this.b_1)},fe(Mr).toArray=function(){return this.k5()},fe(Mr).g4=function(){if(this.c_1)throw yu()},fe(Or).l5=function(n,t){return ue(n,t)},fe(Or).m5=function(n){var t=null==n?null:ie(n);return null==t?0:t},fe(Rr).o5=function(n){throw Bu("Add is not supported on entries")},fe(Rr).d=function(n){return this.o5(null!=n&&Ge(n,Ni)?n:le())},fe(Rr).w4=function(n){return this.n5_1.u1(n)},fe(Rr).f=function(){return this.n5_1.t5_1.f()},fe(Rr).k=function(){return this.n5_1.k()},fe(Ur).t1=function(n){return this.t5_1.z4(n)},fe(Ur).s1=function(n){var t;n:{var r=this.t5_1;if(Ge(r,Ei)&&r.i())t=!1;else{for(var i=r.f();i.g();){var e=i.h();if(this.u5_1.l5(e.i1(),n)){t=!0;break n}}t=!1}}return t},fe(Ur).o=function(){return null==this.v5_1&&(this.v5_1=this.x5()),ae(this.v5_1)},fe(Ur).x5=function(){return new Rr(this)},fe(Ur).v1=function(n){return this.t5_1.v1(n)},fe(Ur).h5=function(n,t){return this.t5_1.h5(n,t)},fe(Ur).k=function(){return this.t5_1.k()},fe(Qr).d=function(n){return null==this.y5_1.h5(n,this)},fe(Qr).u=function(n){return this.y5_1.t1(n)},fe(Qr).i=function(){return this.y5_1.i()},fe(Qr).f=function(){return this.y5_1.g5().f()},fe(Qr).k=function(){return this.y5_1.k()},fe(Kr).g=function(){return-1===this.z5_1&&(this.z5_1=function(n){if(null!=n.c6_1&&n.d6_1){var t=n.c6_1.length;if(n.e6_1=n.e6_1+1|0,n.e6_1<t)return 0}if(n.b6_1=n.b6_1+1|0,n.b6_1<n.a6_1.length){n.c6_1=n.g6_1.i6_1[n.a6_1[n.b6_1]];var r=n,i=n.c6_1;return r.d6_1=null!=i&&Ue(i),n.e6_1=0,0}return n.c6_1=null,1}(this)),0===this.z5_1},fe(Kr).h=function(){if(!this.g())throw bu();var n=this.d6_1?this.c6_1[this.e6_1]:this.c6_1;return this.f6_1=n,this.z5_1=-1,n},fe(Xr).w5=function(){return this.h6_1},fe(Xr).k=function(){return this.j6_1},fe(Xr).h5=function(n,t){var r=this.h6_1.m5(n),i=Wr(this,r);if(null==i)this.i6_1[r]=new Cr(n,t);else{if(null==i||!Ue(i)){var e,u=i;return this.h6_1.l5(u.j1(),n)?u.v4(t):(e=[u,new Cr(n,t)],this.i6_1[r]=e,this.j6_1=this.j6_1+1|0,null)}var o=i,f=Yr(o,this,n);if(null!=f)return f.v4(t);o.push(new Cr(n,t))}return this.j6_1=this.j6_1+1|0,null},fe(Xr).z4=function(n){return!(null==Zr(this,n))},fe(Xr).v1=function(n){var t=Zr(this,n);return null==t?null:t.i1()},fe(Xr).f=function(){return new Kr(this)},fe(ni).g=function(){return!(null===this.m6_1)},fe(ni).h=function(){if(!this.g())throw bu();var n=ae(this.m6_1);this.l6_1=n;var t,r=n.b7_1;return t=r!==this.n6_1.y6_1.v6_1?r:null,this.m6_1=t,n},fe(ii).v4=function(n){return this.d7_1.g4(),fe(Cr).v4.call(this,n)},fe(ei).o5=function(n){throw Bu("Add is not supported on entries")},fe(ei).d=function(n){return this.o5(null!=n&&Ge(n,Ni)?n:le())},fe(ei).w4=function(n){return this.y6_1.u1(n)},fe(ei).f=function(){return new ni(this)},fe(ei).k=function(){return this.y6_1.k()},fe(ei).g4=function(){return this.y6_1.g4()},fe(fi).j5=function(){var n;if(this.g4(),this.x6_1=!0,this.k()>0)n=this;else{var t=ri().e7_1;n=Ge(t,Li)?t:le()}return n},fe(fi).t1=function(n){return this.w6_1.t1(n)},fe(fi).s1=function(n){var t=this.v6_1;if(null==t)return!1;var r=t;do{if(ue(r.i1(),n))return!0;r=ae(r.b7_1)}while(r!==this.v6_1);return!1},fe(fi).x5=function(){return new ei(this)},fe(fi).v1=function(n){var t=this.w6_1.v1(n);return null==t?null:t.i1()},fe(fi).h5=function(n,t){this.g4();var r=this.w6_1.v1(n);if(null==r){var i=new ii(this,n,t);return this.w6_1.h5(n,i),function(n,t){if(null!=n.b7_1||null!=n.c7_1)throw au(re("Check failed."));var r=t.v6_1;if(null==r)t.v6_1=n,n.b7_1=n,n.c7_1=n;else{var i=r.c7_1;if(null==i)throw au(re("Required value was null."));var e=i;n.c7_1=e,n.b7_1=r,r.c7_1=n,e.b7_1=n}}(i,this),null}return r.v4(t)},fe(fi).k=function(){return this.w6_1.k()},fe(fi).g4=function(){if(this.x6_1)throw yu()},fe(ai).g4=function(){return this.y5_1.g4()},fe(li).h7=function(){this.i7("\n")},fe(li).j7=function(n){this.i7(n),this.h7()},fe(_i).i7=function(n){var t=String(n);this.k7_1.write(t)},fe(vi).i7=function(n){var t=String(n),r=t.lastIndexOf("\n",0);if(r>=0){var i=this.m7_1;this.m7_1=i+t.substring(0,r),this.n7();var e=r+1|0;t=t.substring(e)}this.m7_1=this.m7_1+t},fe(vi).n7=function(){console.log(this.m7_1),this.m7_1=""},fe(di).i7=function(n){var t=this.m7_1;this.m7_1=t+String(n)},fe(bi).x3=function(){return this.o7_1.length},fe(bi).y3=function(n){var t=this.o7_1;if(!(n>=0&&n<=Zt(t)))throw su("index: "+n+", length: "+this.x3()+"}");return Qi(t,n)},fe(bi).z3=function(n,t){return this.o7_1.substring(n,t)},fe(bi).i3=function(n){return this.o7_1=this.o7_1+new Si(n),this},fe(bi).e=function(n){return this.o7_1=this.o7_1+Di(n),this},fe(bi).p7=function(n){var t=this.o7_1;return this.o7_1=t+(null==n?"null":n),this},fe(bi).toString=function(){return this.o7_1},fe(ki).t7=function(n){var t=this.q7_1;return n.replace(t,"\\$&")},fe(ki).u7=function(n){var t=this.s7_1;return n.replace(t,"$$$$")},fe(yi).a8=function(n){this.x7_1.lastIndex=0;var t=this.x7_1.exec(re(n));return null!=t&&0===t.index&&this.x7_1.lastIndex===Yi(n)},fe(yi).toString=function(){return this.x7_1.toString()},fe(Si).o8=function(n){return xi(this.h3_1,n)},fe(Si).a4=function(n){return function(n,t){return xi(n.h3_1,t instanceof Si?t.h3_1:le())}(this,n)},fe(Si).equals=function(n){return function(n,t){return t instanceof Si&&n===t.h3_1}(this.h3_1,n)},fe(Si).hashCode=function(){return this.h3_1},fe(Si).toString=function(){return ji(this.h3_1)},fe(Fi).r8=function(n){return Xi(this.q8_1,n.q8_1)},fe(Fi).a4=function(n){return this.r8(n instanceof Fi?n:le())},fe(Fi).equals=function(n){return this===n},fe(Fi).hashCode=function(){return te(this)},fe(Fi).toString=function(){return this.p8_1},fe(Ri).g=function(){return!(this.s8_1===this.t8_1.length)},fe(Ri).h=function(){if(this.s8_1===this.t8_1.length)throw pu(""+this.s8_1);var n=this.s8_1;return this.s8_1=n+1|0,this.t8_1[n]},fe(ve).b9=function(n){return me(this,n)},fe(ve).a4=function(n){return this.b9(n instanceof ve?n:le())},fe(ve).c9=function(n){return ke(this,n)},fe(ve).d9=function(n){return function(n,t){if(Ae(),Ie(t))throw _u("division by zero");if(Ie(n))return de();if(Ce(n,be())){if(Ce(t,ge())||Ce(t,we()))return be();if(Ce(t,be()))return ge();var r=function(n){Ae();return new ve(n.u8_1>>>1|n.v8_1<<31,n.v8_1>>1)}(n),i=function(n){Ae();return new ve(n.u8_1<<1,n.v8_1<<1|n.u8_1>>>31)}(r.d9(t));return Ce(i,de())?Pe(t)?ge():we():ke(i,qe(n,ye(t,i)).d9(t))}if(Ce(t,be()))return de();if(Pe(n))return Pe(t)?ze(n).d9(ze(t)):ze(ze(n).d9(t));if(Pe(t))return ze(n.d9(ze(t)));for(var e=de(),u=n;Ne(u,t);){for(var o=Be(u)/Be(t),f=Math.max(1,Math.floor(o)),s=Math.ceil(Math.log(f)/Math.LN2),c=s<=48?1:Math.pow(2,s-48),a=Te(f),h=ye(a,t);Pe(h)||Le(h,u);)h=ye(a=Te(f-=c),t);Ie(a)&&(a=ge()),e=ke(e,a),u=qe(u,h)}return e}(this,n)},fe(ve).e9=function(){return this.f9().c9(new ve(1,0))},fe(ve).f9=function(){return new ve(~this.u8_1,~this.v8_1)},fe(ve).g9=function(){return this.u8_1},fe(ve).w8=function(){return Be(this)},fe(ve).valueOf=function(){return this.w8()},fe(ve).equals=function(n){return n instanceof ve&&Ce(this,n)},fe(ve).hashCode=function(){return Ae(),this.u8_1^this.v8_1},fe(ve).toString=function(){return xe(this,10)},fe(Nu).toString=function(){return"Model(text="+this.o9_1+", tooltip="+this.p9_1+")"},fe(Nu).hashCode=function(){var n=ee(this.o9_1);return zn(n,31)+ee(this.p9_1)|0},fe(Nu).equals=function(n){if(this===n)return!0;if(!(n instanceof Nu))return!1;var t=n instanceof Nu?n:le();return this.o9_1===t.o9_1&&this.p9_1===t.p9_1},fe(Au).v9=function(n,t){return this.w9(new Nu(n,t))},fe(Au).w9=function(n){var t,r;return Ff().y9(Xf((t=n,r=this,function(n){return n.s9(t.p9_1),n.t9("copy-button"),n.u9(function(n,t){return function(r){return n.q9_1(t.o9_1)}}(r,t)),hr()})),[])},fe(Au).z9=function(n){return this.w9(n instanceof Nu?n:le())},fe(Au).aa=function(n,t){return t},fe(Au).ba=function(n,t){var r=null==n||Ve(n)?n:le();return this.aa(r,t instanceof Nu?t:le())},fe(Fu).ka=function(n){return function(n,t){for(var r=Mf(),i=t.ca_1,e=Lr(Ct(i,10)),u=i.f();u.g();){var o,f,s=u.h();s instanceof bf?f=Mf().ga(s.fa_1):s instanceof pf?f=Mu(n,s.da_1,s.ea_1):he(),o=f,e.d(o)}return r.ha(e)}(this,n)},fe(Fu).z9=function(n){return this.ka(n instanceof Bf?n:le())},fe(Fu).la=function(n,t){return t},fe(Fu).ba=function(n,t){var r=null==n||Ve(n)?n:le();return this.la(r,t instanceof Bf?t:le())},fe(Du).pa=function(n,t,r){return new Du(n,t,r)},fe(Du).qa=function(n,t,r,i){return n=n===A?this.ma_1:n,t=t===A?this.na_1:t,r=r===A?this.oa_1:r,i===A?this.pa(n,t,r):i.pa.call(this,n,t,r)},fe(Du).toString=function(){return"Exception(summary="+this.ma_1+", fullText="+this.na_1+", parts="+this.oa_1+")"},fe(Du).hashCode=function(){var n=null==this.ma_1?0:this.ma_1.hashCode();return n=zn(n,31)+ee(this.na_1)|0,zn(n,31)+ie(this.oa_1)|0},fe(Du).equals=function(n){if(this===n)return!0;if(!(n instanceof Du))return!1;var t=n instanceof Du?n:le();return!!ue(this.ma_1,t.ma_1)&&this.na_1===t.na_1&&!!ue(this.oa_1,t.oa_1)},fe(Ou).ta=function(n,t){return new Ou(n,t)},fe(Ou).ua=function(n,t,r){return n=n===A?this.ra_1:n,t=t===A?this.sa_1:t,r===A?this.ta(n,t):r.ta.call(this,n,t)},fe(Ou).toString=function(){return"StackTracePart(lines="+this.ra_1+", state="+this.sa_1+")"},fe(Ou).hashCode=function(){var n=ie(this.ra_1);return zn(n,31)+(null==this.sa_1?0:this.sa_1.hashCode())|0},fe(Ou).equals=function(n){if(this===n)return!0;if(!(n instanceof Ou))return!1;var t=n instanceof Ou?n:le();return!!ue(this.ra_1,t.ra_1)&&!!ue(this.sa_1,t.sa_1)},fe(Ru).toString=function(){return"Error(label="+this.va_1+", docLink="+this.wa_1+")"},fe(Ru).hashCode=function(){var n=ie(this.va_1);return zn(n,31)+(null==this.wa_1?0:ie(this.wa_1))|0},fe(Ru).equals=function(n){if(this===n)return!0;if(!(n instanceof Ru))return!1;var t=n instanceof Ru?n:le();return!!ue(this.va_1,t.va_1)&&!!ue(this.wa_1,t.wa_1)},fe(Hu).toString=function(){return"Warning(label="+this.xa_1+", docLink="+this.ya_1+")"},fe(Hu).hashCode=function(){var n=ie(this.xa_1);return zn(n,31)+(null==this.ya_1?0:ie(this.ya_1))|0},fe(Hu).equals=function(n){if(this===n)return!0;if(!(n instanceof Hu))return!1;var t=n instanceof Hu?n:le();return!!ue(this.xa_1,t.xa_1)&&!!ue(this.ya_1,t.ya_1)},fe($u).toString=function(){return"Message(prettyText="+this.za_1+")"},fe($u).hashCode=function(){return this.za_1.hashCode()},fe($u).equals=function(n){if(this===n)return!0;if(!(n instanceof $u))return!1;var t=n instanceof $u?n:le();return!!this.za_1.equals(t.za_1)},fe(Gu).toString=function(){return"ListElement(prettyText="+this.ab_1+")"},fe(Gu).hashCode=function(){return this.ab_1.hashCode()},fe(Gu).equals=function(n){if(this===n)return!0;if(!(n instanceof Gu))return!1;var t=n instanceof Gu?n:le();return!!this.ab_1.equals(t.ab_1)},fe(Uu).toString=function(){return"TreeNode(prettyText="+this.bb_1+")"},fe(Uu).hashCode=function(){return this.bb_1.hashCode()},fe(Uu).equals=function(n){if(this===n)return!0;if(!(n instanceof Uu))return!1;var t=n instanceof Uu?n:le();return!!this.bb_1.equals(t.bb_1)},fe(Vu).toString=function(){return"Link(href="+this.cb_1+", label="+this.db_1+")"},fe(Vu).hashCode=function(){var n=ee(this.cb_1);return zn(n,31)+ee(this.db_1)|0},fe(Vu).equals=function(n){if(this===n)return!0;if(!(n instanceof Vu))return!1;var t=n instanceof Vu?n:le();return this.cb_1===t.cb_1&&this.db_1===t.db_1},fe(Qu).toString=function(){return"Label(text="+this.eb_1+")"},fe(Qu).hashCode=function(){return ee(this.eb_1)},fe(Qu).equals=function(n){if(this===n)return!0;if(!(n instanceof Qu))return!1;var t=n instanceof Qu?n:le();return this.eb_1===t.eb_1},fe(ro).toString=function(){return"Info(label="+this.hb_1+", docLink="+this.ib_1+")"},fe(ro).hashCode=function(){var n=ie(this.hb_1);return zn(n,31)+(null==this.ib_1?0:ie(this.ib_1))|0},fe(ro).equals=function(n){if(this===n)return!0;if(!(n instanceof ro))return!1;var t=n instanceof ro?n:le();return!!ue(this.hb_1,t.hb_1)&&!!ue(this.ib_1,t.ib_1)},fe(io).toString=function(){return"Project(path="+this.jb_1+")"},fe(io).hashCode=function(){return ee(this.jb_1)},fe(io).equals=function(n){if(this===n)return!0;if(!(n instanceof io))return!1;var t=n instanceof io?n:le();return this.jb_1===t.jb_1},fe(eo).toString=function(){return"Task(path="+this.kb_1+", type="+this.lb_1+")"},fe(eo).hashCode=function(){var n=ee(this.kb_1);return zn(n,31)+ee(this.lb_1)|0},fe(eo).equals=function(n){if(this===n)return!0;if(!(n instanceof eo))return!1;var t=n instanceof eo?n:le();return this.kb_1===t.kb_1&&this.lb_1===t.lb_1},fe(uo).toString=function(){return"TaskPath(path="+this.mb_1+")"},fe(uo).hashCode=function(){return ee(this.mb_1)},fe(uo).equals=function(n){if(this===n)return!0;if(!(n instanceof uo))return!1;var t=n instanceof uo?n:le();return this.mb_1===t.mb_1},fe(oo).toString=function(){return"Bean(type="+this.nb_1+")"},fe(oo).hashCode=function(){return ee(this.nb_1)},fe(oo).equals=function(n){if(this===n)return!0;if(!(n instanceof oo))return!1;var t=n instanceof oo?n:le();return this.nb_1===t.nb_1},fe(fo).toString=function(){return"SystemProperty(name="+this.ob_1+")"},fe(fo).hashCode=function(){return ee(this.ob_1)},fe(fo).equals=function(n){if(this===n)return!0;if(!(n instanceof fo))return!1;var t=n instanceof fo?n:le();return this.ob_1===t.ob_1},fe(so).toString=function(){return"Property(kind="+this.pb_1+", name="+this.qb_1+", owner="+this.rb_1+")"},fe(so).hashCode=function(){var n=ee(this.pb_1);return n=zn(n,31)+ee(this.qb_1)|0,zn(n,31)+ee(this.rb_1)|0},fe(so).equals=function(n){if(this===n)return!0;if(!(n instanceof so))return!1;var t=n instanceof so?n:le();return this.pb_1===t.pb_1&&this.qb_1===t.qb_1&&this.rb_1===t.rb_1},fe(co).toString=function(){return"BuildLogic(location="+this.sb_1+")"},fe(co).hashCode=function(){return ee(this.sb_1)},fe(co).equals=function(n){if(this===n)return!0;if(!(n instanceof co))return!1;var t=n instanceof co?n:le();return this.sb_1===t.sb_1},fe(ao).toString=function(){return"BuildLogicClass(type="+this.tb_1+")"},fe(ao).hashCode=function(){return ee(this.tb_1)},fe(ao).equals=function(n){if(this===n)return!0;if(!(n instanceof ao))return!1;var t=n instanceof ao?n:le();return this.tb_1===t.tb_1},fe(_o).zb=function(){return this.yb_1},fe(_o).toString=function(){return"TaskTreeIntent(delegate="+this.yb_1+")"},fe(_o).hashCode=function(){return ie(this.yb_1)},fe(_o).equals=function(n){if(this===n)return!0;if(!(n instanceof _o))return!1;var t=n instanceof _o?n:le();return!!ue(this.yb_1,t.yb_1)},fe(vo).zb=function(){return this.ac_1},fe(vo).toString=function(){return"MessageTreeIntent(delegate="+this.ac_1+")"},fe(vo).hashCode=function(){return ie(this.ac_1)},fe(vo).equals=function(n){if(this===n)return!0;if(!(n instanceof vo))return!1;var t=n instanceof vo?n:le();return!!ue(this.ac_1,t.ac_1)},fe(go).zb=function(){return this.bc_1},fe(go).toString=function(){return"InputTreeIntent(delegate="+this.bc_1+")"},fe(go).hashCode=function(){return ie(this.bc_1)},fe(go).equals=function(n){if(this===n)return!0;if(!(n instanceof go))return!1;var t=n instanceof go?n:le();return!!ue(this.bc_1,t.bc_1)},fe(wo).zb=function(){return this.cc_1},fe(wo).toString=function(){return"IncompatibleTaskTreeIntent(delegate="+this.cc_1+")"},fe(wo).hashCode=function(){return ie(this.cc_1)},fe(wo).equals=function(n){if(this===n)return!0;if(!(n instanceof wo))return!1;var t=n instanceof wo?n:le();return!!ue(this.cc_1,t.cc_1)},fe(bo).toString=function(){return"SetTab(tab="+this.dc_1+")"},fe(bo).hashCode=function(){return this.dc_1.hashCode()},fe(bo).equals=function(n){if(this===n)return!0;if(!(n instanceof bo))return!1;var t=n instanceof bo?n:le();return!!this.dc_1.equals(t.dc_1)},fe(po).mc=function(n,t,r,i,e,u,o,f){return new po(n,t,r,i,e,u,o,f)},fe(po).nc=function(n,t,r,i,e,u,o,f,s){return n=n===A?this.ec_1:n,t=t===A?this.fc_1:t,r=r===A?this.gc_1:r,i=i===A?this.hc_1:i,e=e===A?this.ic_1:e,u=u===A?this.jc_1:u,o=o===A?this.kc_1:o,f=f===A?this.lc_1:f,s===A?this.mc(n,t,r,i,e,u,o,f):s.mc.call(this,n,t,r,i,e,u,o,f)},fe(po).toString=function(){return"Model(heading="+this.ec_1+", summary="+this.fc_1+", learnMore="+this.gc_1+", messageTree="+this.hc_1+", locationTree="+this.ic_1+", inputTree="+this.jc_1+", incompatibleTaskTree="+this.kc_1+", tab="+this.lc_1+")"},fe(po).hashCode=function(){var n=this.ec_1.hashCode();return n=zn(n,31)+ie(this.fc_1)|0,n=zn(n,31)+this.gc_1.hashCode()|0,n=zn(n,31)+this.hc_1.hashCode()|0,n=zn(n,31)+this.ic_1.hashCode()|0,n=zn(n,31)+this.jc_1.hashCode()|0,n=zn(n,31)+this.kc_1.hashCode()|0,zn(n,31)+this.lc_1.hashCode()|0},fe(po).equals=function(n){if(this===n)return!0;if(!(n instanceof po))return!1;var t=n instanceof po?n:le();return!!(this.ec_1.equals(t.ec_1)&&ue(this.fc_1,t.fc_1)&&this.gc_1.equals(t.gc_1)&&this.hc_1.equals(t.hc_1)&&this.ic_1.equals(t.ic_1)&&this.jc_1.equals(t.jc_1)&&this.kc_1.equals(t.kc_1)&&this.lc_1.equals(t.lc_1))},fe(Go).gd=function(n,t){var r,i;return n instanceof _o?r=t.nc(A,A,A,A,ls().id(n.yb_1,t.ic_1)):n instanceof vo?r=t.nc(A,A,A,ls().id(n.ac_1,t.hc_1)):n instanceof go?r=t.nc(A,A,A,A,A,ls().id(n.bc_1,t.jc_1)):n instanceof wo?r=t.nc(A,A,A,A,A,A,ls().id(n.cc_1,t.kc_1)):n instanceof pc?r=function(n,t,r,i){var e;return r instanceof vo?e=n.nc(A,A,A,gc(n.hc_1,r,i)):r instanceof _o?e=n.nc(A,A,A,A,gc(n.ic_1,r,i)):r instanceof go?e=n.nc(A,A,A,A,A,gc(n.jc_1,r,i)):r instanceof wo?e=n.nc(A,A,A,A,A,A,gc(n.kc_1,r,i)):(console.error("Unhandled tree intent: "+r),e=n),e}(t,0,n.xc_1,(i=n,function(n){var t;if(!(n instanceof Du))throw ou(re("Failed requirement."));for(var r=n.oa_1,e=i.wc_1,u=Lr(Ct(r,10)),o=0,f=r.f();f.g();){var s,c,a=f.h(),h=o;if(o=h+1|0,e===gr(h)){var l=a.sa_1;c=a.ua(A,null==l?null:l.ad())}else c=a;s=c,u.d(s)}return t=u,n.qa(A,A,t)})):n instanceof wc?(window.navigator.clipboard.writeText(n.hd_1),r=t):n instanceof bo?r=t.nc(A,A,A,A,A,A,A,n.dc_1):(console.error("Unhandled intent: "+n),r=t),r},fe(Go).ba=function(n,t){var r=n instanceof mc?n:le();return this.gd(r,t instanceof po?t:le())},fe(Go).jd=function(n){return Nf().y9(Xf(Eo),[qo(0,n),yo(0,n)])},fe(Go).z9=function(n){return this.jd(n instanceof po?n:le())},fe(Qo).toString=function(){return"ImportedProblem(problem="+this.kd_1+", message="+this.ld_1+", trace="+this.md_1+")"},fe(Qo).hashCode=function(){var n=ie(this.kd_1);return n=zn(n,31)+this.ld_1.hashCode()|0,zn(n,31)+ie(this.md_1)|0},fe(Qo).equals=function(n){if(this===n)return!0;if(!(n instanceof Qo))return!1;var t=n instanceof Qo?n:le();return!!ue(this.kd_1,t.kd_1)&&!!this.ld_1.equals(t.ld_1)&&!!ue(this.md_1,t.md_1)},fe(of).ud=function(n,t){return this.td_1(n,t)},fe(of).compare=function(n,t){return this.ud(n,t)},fe(wf).toString=function(){return"LearnMore(text="+this.sc_1+", documentationLink="+this.tc_1+")"},fe(wf).hashCode=function(){var n=ee(this.sc_1);return zn(n,31)+ee(this.tc_1)|0},fe(wf).equals=function(n){if(this===n)return!0;if(!(n instanceof wf))return!1;var t=n instanceof wf?n:le();return this.sc_1===t.sc_1&&this.tc_1===t.tc_1},fe(bf).toString=function(){return"Text(text="+this.fa_1+")"},fe(bf).hashCode=function(){return ee(this.fa_1)},fe(bf).equals=function(n){if(this===n)return!0;if(!(n instanceof bf))return!1;var t=n instanceof bf?n:le();return this.fa_1===t.fa_1},fe(pf).toString=function(){return"Reference(name="+this.da_1+", clipboardString="+this.ea_1+")"},fe(pf).hashCode=function(){var n=ee(this.da_1);return zn(n,31)+ee(this.ea_1)|0},fe(pf).equals=function(n){if(this===n)return!0;if(!(n instanceof pf))return!1;var t=n instanceof pf?n:le();return this.da_1===t.da_1&&this.ea_1===t.ea_1},fe(kf).ed=function(n){return this.dd_1.d(new bf(n)),this},fe(kf).xd=function(n,t){return this.dd_1.d(new pf(n,t)),this},fe(kf).fd=function(n,t,r){return t=t===A?n:t,r===A?this.xd(n,t):r.xd.call(this,n,t)},fe(kf).j5=function(){return new Bf(Rn(this.dd_1))},fe(qf).rd=function(n){return new Bf(dr(new bf(n)))},fe(qf).qd=function(n){var t=new kf;return n(t),t.j5()},fe(Bf).vd=function(n){return new Bf(n)},fe(Bf).toString=function(){return"PrettyText(fragments="+this.ca_1+")"},fe(Bf).hashCode=function(){return ie(this.ca_1)},fe(Bf).equals=function(n){if(this===n)return!0;if(!(n instanceof Bf))return!1;var t=n instanceof Bf?n:le();return!!ue(this.ca_1,t.ca_1)},fe(Cf).sd=function(n){return function(n){for(var t=$r(),r=n.f();r.g();)for(var i=t,e=r.h().f();e.g();){var u,o=e.h(),f=i,s=f.v1(o);if(null==s){var c=$r();f.h5(o,c),u=c}else u=s;i=u instanceof Ur?u:le()}return t}(n)},fe(If).toString=function(){return"Trie(nestedMaps="+this.wd_1+")"},fe(If).hashCode=function(){return ie(this.wd_1)},fe(If).equals=function(n){return function(n,t){return t instanceof If&&!!ue(n,t instanceof If?t.wd_1:le())}(this.wd_1,n)},fe(Gf).ga=function(n){return Vf().yd(this.x9_1,A,n)},fe(Gf).ha=function(n){return Vf().yd(this.x9_1,A,A,n)},fe(Gf).ja=function(n){return Vf().yd(this.x9_1,A,A,Je(n))},fe(Gf).y9=function(n,t){return Vf().yd(this.x9_1,n,A,Je(t))},fe(Gf).zd=function(n,t){return Vf().yd(this.x9_1,n,A,t)},fe(Gf).fb=function(n,t){return Vf().yd(this.x9_1,n,t)},fe(Gf).rc=function(n,t){return Vf().yd(this.x9_1,A,n,Je(t))},fe(Gf).toString=function(){return"ViewFactory(elementName="+this.x9_1+")"},fe(Gf).hashCode=function(){return ee(this.x9_1)},fe(Gf).equals=function(n){if(this===n)return!0;if(!(n instanceof Gf))return!1;var t=n instanceof Gf?n:le();return this.x9_1===t.x9_1},fe(Uf).ae=function(n,t,r,i){return new Yf(n,t,r,i)},fe(Uf).yd=function(n,t,r,i,e){return t=t===A?bt():t,r=r===A?null:r,i=i===A?bt():i,e===A?this.ae(n,t,r,i):e.ae.call(this,n,t,r,i)},fe(Yf).toString=function(){return"Element(elementName="+this.be_1+", attributes="+this.ce_1+", innerText="+this.de_1+", children="+this.ee_1+")"},fe(Yf).hashCode=function(){var n=ee(this.be_1);return n=zn(n,31)+ie(this.ce_1)|0,n=zn(n,31)+(null==this.de_1?0:ee(this.de_1))|0,zn(n,31)+ie(this.ee_1)|0},fe(Yf).equals=function(n){if(this===n)return!0;if(!(n instanceof Yf))return!1;var t=n instanceof Yf?n:le();return this.be_1===t.be_1&&!!ue(this.ce_1,t.ce_1)&&this.de_1==t.de_1&&!!ue(this.ee_1,t.ee_1)},fe(Jf).u9=function(n){return this.r9_1(new ns("click",n))},fe(Jf).t9=function(n){return this.r9_1(new ts(n))},fe(Jf).gb=function(n){for(var t=0,r=n.length;t<r;){var i=n[t];t=t+1|0,this.r9_1(new ts(i))}return hr()},fe(Jf).s9=function(n){return this.r9_1(new rs("title",n))},fe(Jf).bd=function(n){return this.r9_1(new rs("href",n))},fe(fs).oe=function(){return this.ne_1},fe(fs).toString=function(){return"Toggle(focus="+this.ne_1+")"},fe(fs).hashCode=function(){return ie(this.ne_1)},fe(fs).equals=function(n){if(this===n)return!0;if(!(n instanceof fs))return!1;var t=n instanceof fs?n:le();return!!ue(this.ne_1,t.ne_1)},fe(ss).pe=function(n,t){return this.re(n.qe((r=t,function(n){return n.me(r(n.ub_1))})));var r},fe(ss).re=function(n){return new ss(n)},fe(ss).toString=function(){return"Model(tree="+this.xb_1+")"},fe(ss).hashCode=function(){return this.xb_1.hashCode()},fe(ss).equals=function(n){if(this===n)return!0;if(!(n instanceof ss))return!1;var t=n instanceof ss?n:le();return!!this.xb_1.equals(t.xb_1)},fe(hs).id=function(n,t){var r;if(n instanceof fs){var i=n.oe();r=t.re(i.qe(as))}else he();return r},fe(vs).cd=function(){return this.ve_1},fe(vs).we=function(){return 0},fe(vs).qe=function(n){return n(this.ve_1)},fe(vs).toString=function(){return"Original(tree="+this.ve_1+")"},fe(vs).hashCode=function(){return this.ve_1.hashCode()},fe(vs).equals=function(n){if(this===n)return!0;if(!(n instanceof vs))return!1;var t=n instanceof vs?n:le();return!!this.ve_1.equals(t.ve_1)},fe(ds).cd=function(){return this.ue_1},fe(ds).we=function(){return this.se_1.we()+1|0},fe(ds).qe=function(n){return this.se_1.qe((t=this,r=n,function(n){for(var i,e=n.vb_1,u=t.te_1,o=Lr(Ct(e,10)),f=0,s=e.f();s.g();){var c,a=s.h(),h=f;f=h+1|0,c=u===gr(h)?r(a):a,o.d(c)}return i=o,n.me(A,i)}));var t,r},fe(ds).toString=function(){return"Child(parent="+this.se_1+", index="+this.te_1+", tree="+this.ue_1+")"},fe(ds).hashCode=function(){var n=ie(this.se_1);return n=zn(n,31)+this.te_1|0,zn(n,31)+this.ue_1.hashCode()|0},fe(ds).equals=function(n){if(this===n)return!0;if(!(n instanceof ds))return!1;var t=n instanceof ds?n:le();return!!ue(this.se_1,t.se_1)&&this.te_1===t.te_1&&!!this.ue_1.equals(t.ue_1)},fe(gs).ad=function(){var n;switch(this.q8_1){case 0:n=ps();break;case 1:n=bs();break;default:he()}return n},fe(ws).vc=function(){var n,t;return Xn(On(De(0,this.cd().vb_1.k()-1|0)),(n=this,(t=function(t){return n.xe(t)}).callableName="child",t))},fe(ws).xe=function(n){return new ds(this,n,this.cd().vb_1.j(n))},fe(ms).uc=function(){return new vs(this)},fe(ms).ye=function(){return!this.vb_1.i()},fe(ms).ze=function(n,t,r){return new ms(n,t,r)},fe(ms).me=function(n,t,r,i){return n=n===A?this.ub_1:n,t=t===A?this.vb_1:t,r=r===A?this.wb_1:r,i===A?this.ze(n,t,r):i.ze.call(this,n,t,r)},fe(ms).toString=function(){return"Tree(label="+this.ub_1+", children="+this.vb_1+", state="+this.wb_1+")"},fe(ms).hashCode=function(){var n=null==this.ub_1?0:ie(this.ub_1);return n=zn(n,31)+ie(this.vb_1)|0,zn(n,31)+this.wb_1.hashCode()|0},fe(ms).equals=function(n){if(this===n)return!0;if(!(n instanceof ms))return!1;var t=n instanceof ms?n:le();return!!ue(this.ub_1,t.ub_1)&&!!ue(this.vb_1,t.vb_1)&&!!this.wb_1.equals(t.wb_1)},fe(Cs).toString=function(){return"ProblemNodeGroup(tree="+this.df_1+", children="+this.ef_1+", childGroups="+this.ff_1+", id="+this.gf_1+")"},fe(Cs).hashCode=function(){var n=this.df_1.hashCode();return n=zn(n,31)+ie(this.ef_1)|0,n=zn(n,31)+ie(this.ff_1)|0,zn(n,31)+this.gf_1|0},fe(Cs).equals=function(n){if(this===n)return!0;if(!(n instanceof Cs))return!1;var t=n instanceof Cs?n:le();return!!this.df_1.equals(t.df_1)&&!!ue(this.ef_1,t.ef_1)&&!!ue(this.ff_1,t.ff_1)&&this.gf_1===t.gf_1},fe(Rs).toString=function(){return"Text(text="+this.hf_1+")"},fe(Rs).hashCode=function(){return ee(this.hf_1)},fe(Rs).equals=function(n){if(this===n)return!0;if(!(n instanceof Rs))return!1;var t=n instanceof Rs?n:le();return this.hf_1===t.hf_1},fe(Hs).toString=function(){return"ProblemId(prettyText="+this.if_1+", separator="+this.jf_1+")"},fe(Hs).hashCode=function(){var n=this.if_1.hashCode();return zn(n,31)+(0|this.jf_1)|0},fe(Hs).equals=function(n){if(this===n)return!0;if(!(n instanceof Hs))return!1;var t=n instanceof Hs?n:le();return!!this.if_1.equals(t.if_1)&&this.jf_1===t.jf_1},fe($s).toString=function(){return"Advice(label="+this.kf_1+", docLink="+this.lf_1+")"},fe($s).hashCode=function(){var n=ie(this.kf_1);return zn(n,31)+(null==this.lf_1?0:ie(this.lf_1))|0},fe($s).equals=function(n){if(this===n)return!0;if(!(n instanceof $s))return!1;var t=n instanceof $s?n:le();return!!ue(this.kf_1,t.kf_1)&&!!ue(this.lf_1,t.lf_1)},fe(Us).zb=function(){return this.mf_1},fe(Us).toString=function(){return"MessageTreeIntent(delegate="+this.mf_1+")"},fe(Us).hashCode=function(){return ie(this.mf_1)},fe(Us).equals=function(n){if(this===n)return!0;if(!(n instanceof Us))return!1;var t=n instanceof Us?n:le();return!!ue(this.mf_1,t.mf_1)},fe(Vs).zb=function(){return this.nf_1},fe(Vs).toString=function(){return"ProblemIdTreeIntent(delegate="+this.nf_1+")"},fe(Vs).hashCode=function(){return ie(this.nf_1)},fe(Vs).equals=function(n){if(this===n)return!0;if(!(n instanceof Vs))return!1;var t=n instanceof Vs?n:le();return!!ue(this.nf_1,t.nf_1)},fe(Qs).zb=function(){return this.of_1},fe(Qs).toString=function(){return"FileLocationTreeIntent(delegate="+this.of_1+")"},fe(Qs).hashCode=function(){return ie(this.of_1)},fe(Qs).equals=function(n){if(this===n)return!0;if(!(n instanceof Qs))return!1;var t=n instanceof Qs?n:le();return!!ue(this.of_1,t.of_1)},fe(Zs).toString=function(){return"SetTab(tab="+this.pf_1+")"},fe(Zs).hashCode=function(){return this.pf_1.hashCode()},fe(Zs).equals=function(n){if(this===n)return!0;if(!(n instanceof Zs))return!1;var t=n instanceof Zs?n:le();return!!this.pf_1.equals(t.pf_1)},fe(Ys).yf=function(n,t,r,i,e,u,o,f){return new Ys(n,t,r,i,e,u,o,f)},fe(Ys).zf=function(n,t,r,i,e,u,o,f,s){return n=n===A?this.qf_1:n,t=t===A?this.rf_1:t,r=r===A?this.sf_1:r,i=i===A?this.tf_1:i,e=e===A?this.uf_1:e,u=u===A?this.vf_1:u,o=o===A?this.wf_1:o,f=f===A?this.xf_1:f,s===A?this.yf(n,t,r,i,e,u,o,f):s.yf.call(this,n,t,r,i,e,u,o,f)},fe(Ys).toString=function(){return"Model(heading="+this.qf_1+", summary="+this.rf_1+", learnMore="+this.sf_1+", messageTree="+this.tf_1+", problemIdTree="+this.uf_1+", fileLocationTree="+this.vf_1+", problemCount="+this.wf_1+", tab="+this.xf_1+")"},fe(Ys).hashCode=function(){var n=this.qf_1.hashCode();return n=zn(n,31)+ie(this.rf_1)|0,n=zn(n,31)+this.sf_1.hashCode()|0,n=zn(n,31)+this.tf_1.hashCode()|0,n=zn(n,31)+this.uf_1.hashCode()|0,n=zn(n,31)+this.vf_1.hashCode()|0,n=zn(n,31)+this.wf_1|0,zn(n,31)+this.xf_1.hashCode()|0},fe(Ys).equals=function(n){if(this===n)return!0;if(!(n instanceof Ys))return!1;var t=n instanceof Ys?n:le();return!!(this.qf_1.equals(t.qf_1)&&ue(this.rf_1,t.rf_1)&&this.sf_1.equals(t.sf_1)&&this.tf_1.equals(t.tf_1)&&this.uf_1.equals(t.uf_1)&&this.vf_1.equals(t.vf_1)&&this.wf_1===t.wf_1&&this.xf_1.equals(t.xf_1))},fe(vc).ag=function(n,t){var r,i;return n instanceof Qs?r=t.zf(A,A,A,A,A,ls().id(n.of_1,t.vf_1)):n instanceof Vs?r=t.zf(A,A,A,A,ls().id(n.nf_1,t.uf_1)):n instanceof Us?r=t.zf(A,A,A,ls().id(n.mf_1,t.tf_1)):n instanceof pc?r=function(n,t,r,i){var e;return r instanceof Us?e=n.zf(A,A,A,gc(n.tf_1,r,i)):r instanceof Vs?e=n.zf(A,A,A,A,gc(n.uf_1,r,i)):r instanceof Qs?e=n.zf(A,A,A,A,A,gc(n.vf_1,r,i)):(console.error("Unhandled tree intent: "+r),e=n),e}(t,0,n.xc_1,(i=n,function(n){var t;if(!(n instanceof Du))throw ou(re("Failed requirement."));for(var r=n.oa_1,e=i.wc_1,u=Lr(Ct(r,10)),o=0,f=r.f();f.g();){var s,c,a=f.h(),h=o;if(o=h+1|0,e===gr(h)){var l=a.sa_1;c=a.ua(A,null==l?null:l.ad())}else c=a;s=c,u.d(s)}return t=u,n.qa(A,A,t)})):n instanceof wc?(window.navigator.clipboard.writeText(n.hd_1),r=t):n instanceof Zs?r=t.zf(A,A,A,A,A,A,A,n.pf_1):(console.error("Unhandled intent: "+n),r=t),r},fe(vc).ba=function(n,t){var r=n instanceof mc?n:le();return this.ag(r,t instanceof Ys?t:le())},fe(vc).bg=function(n){return Nf().y9(Xf(oc),[Ks(0,n),Xs(0,n)])},fe(vc).z9=function(n){return this.bg(n instanceof Ys?n:le())},fe(wc).toString=function(){return"Copy(text="+this.hd_1+")"},fe(wc).hashCode=function(){return ee(this.hd_1)},fe(wc).equals=function(n){if(this===n)return!0;if(!(n instanceof wc))return!1;var t=n instanceof wc?n:le();return this.hd_1===t.hd_1},fe(pc).toString=function(){return"ToggleStackTracePart(partIndex="+this.wc_1+", location="+this.xc_1+")"},fe(pc).hashCode=function(){var n=this.wc_1;return zn(n,31)+ie(this.xc_1)|0},fe(pc).equals=function(n){if(this===n)return!0;if(!(n instanceof pc))return!1;var t=n instanceof pc?n:le();return this.wc_1===t.wc_1&&!!ue(this.xc_1,t.xc_1)},fe(Xr).k6=function(){var n=Object.create(null);return n.foo=1,delete n.foo,hr(),n},l=null,wn=0,function(){var n=configurationCacheProblems();if(null==n.problemsReport)Sf(zf("report"),Uo(),function(n){var t,r,i,e,u,o,f,s,c,a,h=function(n){for(var t=Tr(),r=Tr(),i=Tr(),e=0,u=n.length;e<u;){var o=n[e];e=e+1|0;var f,s=o.input,c=null==s?null:r.d(Yo(s,o));if(null==c){var a=o.incompatibleTask;f=null==a?null:i.d(Yo(a,o))}else f=c;if(null==f){var h=ae(o.problem);t.d(Yo(h,o))}}return new Zo(t,r,i)}(n.diagnostics),l=n.totalProblemCount;return new po((f=(t=n).buildName,s=t.requestedTasks,c=null==s?null:Yt(s," ",A,r=r!==A&&r)>=0,a=null==c||c,yf().qd((i=t,e=f,u=s,o=a,function(n){n.ed(function(n){var t;if(Yi(n)>0){var r,i=Qi(n,0);r=function(n){return 97<=n&&n<=122||!(xi(n,128)<0)&&function(n){var t;return t=1===function(n){var t=n,r=tu(iu().h9_1,t),i=iu().h9_1[r],e=(i+iu().i9_1[r]|0)-1|0,u=iu().j9_1[r];if(t>e)return 0;var o=3&u;if(0===o){var f=2,s=i,c=0;if(c<=1)do{if(c=c+1|0,(s=s+(u>>f&127)|0)>t)return 3;if((s=s+(u>>(f=f+7|0)&127)|0)>t)return 0;f=f+7|0}while(c<=1);return 3}if(u<=7)return o;var a=t-i|0;return u>>zn(2,u<=31?a%2|0:a)&3}(n)||function(n){var t=tu(uu().k9_1,n);return t>=0&&n<(uu().k9_1[t]+uu().l9_1[t]|0)}(n),t}(n)}(i)?function(n){return function(n){var t=ji(n).toUpperCase();if(t.length>1){var r;if(329===n)r=t;else{var i=Qi(t,0),e=t.substring(1).toLowerCase();r=ji(i)+e}return r}return ji(function(n){return function(n){var t=n;return 452<=t&&t<=460||497<=t&&t<=499?Fe(zn(3,(t+1|0)/3|0)):4304<=t&&t<=4346||4349<=t&&t<=4351?n:pi(n)}(n)}(n))}(n)}(i):ji(i),t=re(r)+n.substring(1)}else t=n;return t}(i.cacheAction)+" the configuration cache for ");var t=e;null==t||n.fd(t),null==e||n.ed(" build and ");var r=u;return null==(null==r?null:n.fd(r))&&n.ed("default"),n.ed(o?" tasks":" task"),hr()}))),function(n,t){var r=n.cacheActionDescription,i=null==r?null:_f(r),e=yf().rd(function(n){var t=n.od_1.k(),r=vf(t,"build configuration input");return t>0?r+" and will cause the cache to be discarded when "+(t<=1?"its":"their")+" value change":r}(t)),u=yf().rd(function(n,t){var r=n.totalProblemCount,i=t.nd_1.k(),e=vf(r,"problem");return r>i?e+", only the first "+i+" "+gf(i)+" included in this report":e}(n,t));return function(n,t){for(var r=0,i=n.length;r<i;){var e=n[r];r=r+1|0,null!=e&&t.d(e)}return t}([i,e,u],Tr())}(n,h),new wf("Gradle Configuration Cache",n.documentationLink),ef(new Qu(Ro().qc_1),Xn(On(h.nd_1),cf)),ef(new Qu(Ho().qc_1),function(n){return Xn(On(n),af)}(h.nd_1)),ef(new Qu(Oo().qc_1),Xn(On(h.od_1),ff)),ef(new Qu($o().qc_1),Xn(On(h.pd_1),sf)),0===l?Oo():Ro())}(n));else{var t=n.problemsReport;Sf(zf("report"),dc(),function(n,t){var r=function(n){for(var t=ui(),r=0,i=n.length;r<i;){var e=n[r];r=r+1|0;var u,o=js(e),f=t.v1(o);if(null==f){var s=Tr();t.h5(o,s),u=s}else u=f;u.d(e)}for(var c=t.o(),a=Lr(Ct(c,10)),h=c.f();h.g();){for(var l,_=h.h(),v=_.i1(),d=Lr(Ct(v,10)),g=v.f();g.g();){var w;w=Ps(g.h(),null,!0),d.d(w)}var b=d,p=Dn(_.i1());l=new ms(Ss(p,new $u(zs(Is(p)).ed(" ("+_.i1().k()+")").j5())),b),a.d(l)}var m=a;return new ss(new ms(new Rs("text"),m))}(t),i=function(n){for(var t=function(){var n=Tr();return new Cs(new ms(new Hs(yf().rd("Ungrouped"),!0),n),n,ui())}(),r=ui(),i=0,e=n.length;i<e;){var u=n[i];i=i+1|0;var o=xs(r,Hn(Tn(u.problemId.slice(),1))),f=Ps(u);null==o?t.ef_1.d(f):o.ef_1.d(f)}for(var s=r.w1(),c=Lr(Ct(s,10)),a=s.f();a.g();){var h;h=a.h().df_1,c.d(h)}var l=$n(c);return l.d(t.df_1),new ss(new ms(new Rs("text"),l))}(t),e=function(n){for(var t=Tr(),r=ui(),i=0,e=n.length;i<e;){var u=n[i];i=i+1|0;var o=u.locations;if(null==o||0===o.length)t.d(Ps(u));else{var f,s=u.locations;if(null==s)f=null;else{for(var c=Tr(),a=Oi(s);a.g();){var h=a.h();null!=h.path&&c.d(h)}f=c}if(null==f);else for(var l=f.f();l.g();){var _=l.h();Bs(r,ae(_.path),u,_)}var v,d=u.locations;if(null==d)v=null;else{for(var g=Tr(),w=Oi(d);w.g();){var b=w.h();null!=b.pluginId&&g.d(b)}v=g}if(null==v);else for(var p=v.f();p.g();){var m=p.h();Bs(r,ae(m.pluginId),u,m)}var k,q=u.locations;if(null==q)k=null;else{for(var y=Tr(),B=Oi(q);B.g();){var C=B.h();null!=C.taskPath&&y.d(C)}k=y}if(null==k);else for(var x=k.f();x.g();){var j=x.h();Bs(r,ae(j.taskPath),u,j)}}}var P=function(n,t){for(var r=n.w1(),i=Lr(Ct(r,10)),e=r.f();e.g();){var u;u=e.h().t3_1,i.d(u)}var o=i;return t.i()?o:function(n,t){var r=Lr(n.k());return r.m(n),r.d(t),r}(o,new ms(new Hs(yf().rd("no location"),!0),t))}(r,t);return new ss(new ms(new Rs("text"),P))}(t);return new Ys(yf().rd("Problems Report"),function(n,t){var r,i,e,u=n.description,o=null==u?null:dr(_f(u));return r=null==o?dr(yf().qd((i=t,e=n,function(n){n.ed(i.length+" problems have been reported during the execution");var t=e.buildName;null==t||(n.ed(" of build "),n.fd(t));var r=e.requestedTasks;return null==r||(n.ed(" for the following tasks:"),n.fd(r),hr()),hr()}))):o,r}(n,t),new wf("reporting problems",n.documentationLink),r,i,e,t.length,function(n,t,r){return ho(r)>0?Os():ho(n)>0?Fs():ho(t)>0?Ds():Fs()}(r,i,e))}(t,n.diagnostics))}}(),n}(void 0===this["configuration-cache-report"]?{}:this["configuration-cache-report"])}}[70](),{}))));
-//# sourceMappingURL=configuration-cache-report.js.map
-                </script>
-
-</body>
-</html>
diff --git a/android/gradle/wrapper/gradle-wrapper.properties b/android/gradle/wrapper/gradle-wrapper.properties
index 5e6b542..b56f45a 100644
--- a/android/gradle/wrapper/gradle-wrapper.properties
+++ b/android/gradle/wrapper/gradle-wrapper.properties
@@ -2,4 +2,5 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-8.4-all.zip
+# FIX: Using Gradle 8.3 to match Flutter 3.24.5 template (compatible with AGP 8.1.0)
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.3-all.zip
diff --git a/android/settings.gradle b/android/settings.gradle
index d2b72b8..2c412a9 100644
--- a/android/settings.gradle
+++ b/android/settings.gradle
@@ -1,3 +1,4 @@
+// FIX: Updated to match Flutter 3.24.5 template versions
 pluginManagement {
     def flutterSdkPath = {
         def properties = new Properties()
@@ -18,8 +19,9 @@ pluginManagement {
 
 plugins {
     id "dev.flutter.flutter-plugin-loader" version "1.0.0"
-    id "com.android.application" version "8.2.0" apply false
-    id "org.jetbrains.kotlin.android" version "1.9.22" apply false
+    // FIX: Using AGP 8.1.0 and Kotlin 1.8.22 to match Flutter 3.24.5 template
+    id "com.android.application" version "8.1.0" apply false
+    id "org.jetbrains.kotlin.android" version "1.8.22" apply false
 }
 
 include ":app"
diff --git a/ios/Podfile.lock b/ios/Podfile.lock
index 0b70f6a..589f483 100644
--- a/ios/Podfile.lock
+++ b/ios/Podfile.lock
@@ -6,9 +6,6 @@ PODS:
     - FlutterMacOS
   - audio_session (0.0.1):
     - Flutter
-  - connectivity_plus (0.0.1):
-    - Flutter
-    - ReachabilitySwift
   - DKImagePickerController/Core (4.3.9):
     - DKImagePickerController/ImageDataManager
     - DKImagePickerController/Resource
@@ -52,12 +49,11 @@ PODS:
   - path_provider_foundation (0.0.1):
     - Flutter
     - FlutterMacOS
-  - ReachabilitySwift (5.2.4)
+  - permission_handler_apple (9.3.0):
+    - Flutter
   - SDWebImage (5.21.5):
     - SDWebImage/Core (= 5.21.5)
   - SDWebImage/Core (5.21.5)
-  - share_plus (0.0.1):
-    - Flutter
   - shared_preferences_foundation (0.0.1):
     - Flutter
     - FlutterMacOS
@@ -108,13 +104,12 @@ DEPENDENCIES:
   - app_links (from `.symlinks/plugins/app_links/ios`)
   - audio_service (from `.symlinks/plugins/audio_service/darwin`)
   - audio_session (from `.symlinks/plugins/audio_session/ios`)
-  - connectivity_plus (from `.symlinks/plugins/connectivity_plus/ios`)
   - file_picker (from `.symlinks/plugins/file_picker/ios`)
   - Flutter (from `Flutter`)
   - image_picker_ios (from `.symlinks/plugins/image_picker_ios/ios`)
   - just_audio (from `.symlinks/plugins/just_audio/darwin`)
   - path_provider_foundation (from `.symlinks/plugins/path_provider_foundation/darwin`)
-  - share_plus (from `.symlinks/plugins/share_plus/ios`)
+  - permission_handler_apple (from `.symlinks/plugins/permission_handler_apple/ios`)
   - shared_preferences_foundation (from `.symlinks/plugins/shared_preferences_foundation/darwin`)
   - sqflite_darwin (from `.symlinks/plugins/sqflite_darwin/darwin`)
   - stripe_ios (from `.symlinks/plugins/stripe_ios/ios`)
@@ -124,7 +119,6 @@ SPEC REPOS:
   trunk:
     - DKImagePickerController
     - DKPhotoGallery
-    - ReachabilitySwift
     - SDWebImage
     - Stripe
     - StripeApplePay
@@ -143,8 +137,6 @@ EXTERNAL SOURCES:
     :path: ".symlinks/plugins/audio_service/darwin"
   audio_session:
     :path: ".symlinks/plugins/audio_session/ios"
-  connectivity_plus:
-    :path: ".symlinks/plugins/connectivity_plus/ios"
   file_picker:
     :path: ".symlinks/plugins/file_picker/ios"
   Flutter:
@@ -155,8 +147,8 @@ EXTERNAL SOURCES:
     :path: ".symlinks/plugins/just_audio/darwin"
   path_provider_foundation:
     :path: ".symlinks/plugins/path_provider_foundation/darwin"
-  share_plus:
-    :path: ".symlinks/plugins/share_plus/ios"
+  permission_handler_apple:
+    :path: ".symlinks/plugins/permission_handler_apple/ios"
   shared_preferences_foundation:
     :path: ".symlinks/plugins/shared_preferences_foundation/darwin"
   sqflite_darwin:
@@ -170,7 +162,6 @@ SPEC CHECKSUMS:
   app_links: c5161ac5ab5383ad046884568b4b91cb52df5d91
   audio_service: aa99a6ba2ae7565996015322b0bb024e1d25c6fd
   audio_session: 9bb7f6c970f21241b19f5a3658097ae459681ba0
-  connectivity_plus: 481668c94744c30c53b8895afb39159d1e619bdf
   DKImagePickerController: 946cec48c7873164274ecc4624d19e3da4c1ef3c
   DKPhotoGallery: b3834fecb755ee09a593d7c9e389d8b5d6deed60
   file_picker: 07c75322ede1d47ec9bb4ac82b27c94d3598251a
@@ -178,9 +169,8 @@ SPEC CHECKSUMS:
   image_picker_ios: 7fe1ff8e34c1790d6fff70a32484959f563a928a
   just_audio: 4e391f57b79cad2b0674030a00453ca5ce817eed
   path_provider_foundation: 080d55be775b7414fd5a5ef3ac137b97b097e564
-  ReachabilitySwift: 32793e867593cfc1177f5d16491e3a197d2fccda
+  permission_handler_apple: 4ed2196e43d0651e8ff7ca3483a069d469701f2d
   SDWebImage: e9c98383c7572d713c1a0d7dd2783b10599b9838
-  share_plus: de6030e33b4e106470e09322d87cf2a4258d2d1d
   shared_preferences_foundation: 9e1978ff2562383bd5676f64ec4e9aa8fa06a6f7
   sqflite_darwin: 20b2a3a3b70e43edae938624ce550a3cbf66a3d0
   Stripe: 9fec845645e39f371e6898926d096fd9c2feb5a5
diff --git a/ios/Runner.xcworkspace/contents.xcworkspacedata b/ios/Runner.xcworkspace/contents.xcworkspacedata
index 21a3cc1..8f8cf39 100644
--- a/ios/Runner.xcworkspace/contents.xcworkspacedata
+++ b/ios/Runner.xcworkspace/contents.xcworkspacedata
@@ -2,9 +2,12 @@
 <Workspace
    version = "1.0">
    <FileRef
-      location = "group:Runner.xcodeproj">
+      location = "group:\.xcodeproj">
    </FileRef>
    <FileRef
       location = "group:Pods/Pods.xcodeproj">
    </FileRef>
+   <FileRef
+      location = "group:Runner.xcodeproj">
+   </FileRef>
 </Workspace>
diff --git a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-1024x1024@1x.png b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-1024x1024@1x.png
index dc9ada4..ba15ffe 100644
Binary files a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-1024x1024@1x.png and b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-1024x1024@1x.png differ
diff --git a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-20x20@1x.png b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-20x20@1x.png
index 7353c41..ea17831 100644
Binary files a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-20x20@1x.png and b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-20x20@1x.png differ
diff --git a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-20x20@2x.png b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-20x20@2x.png
index 797d452..adeca17 100644
Binary files a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-20x20@2x.png and b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-20x20@2x.png differ
diff --git a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-20x20@3x.png b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-20x20@3x.png
index 6ed2d93..42bc184 100644
Binary files a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-20x20@3x.png and b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-20x20@3x.png differ
diff --git a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-29x29@1x.png b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-29x29@1x.png
index 4cd7b00..05a295e 100644
Binary files a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-29x29@1x.png and b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-29x29@1x.png differ
diff --git a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-29x29@2x.png b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-29x29@2x.png
index fe73094..d85632b 100644
Binary files a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-29x29@2x.png and b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-29x29@2x.png differ
diff --git a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-29x29@3x.png b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-29x29@3x.png
index 321773c..0a660e0 100644
Binary files a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-29x29@3x.png and b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-29x29@3x.png differ
diff --git a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-40x40@1x.png b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-40x40@1x.png
index 797d452..adeca17 100644
Binary files a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-40x40@1x.png and b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-40x40@1x.png differ
diff --git a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-40x40@2x.png b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-40x40@2x.png
index 502f463..5497f4e 100644
Binary files a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-40x40@2x.png and b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-40x40@2x.png differ
diff --git a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-40x40@3x.png b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-40x40@3x.png
index 0ec3034..fc4e77d 100644
Binary files a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-40x40@3x.png and b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-40x40@3x.png differ
diff --git a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-60x60@2x.png b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-60x60@2x.png
index 0ec3034..fc4e77d 100644
Binary files a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-60x60@2x.png and b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-60x60@2x.png differ
diff --git a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-60x60@3x.png b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-60x60@3x.png
index e9f5fea..3f239eb 100644
Binary files a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-60x60@3x.png and b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-60x60@3x.png differ
diff --git a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-76x76@1x.png b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-76x76@1x.png
index 84ac32a..c9d7025 100644
Binary files a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-76x76@1x.png and b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-76x76@1x.png differ
diff --git a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-76x76@2x.png b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-76x76@2x.png
index 8953cba..c7173cc 100644
Binary files a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-76x76@2x.png and b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-76x76@2x.png differ
diff --git a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-83.5x83.5@2x.png b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-83.5x83.5@2x.png
index 0467bf1..d0c61fd 100644
Binary files a/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-83.5x83.5@2x.png and b/ios/Runner/Assets.xcassets/AppIcon.appiconset/Icon-App-83.5x83.5@2x.png differ
diff --git a/ios/Runner/Info.plist b/ios/Runner/Info.plist
index 6eb6d81..22e109d 100644
--- a/ios/Runner/Info.plist
+++ b/ios/Runner/Info.plist
@@ -5,7 +5,7 @@
 	<key>CFBundleDevelopmentRegion</key>
 	<string>$(DEVELOPMENT_LANGUAGE)</string>
 	<key>CFBundleDisplayName</key>
-	<string>Myna</string>
+	<string>Parasto</string>
 	<key>CFBundleExecutable</key>
 	<string>$(EXECUTABLE_NAME)</string>
 	<key>CFBundleIdentifier</key>
@@ -52,12 +52,12 @@
 	</array>
 	<!-- Microphone Permission (for future narration features) -->
 	<key>NSMicrophoneUsageDescription</key>
-	<string>مینا برای ضبط صدا به میکروفون نیاز دارد</string>
+	<string>پرستو برای ضبط صدا به میکروفون نیاز دارد</string>
 	<!-- Photo Library Permission (for profile/cover images) -->
 	<key>NSPhotoLibraryUsageDescription</key>
-	<string>مینا برای انتخاب تصویر به گالری نیاز دارد</string>
+	<string>پرستو برای انتخاب تصویر به گالری نیاز دارد</string>
 	<!-- Camera Permission (for profile photos) -->
 	<key>NSCameraUsageDescription</key>
-	<string>مینا برای گرفتن عکس به دوربین نیاز دارد</string>
+	<string>پرستو برای گرفتن عکس به دوربین نیاز دارد</string>
 </dict>
 </plist>
diff --git a/lib/config/app_config.dart b/lib/config/app_config.dart
index 06b0b05..649fb7d 100644
--- a/lib/config/app_config.dart
+++ b/lib/config/app_config.dart
@@ -50,12 +50,12 @@ class AppConfig {
   // App Configuration
   static String get appName {
     _ensureLoaded();
-    return dotenv.env['APP_NAME'] ?? 'Myna';
+    return dotenv.env['APP_NAME'] ?? 'Parasto';
   }
 
   static String get appNameFa {
     _ensureLoaded();
-    return dotenv.env['APP_NAME_FA'] ?? 'مینا';
+    return dotenv.env['APP_NAME_FA'] ?? 'پرستو';
   }
 
   // Storage Buckets
diff --git a/lib/main.dart b/lib/main.dart
index f1ae57d..158be65 100644
--- a/lib/main.dart
+++ b/lib/main.dart
@@ -2,6 +2,7 @@ import 'package:flutter/material.dart';
 import 'package:flutter/foundation.dart' show kIsWeb;
 import 'package:flutter_riverpod/flutter_riverpod.dart';
 import 'package:supabase_flutter/supabase_flutter.dart';
+import 'package:shared_preferences/shared_preferences.dart';
 import 'package:myna/config/app_config.dart';
 import 'package:myna/config/env.dart';
 import 'package:myna/utils/app_logger.dart';
@@ -15,45 +16,71 @@ import 'package:myna/services/payment_service.dart';
 import 'package:myna/services/download_service.dart';
 import 'package:myna/providers/audio_provider.dart';
 import 'package:myna/providers/user_providers.dart';
+import 'package:myna/providers/app_mode_provider.dart';
 
 void main() async {
   WidgetsFlutterBinding.ensureInitialized();
 
-  // Load environment variables first
+  // Load environment variables first (required for other services)
   await AppConfig.load();
   AppLogger.i('Environment loaded');
 
-  // Initialize Supabase with config from environment
+  // Initialize Supabase with config from environment (required for other services)
   await Supabase.initialize(
     url: Env.supabaseUrl,
     anonKey: Env.supabaseAnonKey,
   );
   AppLogger.i('Supabase initialized');
 
-  // Initialize audio service for background playback (not supported on web)
+  // PERFORMANCE: Only await critical services before runApp
+  // Non-critical services init in background after app starts
+
+  // Audio service is critical for playback - must await
   if (!kIsWeb) {
-    try {
-      final audioHandler = await initAudioService();
-      setGlobalAudioHandler(audioHandler);
-      AppLogger.i('Audio service initialized');
-    } catch (e) {
-      AppLogger.e('Failed to initialize audio service', error: e);
-      // Continue without background audio - will use fallback
-    }
+    await _initAudioService();
+  }
 
-    // Initialize download service for offline playback
-    try {
-      await DownloadService().init();
-      AppLogger.i('Download service initialized');
-    } catch (e) {
-      AppLogger.e('Failed to initialize download service', error: e);
-    }
+  // Start app immediately - other services init in background
+  runApp(const ProviderScope(child: MynaApp()));
+
+  // PERFORMANCE: Initialize non-critical services AFTER runApp (background)
+  // This allows the UI to render while these services load
+  if (!kIsWeb) {
+    _initDownloadService(); // Downloads can wait
+  }
+  _initPaymentService(); // Payment init can happen in background
+}
+
+Future<void> _initAudioService() async {
+  AppLogger.audioNotif('STARTUP: _initAudioService() called from main()');
+  try {
+    final audioHandler = await initAudioService();
+    setGlobalAudioHandler(audioHandler);
+    AppLogger.audioNotif('STARTUP: AudioService initialized and handler set globally');
+    AppLogger.i('Audio service initialized');
+  } catch (e, st) {
+    AppLogger.audioNotif('STARTUP: AudioService initialization FAILED: $e');
+    AppLogger.e('Failed to initialize audio service', error: e, stackTrace: st);
+    // Continue without background audio - will use fallback
   }
+}
 
-  // Initialize payment service
-  await PaymentService().initialize();
+Future<void> _initDownloadService() async {
+  try {
+    await DownloadService().init();
+    AppLogger.i('Download service initialized');
+  } catch (e) {
+    AppLogger.e('Failed to initialize download service', error: e);
+  }
+}
 
-  runApp(const ProviderScope(child: MynaApp()));
+Future<void> _initPaymentService() async {
+  try {
+    await PaymentService().initialize();
+    AppLogger.i('Payment service initialized');
+  } catch (e) {
+    AppLogger.e('Failed to initialize payment service', error: e);
+  }
 }
 
 class MynaApp extends ConsumerStatefulWidget {
@@ -80,16 +107,26 @@ class _MynaAppState extends ConsumerState<MynaApp> {
 
       AppLogger.auth('Auth state changed: $event', userId: newUserId);
 
-      // Invalidate user providers when:
-      // 1. User signs out
-      // 2. User changes (different user signs in)
-      if (event == AuthChangeEvent.signedOut ||
-          (newUserId != null && _lastUserId != null && newUserId != _lastUserId)) {
-        AppLogger.i('User changed or signed out - invalidating providers');
+      // NOTE(Issue 5 fix): Invalidate user providers when:
+      // 1. User signs out - clear old user's data
+      // 2. User signs in - refresh to get fresh data for this user
+      // 3. User changes (different user signs in) - refresh for new user
+      // This fixes the issue where "Continue Listening" disappeared after
+      // logout/login because providers weren't refreshed on sign-in.
+      if (event == AuthChangeEvent.signedOut) {
+        AppLogger.i('User signed out - invalidating providers');
+        invalidateUserProviders(ref);
+        _lastUserId = null; // Clear last user ID on logout
+      } else if (event == AuthChangeEvent.signedIn && newUserId != null) {
+        AppLogger.i('User signed in - refreshing providers for user');
+        invalidateUserProviders(ref);
+        _lastUserId = newUserId;
+      } else if (newUserId != null && _lastUserId != null && newUserId != _lastUserId) {
+        AppLogger.i('Different user detected - invalidating providers');
         invalidateUserProviders(ref);
+        _lastUserId = newUserId;
       }
 
-      _lastUserId = newUserId;
       _checkAuth();
     });
   }
@@ -125,15 +162,32 @@ class _MynaAppState extends ConsumerState<MynaApp> {
     try {
       final response = await Supabase.instance.client
           .from('profiles')
-          .select('role')
+          .select('role, is_disabled')
           .eq('id', user.id)
           .single();
 
-      AppLogger.auth('Role fetched', userId: user.id);
+      // NOTE(Issue 10 fix): Check if user is disabled by admin
+      // If so, sign them out and show an error message
+      final isDisabled = response['is_disabled'] == true;
+      if (isDisabled) {
+        AppLogger.w('User is disabled - signing out: userId=${user.id}');
+        await Supabase.instance.client.auth.signOut();
+        if (mounted) {
+          _showDisabledAccountDialog();
+        }
+        return;
+      }
+
+      final newRole = response['role'] as String?;
+      AppLogger.auth('Role fetched: $newRole', userId: user.id);
+
+      // NOTE(Issue 7 fix): Check if user's role was upgraded
+      // and show a notification dialog if so
+      await _checkRoleUpgrade(user.id, newRole);
 
       setState(() {
         _isLoggedIn = true;
-        _role = response['role'] as String?;
+        _role = newRole;
         _isLoading = false;
       });
     } catch (e) {
@@ -145,6 +199,118 @@ class _MynaAppState extends ConsumerState<MynaApp> {
       });
     }
   }
+
+  /// NOTE(Issue 7 fix): Check if user's role was upgraded and show notification.
+  /// Persists last known role per user in SharedPreferences.
+  Future<void> _checkRoleUpgrade(String userId, String? newRole) async {
+    if (newRole == null) return;
+
+    try {
+      final prefs = await SharedPreferences.getInstance();
+      final roleKey = 'last_role_$userId';
+      final lastRole = prefs.getString(roleKey);
+
+      // Save current role for next time
+      await prefs.setString(roleKey, newRole);
+
+      // Check if role was upgraded from listener to narrator
+      if (lastRole == 'listener' && newRole == 'narrator') {
+        AppLogger.i('Role upgrade detected: listener -> narrator');
+
+        // Show dialog after a short delay to ensure the app is ready
+        Future.delayed(const Duration(milliseconds: 500), () {
+          if (mounted) {
+            _showRoleUpgradeDialog();
+          }
+        });
+      }
+    } catch (e) {
+      AppLogger.e('Error checking role upgrade', error: e);
+    }
+  }
+
+  /// NOTE(Issue 10 fix): Show dialog when user account is disabled
+  void _showDisabledAccountDialog() {
+    showDialog<void>(
+      context: context,
+      barrierDismissible: false,
+      builder: (context) => Directionality(
+        textDirection: TextDirection.rtl,
+        child: AlertDialog(
+          backgroundColor: AppColors.surface,
+          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
+          title: const Row(
+            children: [
+              Icon(Icons.block, color: AppColors.error, size: 28),
+              SizedBox(width: 12),
+              Expanded(
+                child: Text(
+                  'حساب غیرفعال',
+                  style: TextStyle(color: AppColors.textPrimary, fontWeight: FontWeight.bold),
+                ),
+              ),
+            ],
+          ),
+          content: const Text(
+            'حساب کاربری شما غیرفعال شده است.\n\n'
+            'برای اطلاعات بیشتر با پشتیبانی تماس بگیرید.',
+            style: TextStyle(color: AppColors.textSecondary, height: 1.5),
+          ),
+          actions: [
+            TextButton(
+              onPressed: () => Navigator.pop(context),
+              child: const Text(
+                'متوجه شدم',
+                style: TextStyle(color: AppColors.primary, fontWeight: FontWeight.w600),
+              ),
+            ),
+          ],
+        ),
+      ),
+    );
+  }
+
+  /// Show a dialog notifying user of their role upgrade
+  void _showRoleUpgradeDialog() {
+    showDialog<void>(
+      context: context,
+      barrierDismissible: false,
+      builder: (context) => Directionality(
+        textDirection: TextDirection.rtl,
+        child: AlertDialog(
+          backgroundColor: AppColors.surface,
+          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
+          title: const Row(
+            children: [
+              Icon(Icons.celebration, color: AppColors.primary, size: 28),
+              SizedBox(width: 12),
+              Expanded(
+                child: Text(
+                  'تبریک! 🎉',
+                  style: TextStyle(color: AppColors.textPrimary, fontWeight: FontWeight.bold),
+                ),
+              ),
+            ],
+          ),
+          content: const Text(
+            'حساب شما به نقش راوی ارتقا یافت!\n\n'
+            'اکنون می‌توانید کتاب‌های صوتی خود را ثبت و مدیریت کنید. '
+            'برای دسترسی به پنل راوی، از منوی پروفایل گزینه «حالت راوی» را انتخاب کنید.',
+            style: TextStyle(color: AppColors.textSecondary, height: 1.5),
+          ),
+          actions: [
+            TextButton(
+              onPressed: () => Navigator.pop(context),
+              child: const Text(
+                'متوجه شدم',
+                style: TextStyle(color: AppColors.primary, fontWeight: FontWeight.w600),
+              ),
+            ),
+          ],
+        ),
+      ),
+    );
+  }
   
   @override
   Widget build(BuildContext context) {
@@ -165,19 +331,27 @@ class _MynaAppState extends ConsumerState<MynaApp> {
         ),
       );
     }
-    
+
     if (!_isLoggedIn) {
       return const LoginScreen();
     }
-    
+
+    // Admin always sees AdminShell
     if (_role == 'admin') {
       return const AdminShell();
     }
-    
+
+    // Narrator users can switch between listener and narrator mode
     if (_role == 'narrator') {
-      return const NarratorMainShell();
+      final appMode = ref.watch(appModeProvider);
+      if (appMode == AppMode.narrator) {
+        return const NarratorMainShell();
+      }
+      // Narrator in listener mode sees MainShell
+      return const MainShell();
     }
-    
+
+    // Regular listeners always see MainShell
     return const MainShell();
   }
 }
\ No newline at end of file
diff --git a/lib/providers/audio_provider.dart b/lib/providers/audio_provider.dart
index 56650f0..7471940 100644
--- a/lib/providers/audio_provider.dart
+++ b/lib/providers/audio_provider.dart
@@ -3,11 +3,17 @@ import 'dart:io';
 import 'package:flutter/widgets.dart';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
 import 'package:just_audio/just_audio.dart';
+import 'package:shared_preferences/shared_preferences.dart';
 import 'package:supabase_flutter/supabase_flutter.dart';
 import 'package:myna/config/env.dart';
 import 'package:myna/utils/app_logger.dart';
 import 'package:myna/services/audio_handler.dart';
 import 'package:myna/services/download_service.dart';
+import 'package:myna/services/playlist_service.dart';
+import 'package:myna/services/notification_permission_service.dart';
+
+/// Sentinel value to distinguish between "not provided" and "explicitly null"
+const _sentinel = Object();
 
 /// Possible audio error types for user-facing messages
 enum AudioErrorType {
@@ -42,6 +48,10 @@ class AudioState {
   final Duration sleepTimerRemaining;
   // Ownership state - tracks whether user has purchased this audiobook
   final bool isOwned;
+  // Playlist queue state - for sequential playlist playback
+  final String? playlistId;
+  final List<PlaylistItem> playlistItems;
+  final int currentPlaylistIndex;
 
   const AudioState({
     this.audiobook,
@@ -58,16 +68,31 @@ class AudioState {
     this.sleepTimerMode = SleepTimerMode.off,
     this.sleepTimerRemaining = Duration.zero,
     this.isOwned = false,
+    this.playlistId,
+    this.playlistItems = const [],
+    this.currentPlaylistIndex = 0,
   });
 
   bool get hasAudio => audiobook != null;
   bool get hasError => errorType != AudioErrorType.none;
   bool get hasSleepTimer => sleepTimerMode != SleepTimerMode.off;
 
+  /// True if currently playing from a playlist queue
+  bool get isPlaylistActive => playlistId != null && playlistItems.isNotEmpty;
+
+  /// True if there's a next item in the playlist queue
+  bool get hasNextPlaylistItem =>
+      isPlaylistActive && currentPlaylistIndex < playlistItems.length - 1;
+
   /// Check if user can play a specific chapter
-  /// Returns true if user owns the audiobook OR if the chapter is a free preview
+  /// Returns true if:
+  /// - User owns the audiobook (isOwned), OR
+  /// - The audiobook is free (is_free == true), OR
+  /// - The chapter is a free preview (is_preview == true)
   bool canPlayChapter(int chapterIndex) {
     if (isOwned) return true;
+    // FREE BOOK: All chapters are playable without purchase
+    if (audiobook != null && audiobook!['is_free'] == true) return true;
     if (chapterIndex < 0 || chapterIndex >= chapters.length) return false;
     return chapters[chapterIndex]['is_preview'] == true;
   }
@@ -99,6 +124,9 @@ class AudioState {
     SleepTimerMode? sleepTimerMode,
     Duration? sleepTimerRemaining,
     bool? isOwned,
+    Object? playlistId = _sentinel,
+    List<PlaylistItem>? playlistItems,
+    int? currentPlaylistIndex,
   }) {
     return AudioState(
       audiobook: audiobook ?? this.audiobook,
@@ -115,6 +143,18 @@ class AudioState {
       sleepTimerMode: sleepTimerMode ?? this.sleepTimerMode,
       sleepTimerRemaining: sleepTimerRemaining ?? this.sleepTimerRemaining,
       isOwned: isOwned ?? this.isOwned,
+      playlistId: playlistId == _sentinel ? this.playlistId : playlistId as String?,
+      playlistItems: playlistItems ?? this.playlistItems,
+      currentPlaylistIndex: currentPlaylistIndex ?? this.currentPlaylistIndex,
+    );
+  }
+
+  /// Clear playlist queue state (e.g., when playing a single audiobook directly)
+  AudioState clearPlaylist() {
+    return copyWith(
+      playlistId: null,
+      playlistItems: const [],
+      currentPlaylistIndex: 0,
     );
   }
 
@@ -146,14 +186,46 @@ class AudioNotifier extends StateNotifier<AudioState> with WidgetsBindingObserve
   StreamSubscription<Duration?>? _durationSubscription;
   StreamSubscription<AuthState>? _authSubscription;
 
+  /// Flag to suspend position stream updates (used during payment to reduce CPU)
+  bool _positionUpdatesSuspended = false;
+
+  /// Request counter for cancellation pattern - allows newer play requests to cancel older ones
+  /// Instead of blocking new requests, we let them run and cancel in-flight older requests
+  int _currentPlayRequestId = 0;
+
+  /// OPTIMIZATION: Cached autoPlayNext setting to avoid SharedPreferences.getInstance() on every chapter complete.
+  /// Default is true. Updated when user changes the setting via SettingsScreen.
+  bool _cachedAutoPlayNext = true;
+
+  /// Cached SharedPreferences instance for faster access
+  SharedPreferences? _cachedPrefs;
+
+  /// Guard flag to prevent duplicate _onChapterComplete calls.
+  /// Both the stream listener and the audio_handler callback can trigger it.
+  bool _chapterCompleteInProgress = false;
+
   AudioNotifier() : super(const AudioState()) {
     // Use the global audio handler's player if available, otherwise create standalone
     _player = _globalAudioHandler?.player ?? AudioPlayer();
     _initPlayer();
     _initAuthListener();
+    _initAutoPlaySetting();
     WidgetsBinding.instance.addObserver(this);
   }
 
+  /// OPTIMIZATION: Load autoPlayNext setting once at init and cache it
+  Future<void> _initAutoPlaySetting() async {
+    _cachedPrefs = await SharedPreferences.getInstance();
+    _cachedAutoPlayNext = _cachedPrefs?.getBool('auto_play_next') ?? true;
+    AppLogger.audio('INIT: Cached autoPlayNext=$_cachedAutoPlayNext');
+  }
+
+  /// Call this when user changes the autoPlayNext setting to update the cache
+  void updateAutoPlayNextCache(bool value) {
+    _cachedAutoPlayNext = value;
+    AppLogger.audio('CACHE: autoPlayNext updated to $value');
+  }
+
   /// Listen for auth state changes and stop audio on logout
   void _initAuthListener() {
     _authSubscription = Supabase.instance.client.auth.onAuthStateChange.listen((data) {
@@ -177,19 +249,49 @@ class AudioNotifier extends StateNotifier<AudioState> with WidgetsBindingObserve
     }
   }
 
+  /// Throttle position updates to reduce CPU usage on large files
+  /// Only update state if position changed by more than 250ms
+  Duration _lastReportedPosition = Duration.zero;
+  static const _positionUpdateThreshold = Duration(milliseconds: 250);
+
   void _initPlayer() {
-    // Set up callbacks for audio handler (for lock screen controls)
+    // Set up callbacks for audio handler (for lock screen controls and background playback)
     if (_globalAudioHandler != null) {
-      _globalAudioHandler!.onProgressSave = () => _saveProgress();
+      _globalAudioHandler!.onProgressSave = _saveProgress;
       _globalAudioHandler!.onChapterComplete = (index) {
         if (index != state.currentChapterIndex && state.hasAudio) {
           goToChapter(index);
         }
       };
+      // BACKGROUND PLAYBACK FIX: Handle completion callback from audio_handler.
+      // This ensures chapter auto-next works even when app is minimized/in background.
+      // The audio_handler's completion detection runs in audio_service's background
+      // context, which is more reliable than Flutter's stream listeners when suspended.
+      _globalAudioHandler!.onPlaybackComplete = () {
+        // [AUTO_NEXT] Log when handler callback reaches audio_provider
+        AppLogger.audio('[AUTO_NEXT] CH_COMPLETE_HANDLER_RECEIVED: callback from audio_handler received in AudioNotifier');
+        _onChapterComplete();
+      };
     }
 
+    // OPTIMIZATION: Throttle position updates to reduce rebuilds on large files
+    // Only update state if position changed significantly (250ms) when playing
+    // Always update immediately when paused/stopped for accurate UI
     _positionSubscription = _player.positionStream.listen((pos) {
-      if (mounted) state = state.copyWith(position: pos);
+      if (!mounted || _positionUpdatesSuspended) return;
+
+      final diff = (pos - _lastReportedPosition).abs();
+
+      // When playing: throttle updates to reduce CPU usage
+      // When NOT playing: always update for accurate seek preview
+      final shouldUpdate = state.isPlaying
+          ? diff >= _positionUpdateThreshold
+          : true; // Always update when paused for responsive UI
+
+      if (shouldUpdate) {
+        _lastReportedPosition = pos;
+        state = state.copyWith(position: pos);
+      }
     });
 
     _durationSubscription = _player.durationStream.listen((dur) {
@@ -224,6 +326,8 @@ class AudioNotifier extends StateNotifier<AudioState> with WidgetsBindingObserve
 
       // Handle chapter completion
       if (processingState == ProcessingState.completed) {
+        // [AUTO_NEXT] Log when UI stream detects completion
+        AppLogger.audio('[AUTO_NEXT] CH_COMPLETE_UI_STREAM: processingState=completed detected in playerStateStream');
         _onChapterComplete();
       }
     });
@@ -244,11 +348,17 @@ class AudioNotifier extends StateNotifier<AudioState> with WidgetsBindingObserve
       },
     );
 
-    // Start periodic progress saving
-    _saveTimer = Timer.periodic(const Duration(seconds: 10), (_) => _saveProgress());
+    // Periodic progress save every 30 seconds while playing
+    // This ensures progress is saved even if user kills the app
+    _saveTimer = Timer.periodic(const Duration(seconds: 30), (_) {
+      if (state.isPlaying && state.hasAudio) {
+        _saveProgress();
+      }
+    });
   }
 
   /// Handle app lifecycle changes - save progress when app goes to background
+  /// and force refresh state when app comes back to foreground
   @override
   void didChangeAppLifecycleState(AppLifecycleState appState) {
     if (appState == AppLifecycleState.paused ||
@@ -259,9 +369,39 @@ class AudioNotifier extends StateNotifier<AudioState> with WidgetsBindingObserve
         AppLogger.audio('App lifecycle: $appState - saving progress');
         _saveProgress();
       }
+    } else if (appState == AppLifecycleState.resumed) {
+      // App is coming back to foreground - force refresh playback state
+      if (state.hasAudio) {
+        AppLogger.audio('App lifecycle: resumed - refreshing state');
+        _forceRefreshState();
+      }
     }
   }
 
+  /// Force refresh the playback state from the player
+  /// Called when app resumes from background to sync UI with actual playback
+  void _forceRefreshState() {
+    if (!mounted) return;
+
+    // Get current actual values from player
+    final currentPosition = _player.position;
+    final currentDuration = _player.duration ?? Duration.zero;
+    final isPlaying = _player.playing;
+    final processingState = _player.processingState;
+
+    // Force update last reported position to allow immediate refresh
+    _lastReportedPosition = currentPosition;
+
+    // Update state with all current values
+    state = state.copyWith(
+      position: currentPosition,
+      duration: currentDuration,
+      isPlaying: isPlaying,
+      isLoading: processingState == ProcessingState.loading,
+      isBuffering: processingState == ProcessingState.buffering,
+    );
+  }
+
   /// Get the audio source - prefers local file if downloaded, otherwise remote URL
   /// Returns a record with the source URL/path and whether it's local
   (String? source, bool isLocal) _getAudioSourceWithType(Map<String, dynamic> chapter, int audiobookId) {
@@ -318,6 +458,17 @@ class AudioNotifier extends StateNotifier<AudioState> with WidgetsBindingObserve
     }
   }
 
+  /// Suspend position stream updates to reduce CPU usage during payment
+  /// Call this before presenting the Stripe payment sheet
+  void suspendPositionUpdates() {
+    _positionUpdatesSuspended = true;
+  }
+
+  /// Resume position stream updates after payment completes
+  void resumePositionUpdates() {
+    _positionUpdatesSuspended = false;
+  }
+
   /// Load existing listen time from database for accumulation
   Future<void> _loadExistingListenTime(int audiobookId) async {
     try {
@@ -366,8 +517,74 @@ class AudioNotifier extends StateNotifier<AudioState> with WidgetsBindingObserve
     int? seekTo,
     bool? isOwned,
   }) async {
+    final audiobookId = audiobook['id'];
+    final audiobookTitle = audiobook['title_fa'] ?? audiobook['title'] ?? 'unknown';
+    final isFree = audiobook['is_free'] == true;
+
+    AppLogger.audioNotif('PLAY: play() ENTRY - '
+        'audiobookId=$audiobookId, title="$audiobookTitle", '
+        'chapterIndex=$chapterIndex, totalChapters=${chapters.length}, '
+        'isOwned=$isOwned, isFree=$isFree');
+
+    // ANDROID 13+ FIX: Request notification permission before starting playback.
+    // Without this, the media notification won't appear in the notification shade.
+    if (Platform.isAndroid) {
+      AppLogger.audioNotif('PLAY: Android detected - checking notification permission');
+      final permissionGranted = await NotificationPermissionService().ensureNotificationPermission();
+      if (!permissionGranted) {
+        AppLogger.audioNotif('PLAY: WARNING - Notification permission NOT granted, media controls may not appear');
+        AppLogger.w('PLAYER: Notification permission not granted - media controls may not appear');
+        // Continue anyway - audio will still play, just without system notification
+      } else {
+        AppLogger.audioNotif('PLAY: Notification permission granted');
+      }
+
+      // Log diagnostics right before first playback to capture channel state
+      await NotificationPermissionService().logNotificationDiagnostics('PLAYBACK');
+    }
+
+    // Increment request ID - this cancels any in-flight play operations
+    // Using cancellation pattern instead of blocking: new requests always proceed,
+    // and older in-flight requests check their ID and abort if superseded
+    _currentPlayRequestId++;
+    final thisRequestId = _currentPlayRequestId;
+
+    final chapterId = chapters.isNotEmpty && chapterIndex < chapters.length
+        ? chapters[chapterIndex]['id']
+        : null;
+    AppLogger.audio(
+      'PLAYER: play() called - requestId=$thisRequestId, audiobookId=${audiobook['id']}, '
+      'chapterIndex=$chapterIndex, chapterId=$chapterId',
+    );
+
+    await _playInternal(
+      audiobook: audiobook,
+      chapters: chapters,
+      chapterIndex: chapterIndex,
+      seekTo: seekTo,
+      isOwned: isOwned,
+      requestId: thisRequestId,
+    );
+  }
+
+  /// Internal play method with cancellation support
+  /// The requestId parameter allows newer requests to cancel this one mid-flight
+  Future<void> _playInternal({
+    required Map<String, dynamic> audiobook,
+    required List<Map<String, dynamic>> chapters,
+    int chapterIndex = 0,
+    int? seekTo,
+    bool? isOwned,
+    required int requestId,
+  }) async {
+    // Helper to check if this request has been superseded by a newer one
+    bool isCancelled() => _currentPlayRequestId != requestId;
+
+    AppLogger.audioNotif('PLAY_INTERNAL: [req=$requestId] Starting playback process');
+
     if (chapters.isEmpty) {
-      AppLogger.w('No chapters to play');
+      AppLogger.audioNotif('PLAY_INTERNAL: [req=$requestId] FAILED - no chapters');
+      AppLogger.w('PLAYER: No chapters to play');
       state = state.copyWith(
         errorType: AudioErrorType.audioNotFound,
         errorMessage: 'هیچ فصلی برای پخش وجود ندارد',
@@ -377,19 +594,29 @@ class AudioNotifier extends StateNotifier<AudioState> with WidgetsBindingObserve
 
     // Validate chapter index
     if (chapterIndex < 0 || chapterIndex >= chapters.length) {
-      AppLogger.e('Invalid chapter index: $chapterIndex');
+      AppLogger.audioNotif('PLAY_INTERNAL: [req=$requestId] Invalid chapter index $chapterIndex, resetting to 0');
+      AppLogger.e('PLAYER: Invalid chapter index: $chapterIndex');
       chapterIndex = 0;
     }
 
     // Determine ownership: use provided value, or preserve current state if same audiobook
-    final ownershipStatus = isOwned ??
-        (audiobook['id'] == state.audiobook?['id'] ? state.isOwned : false);
+    final isSameAudiobook = audiobook['id'] == state.audiobook?['id'];
+    final ownershipStatus = isOwned ?? (isSameAudiobook ? state.isOwned : false);
 
     // Check if user can play this chapter
     final chapter = chapters[chapterIndex];
     final chapterIsPreview = chapter['is_preview'] == true;
-    if (!ownershipStatus && !chapterIsPreview) {
-      AppLogger.w('Access denied: chapter is locked');
+    final isFreeAudiobook = audiobook['is_free'] == true;
+
+    // Log entitlement check for debugging
+    AppLogger.audioNotif('ENTITLEMENT: [req=$requestId] Check - '
+        'isOwned=$ownershipStatus, isFree=$isFreeAudiobook, isPreview=$chapterIsPreview, '
+        'canPlay=${ownershipStatus || chapterIsPreview || isFreeAudiobook}');
+
+    // Allow playback if: owned, OR preview chapter, OR free audiobook
+    if (!ownershipStatus && !chapterIsPreview && !isFreeAudiobook) {
+      AppLogger.audioNotif('PLAY_INTERNAL: [req=$requestId] BLOCKED - chapter locked (not owned, not free, not preview)');
+      AppLogger.w('PLAYER: Access denied - chapter is locked');
       state = state.copyWith(
         errorType: AudioErrorType.unauthorized,
         errorMessage: 'برای گوش دادن به این فصل، کتاب را خریداری کنید',
@@ -397,9 +624,22 @@ class AudioNotifier extends StateNotifier<AudioState> with WidgetsBindingObserve
       return;
     }
 
-    // Load existing listen time from database for this audiobook
-    await _loadExistingListenTime(audiobook['id'] as int);
+    // OPTIMIZATION: Skip database query during chapter transitions within the same audiobook.
+    // Listen time is already loaded when the audiobook started playing.
+    // This saves ~50-150ms per chapter transition.
+    if (!isSameAudiobook) {
+      await _loadExistingListenTime(audiobook['id'] as int);
+    } else {
+      AppLogger.audio('PLAYER: [req=$requestId] Skipping listen time load (same audiobook)');
+    }
 
+    // Check if cancelled after async operation
+    if (isCancelled()) {
+      AppLogger.audio('PLAYER: Request $requestId cancelled (newer request exists)');
+      return;
+    }
+
+    // Set loading state BEFORE stopping player to show immediate feedback
     state = state.copyWith(
       audiobook: audiobook,
       chapters: chapters,
@@ -415,23 +655,34 @@ class AudioNotifier extends StateNotifier<AudioState> with WidgetsBindingObserve
       final audiobookId = audiobook['id'] as int;
       final (audioSource, isLocal) = _getAudioSourceWithType(chapter, audiobookId);
 
-      AppLogger.audio('Playing chapter', chapter: chapter['title_fa'] as String?);
+      AppLogger.audio(
+        'PLAYER: [req=$requestId] Loading chapter - title="${chapter['title_fa']}", '
+        'isLocal=$isLocal',
+      );
 
       if (audioSource == null || audioSource.isEmpty) {
-        AppLogger.e('No audio source found for chapter');
-        state = state.copyWith(
-          isLoading: false,
-          errorType: AudioErrorType.audioNotFound,
-          errorMessage: 'فایل صوتی این فصل موجود نیست',
-        );
+        AppLogger.e('PLAYER: No audio source found for chapter');
+        if (!isCancelled()) {
+          state = state.copyWith(
+            isLoading: false,
+            errorType: AudioErrorType.audioNotFound,
+            errorMessage: 'فایل صوتی این فصل موجود نیست',
+          );
+        }
         return;
       }
 
-      // If using remote URL, check if we're offline
-      if (!isLocal) {
+      // OPTIMIZATION: Skip offline check during chapter transitions within the same audiobook.
+      // If we're already streaming, the connection is working. The player will fail naturally
+      // if the network drops mid-stream. This saves ~100-300ms per chapter transition.
+      if (!isLocal && !isSameAudiobook) {
         final offline = await _isOffline();
+        if (isCancelled()) {
+          AppLogger.audio('PLAYER: Request $requestId cancelled after offline check');
+          return;
+        }
         if (offline) {
-          AppLogger.e('Offline and chapter not downloaded');
+          AppLogger.e('PLAYER: Offline and chapter not downloaded');
           state = state.copyWith(
             isLoading: false,
             errorType: AudioErrorType.networkError,
@@ -439,10 +690,27 @@ class AudioNotifier extends StateNotifier<AudioState> with WidgetsBindingObserve
           );
           return;
         }
+      } else if (!isLocal && isSameAudiobook) {
+        AppLogger.audio('PLAYER: [req=$requestId] Skipping offline check (same audiobook, already streaming)');
+      }
+
+      // CRITICAL: Stop the player before setting a new source
+      // This prevents PlayerInterruptedException when switching chapters
+      AppLogger.audio('PLAYER: [req=$requestId] Stopping current playback');
+      await _player.stop();
+
+      // Check cancellation after stop
+      if (isCancelled()) {
+        AppLogger.audio('PLAYER: Request $requestId cancelled after stop');
+        return;
       }
 
       // Use audio handler if available (enables lock screen controls)
       if (_globalAudioHandler != null) {
+        AppLogger.audioNotif('PLAY_INTERNAL: [req=$requestId] Calling _globalAudioHandler.playChapter() - '
+            'this will set MediaItem and trigger notification');
+        AppLogger.audio('PLAYER: [req=$requestId] Using audio handler to play chapter');
+
         await _globalAudioHandler!.playChapter(
           audiobook: audiobook,
           chapters: chapters,
@@ -451,14 +719,34 @@ class AudioNotifier extends StateNotifier<AudioState> with WidgetsBindingObserve
           startPosition: seekTo != null ? Duration(seconds: seekTo) : null,
           isLocalFile: isLocal,
         );
+
+        AppLogger.audioNotif('PLAY_INTERNAL: [req=$requestId] _globalAudioHandler.playChapter() returned successfully');
+
+        // Check cancellation after playChapter
+        if (isCancelled()) {
+          AppLogger.audioNotif('PLAY_INTERNAL: [req=$requestId] Request cancelled after playChapter');
+          AppLogger.audio('PLAYER: Request $requestId cancelled after playChapter - stopping');
+          await _player.stop();
+          return;
+        }
+
         await _globalAudioHandler!.setSpeed(state.playbackSpeed);
       } else {
+        AppLogger.audioNotif('PLAY_INTERNAL: [req=$requestId] WARNING - _globalAudioHandler is null, using direct player (no notification!)');
         // Fallback: direct player control
+        AppLogger.audio('PLAYER: [req=$requestId] Using direct player control');
         if (isLocal) {
           await _player.setFilePath(audioSource);
         } else {
           await _player.setUrl(audioSource);
         }
+
+        if (isCancelled()) {
+          AppLogger.audio('PLAYER: Request $requestId cancelled after setUrl - stopping');
+          await _player.stop();
+          return;
+        }
+
         await _player.setSpeed(state.playbackSpeed);
         if (seekTo != null && seekTo > 0) {
           final maxSeek = state.duration.inSeconds;
@@ -467,51 +755,73 @@ class AudioNotifier extends StateNotifier<AudioState> with WidgetsBindingObserve
         }
         await _player.play();
       }
+
+      // Final cancellation check before updating state
+      if (isCancelled()) {
+        AppLogger.audioNotif('PLAY_INTERNAL: [req=$requestId] Request cancelled at final check');
+        AppLogger.audio('PLAYER: Request $requestId cancelled at end - stopping');
+        await _player.stop();
+        return;
+      }
+
       state = state.copyWith(isLoading: false);
-      AppLogger.audio('Playback started${isLocal ? " (offline)" : ""}');
-    } on PlayerException catch (e) {
-      AppLogger.e('PlayerException', error: e);
-      state = state.copyWith(
-        isLoading: false,
-        errorType: AudioErrorType.playbackFailed,
-        errorMessage: 'خطا در بارگذاری صدا. لطفاً دوباره تلاش کنید',
-      );
-    } on PlayerInterruptedException catch (e) {
-      AppLogger.e('PlayerInterruptedException', error: e);
-      state = state.copyWith(
-        isLoading: false,
-        errorType: AudioErrorType.playbackFailed,
-        errorMessage: 'پخش قطع شد. لطفاً دوباره تلاش کنید',
-      );
-    } catch (e) {
-      AppLogger.e('Error playing audio', error: e);
-
-      // Determine error type based on exception
-      AudioErrorType errorType = AudioErrorType.playbackFailed;
-      String errorMessage = 'خطا در پخش صدا. لطفاً دوباره تلاش کنید';
-
-      final errorString = e.toString().toLowerCase();
-      if (errorString.contains('network') ||
-          errorString.contains('connection') ||
-          errorString.contains('socket')) {
-        errorType = AudioErrorType.networkError;
-        errorMessage = 'اتصال به اینترنت برقرار نیست';
-      } else if (errorString.contains('404') ||
-                 errorString.contains('not found')) {
-        errorType = AudioErrorType.audioNotFound;
-        errorMessage = 'فایل صوتی یافت نشد';
-      } else if (errorString.contains('403') ||
-                 errorString.contains('unauthorized') ||
-                 errorString.contains('forbidden')) {
-        errorType = AudioErrorType.unauthorized;
-        errorMessage = 'شما اجازه دسترسی به این محتوا را ندارید';
+      AppLogger.audioNotif('PLAY_INTERNAL: [req=$requestId] SUCCESS - playback started, '
+          'isPlaying=${_player.playing}, processingState=${_player.processingState}');
+      AppLogger.audio('PLAYER: [req=$requestId] Playback started successfully${isLocal ? " (offline)" : ""}');
+    } on PlayerException catch (e, st) {
+      AppLogger.audioNotif('PLAY_INTERNAL: [req=$requestId] PlayerException: $e');
+      AppLogger.e('PLAYER ERROR: PlayerException', error: e, stackTrace: st);
+      if (!isCancelled()) {
+        state = state.copyWith(
+          isLoading: false,
+          errorType: AudioErrorType.playbackFailed,
+          errorMessage: 'خطا در بارگذاری صدا. لطفاً دوباره تلاش کنید',
+        );
       }
+    } on PlayerInterruptedException catch (e, st) {
+      // This can happen legitimately when a newer request cancels this one
+      // Only show error if this request wasn't cancelled
+      if (!isCancelled()) {
+        AppLogger.e('PLAYER ERROR: PlayerInterruptedException', error: e, stackTrace: st);
+        state = state.copyWith(
+          isLoading: false,
+          errorType: AudioErrorType.playbackFailed,
+          errorMessage: 'پخش قطع شد. لطفاً دوباره تلاش کنید',
+        );
+      } else {
+        AppLogger.audio('PLAYER: PlayerInterruptedException for cancelled request $requestId (expected)');
+      }
+    } catch (e, st) {
+      if (!isCancelled()) {
+        AppLogger.e('PLAYER ERROR: Unexpected error', error: e, stackTrace: st);
+
+        // Determine error type based on exception
+        AudioErrorType errorType = AudioErrorType.playbackFailed;
+        String errorMessage = 'خطا در پخش صدا. لطفاً دوباره تلاش کنید';
+
+        final errorString = e.toString().toLowerCase();
+        if (errorString.contains('network') ||
+            errorString.contains('connection') ||
+            errorString.contains('socket')) {
+          errorType = AudioErrorType.networkError;
+          errorMessage = 'اتصال به اینترنت برقرار نیست';
+        } else if (errorString.contains('404') ||
+                   errorString.contains('not found')) {
+          errorType = AudioErrorType.audioNotFound;
+          errorMessage = 'فایل صوتی یافت نشد';
+        } else if (errorString.contains('403') ||
+                   errorString.contains('unauthorized') ||
+                   errorString.contains('forbidden')) {
+          errorType = AudioErrorType.unauthorized;
+          errorMessage = 'شما اجازه دسترسی به این محتوا را ندارید';
+        }
 
-      state = state.copyWith(
-        isLoading: false,
-        errorType: errorType,
-        errorMessage: errorMessage,
-      );
+        state = state.copyWith(
+          isLoading: false,
+          errorType: errorType,
+          errorMessage: errorMessage,
+        );
+      }
     }
   }
 
@@ -521,19 +831,32 @@ class AudioNotifier extends StateNotifier<AudioState> with WidgetsBindingObserve
       return;
     }
 
-    AppLogger.audio(state.isPlaying ? 'Pausing' : 'Resuming');
-    if (state.isPlaying) {
-      if (_globalAudioHandler != null) {
-        await _globalAudioHandler!.pause();
+    final wasPlaying = state.isPlaying;
+    AppLogger.audio(wasPlaying ? 'Pausing' : 'Resuming');
+
+    // Optimistically update UI immediately for responsive feel
+    state = state.copyWith(isPlaying: !wasPlaying);
+
+    try {
+      if (wasPlaying) {
+        if (_globalAudioHandler != null) {
+          await _globalAudioHandler!.pause();
+        } else {
+          await _player.pause();
+        }
+        _saveProgress();
       } else {
-        await _player.pause();
+        if (_globalAudioHandler != null) {
+          await _globalAudioHandler!.play();
+        } else {
+          await _player.play();
+        }
       }
-      _saveProgress();
-    } else {
-      if (_globalAudioHandler != null) {
-        await _globalAudioHandler!.play();
-      } else {
-        await _player.play();
+    } catch (e) {
+      // Revert optimistic update on error
+      AppLogger.e('Error toggling play/pause', error: e);
+      if (mounted) {
+        state = state.copyWith(isPlaying: wasPlaying);
       }
     }
   }
@@ -544,6 +867,10 @@ class AudioNotifier extends StateNotifier<AudioState> with WidgetsBindingObserve
     final clampedPosition = Duration(
       milliseconds: position.inMilliseconds.clamp(0, maxDuration.inMilliseconds),
     );
+    // Immediately update state for responsive UI
+    _lastReportedPosition = clampedPosition;
+    state = state.copyWith(position: clampedPosition);
+
     if (_globalAudioHandler != null) {
       await _globalAudioHandler!.seek(clampedPosition);
     } else {
@@ -579,6 +906,7 @@ class AudioNotifier extends StateNotifier<AudioState> with WidgetsBindingObserve
         audiobook: state.audiobook!,
         chapters: state.chapters,
         chapterIndex: state.currentChapterIndex - 1,
+        isOwned: state.isOwned, // Preserve ownership state across chapter switches
       );
     }
   }
@@ -592,6 +920,7 @@ class AudioNotifier extends StateNotifier<AudioState> with WidgetsBindingObserve
           audiobook: state.audiobook!,
           chapters: state.chapters,
           chapterIndex: nextIndex,
+          isOwned: state.isOwned, // Preserve ownership state across chapter switches
         );
         return true;
       } else {
@@ -608,22 +937,52 @@ class AudioNotifier extends StateNotifier<AudioState> with WidgetsBindingObserve
   }
 
   Future<void> goToChapter(int chapterIndex) async {
-    if (chapterIndex >= 0 && chapterIndex < state.chapters.length) {
-      if (state.canPlayChapter(chapterIndex)) {
-        await play(
-          audiobook: state.audiobook!,
-          chapters: state.chapters,
-          chapterIndex: chapterIndex,
-        );
-      } else {
-        // Chapter is locked
-        AppLogger.w('Chapter $chapterIndex is locked');
-        state = state.copyWith(
-          errorType: AudioErrorType.unauthorized,
-          errorMessage: 'این فصل قفل است. برای گوش دادن، کتاب را خریداری کنید',
-        );
-      }
+    AppLogger.audio('PLAYER: goToChapter($chapterIndex) called, currentState: isPlaying=${state.isPlaying}, hasError=${state.hasError}');
+
+    // Validate state
+    if (state.audiobook == null) {
+      AppLogger.e('PLAYER: Cannot switch chapter - no audiobook loaded');
+      return;
+    }
+
+    if (chapterIndex < 0 || chapterIndex >= state.chapters.length) {
+      AppLogger.e('PLAYER: Invalid chapter index $chapterIndex (chapters: ${state.chapters.length})');
+      return;
+    }
+
+    if (!state.canPlayChapter(chapterIndex)) {
+      // Chapter is locked
+      AppLogger.w('PLAYER: Chapter $chapterIndex is locked');
+      state = state.copyWith(
+        errorType: AudioErrorType.unauthorized,
+        errorMessage: 'این فصل قفل است. برای گوش دادن، کتاب را خریداری کنید',
+      );
+      return;
+    }
+
+    // FIX: Clear any existing error state before switching chapters
+    // This prevents "خطایی در پخش رخ داد" from showing during valid transitions
+    if (state.hasError) {
+      AppLogger.audio('PLAYER: Clearing error state before chapter switch');
+      state = state.clearError();
     }
+
+    // Save progress before switching chapters
+    if (state.hasAudio) {
+      AppLogger.audio('PLAYER: Saving progress before chapter switch');
+      _saveProgress();
+    }
+
+    // FIX: Log full chapter details for debugging
+    final chapter = state.chapters[chapterIndex];
+    AppLogger.audio('PLAYER: Switching to chapter $chapterIndex - "${chapter['title_fa']}"');
+
+    await play(
+      audiobook: state.audiobook!,
+      chapters: state.chapters,
+      chapterIndex: chapterIndex,
+      isOwned: state.isOwned, // Preserve ownership state across chapter switches
+    );
   }
 
   Future<void> setSpeed(double speed) async {
@@ -732,31 +1091,348 @@ class AudioNotifier extends StateNotifier<AudioState> with WidgetsBindingObserve
   }
 
   void _onChapterComplete() async {
+    // GUARD: Prevent duplicate calls from both stream listener and audio_handler callback.
+    // This can happen because processingStateStream.completed and onPlaybackComplete
+    // may both fire for the same completion event.
+    if (_chapterCompleteInProgress) {
+      AppLogger.audio('[AUTO_NEXT] CH_COMPLETE_UI: DUPLICATE CALL - ignoring');
+      return;
+    }
+    _chapterCompleteInProgress = true;
+
+    // CRITICAL: Capture all state values upfront BEFORE any async operations
+    // This prevents race conditions where state changes during await calls
+    final currentState = state;
+    final audiobookId = currentState.audiobook?['id'];
+    final chapterIndex = currentState.currentChapterIndex;
+    final chaptersCount = currentState.chapters.length;
+    final isPlaylistActive = currentState.isPlaylistActive;
+    final hasNextPlaylistItem = currentState.hasNextPlaylistItem;
+    final playlistIndex = currentState.currentPlaylistIndex;
+    final playlistItemsCount = currentState.playlistItems.length;
+    final sleepTimerMode = currentState.sleepTimerMode;
+    final hasNext = chapterIndex < chaptersCount - 1;
+
+    // [AUTO_NEXT] Comprehensive diagnostic log at entry
+    AppLogger.audio('[AUTO_NEXT] CH_COMPLETE_UI: ENTRY - '
+        'audiobookId=$audiobookId, chapterIndex=$chapterIndex, totalChapters=$chaptersCount, '
+        'hasNext=$hasNext, autoPlayNext=$_cachedAutoPlayNext, sleepTimerMode=$sleepTimerMode, '
+        'mounted=$mounted');
+
     // Check if "end of chapter" sleep timer is active
-    if (state.sleepTimerMode == SleepTimerMode.endOfChapter) {
-      AppLogger.audio('Chapter complete - sleep timer triggering');
+    if (sleepTimerMode == SleepTimerMode.endOfChapter) {
+      AppLogger.audio('[AUTO_NEXT] CH_COMPLETE_UI: SLEEP_TIMER - triggering end-of-chapter sleep');
+      _chapterCompleteInProgress = false;
       _onSleepTimerExpired();
       return;
     }
 
-    if (state.currentChapterIndex < state.chapters.length - 1) {
-      // Try to auto-play next chapter (will be blocked if locked)
-      final success = await nextChapter();
-      if (!success) {
-        // Next chapter is locked - save progress and stop
-        AppLogger.audio('Chapter complete - next chapter locked, stopping playback');
+    // OPTIMIZATION: Use cached autoPlayNext setting instead of await SharedPreferences.getInstance()
+    // This eliminates ~50-200ms delay on every chapter transition.
+    // The cache is updated when user changes the setting via SettingsScreen.
+    final autoPlayNext = _cachedAutoPlayNext;
+
+    AppLogger.audio('AUTOPLAY: Chapter $chapterIndex complete - autoPlayNext=$autoPlayNext (audiobook=$audiobookId)');
+
+    if (chapterIndex < chaptersCount - 1) {
+      if (autoPlayNext) {
+        // Auto-play is ON - try to play next chapter
+        AppLogger.audio('[AUTO_NEXT] CH_COMPLETE_UI: CALLING_NEXT - autoPlayNext=true, calling nextChapter()');
+        final success = await nextChapter();
+        AppLogger.audio('[AUTO_NEXT] CH_COMPLETE_UI: NEXT_RESULT - nextChapter() returned success=$success');
+        if (!success) {
+          // Next chapter is locked - save progress and stop
+          AppLogger.audio('[AUTO_NEXT] CH_COMPLETE_UI: NEXT_LOCKED - stopping playback');
+          _saveProgress();
+          if (_globalAudioHandler != null) {
+            await _globalAudioHandler!.pause();
+          }
+        }
+      } else {
+        // Auto-play is OFF - stop at end of chapter
+        AppLogger.audio('AUTOPLAY: Auto-play is OFF - stopping at end of chapter $chapterIndex');
         _saveProgress();
-        // Pause playback (audio already stopped because chapter ended)
         if (_globalAudioHandler != null) {
           await _globalAudioHandler!.pause();
         }
       }
     } else {
-      // Audiobook completed
+      // Last chapter of current audiobook completed
+      AppLogger.audio('AUTOPLAY: Last chapter complete - audiobook finished');
       _saveProgress(completed: true);
+
+      // DEBUG: Log all playlist state values for troubleshooting
+      // Using captured values to ensure consistency
+      AppLogger.audio('PLAYLIST_DEBUG: playlistId=${currentState.playlistId}, '
+          'itemsCount=$playlistItemsCount, '
+          'currentIndex=$playlistIndex, '
+          'isActive=$isPlaylistActive, '
+          'hasNext=$hasNextPlaylistItem, '
+          'autoPlayNext=$autoPlayNext');
+
+      // PLAYLIST AUTO-ADVANCE: If playing from a playlist, move to next item
+      // CRITICAL: Use captured values (isPlaylistActive, hasNextPlaylistItem)
+      // to avoid race conditions where state might change during async operations
+      if (isPlaylistActive && hasNextPlaylistItem && autoPlayNext) {
+        AppLogger.audio('PLAYLIST: Audiobook finished, advancing to next playlist item '
+            '(current=$playlistIndex, total=$playlistItemsCount)');
+        await _playNextPlaylistItem();
+      } else if (isPlaylistActive) {
+        AppLogger.audio('PLAYLIST: Playlist playback complete (no more items or auto-play off)');
+        // Clear playlist state when done
+        if (mounted) {
+          state = state.clearPlaylist();
+        }
+      }
     }
+
+    // Reset guard flag after completion (with small delay to debounce rapid events)
+    Future.delayed(const Duration(milliseconds: 100), () {
+      _chapterCompleteInProgress = false;
+    });
   }
 
+  // ============================================
+  // PLAYLIST PLAYBACK METHODS
+  // ============================================
+
+  /// Start playing a playlist from a specific index.
+  /// This loads the audiobook at that index and begins playback.
+  ///
+  /// [playlistId] - The playlist being played
+  /// [items] - Ordered list of playlist items
+  /// [startIndex] - Which item to start from (0-based)
+  Future<void> playFromPlaylist({
+    required String playlistId,
+    required List<PlaylistItem> items,
+    required int startIndex,
+  }) async {
+    if (items.isEmpty) {
+      AppLogger.w('PLAYLIST: Cannot play - empty playlist');
+      return;
+    }
+
+    if (startIndex < 0 || startIndex >= items.length) {
+      AppLogger.e('PLAYLIST: Invalid start index $startIndex for playlist with ${items.length} items');
+      startIndex = 0;
+    }
+
+    AppLogger.audio('PLAYLIST: Starting playlist $playlistId from index $startIndex (${items.length} items)');
+
+    // Set playlist state
+    state = state.copyWith(
+      playlistId: playlistId,
+      playlistItems: items,
+      currentPlaylistIndex: startIndex,
+    );
+
+    // DEBUG: Verify state was set correctly
+    AppLogger.audio('PLAYLIST_DEBUG: After state set - playlistId=${state.playlistId}, '
+        'itemsCount=${state.playlistItems.length}, currentIndex=${state.currentPlaylistIndex}');
+
+    // Load and play the first item
+    await _loadAndPlayPlaylistItem(startIndex);
+  }
+
+  /// Load and play a specific item from the current playlist.
+  Future<void> _loadAndPlayPlaylistItem(int playlistIndex) async {
+    if (!state.isPlaylistActive) {
+      AppLogger.e('PLAYLIST: No active playlist');
+      return;
+    }
+
+    if (playlistIndex < 0 || playlistIndex >= state.playlistItems.length) {
+      AppLogger.e('PLAYLIST: Invalid playlist index $playlistIndex');
+      return;
+    }
+
+    final item = state.playlistItems[playlistIndex];
+    final audiobookId = item.audiobookId;
+
+    AppLogger.audio('PLAYLIST: Loading item $playlistIndex - audiobook $audiobookId (${item.titleFa ?? "unknown"})');
+
+    // Update current index before loading
+    state = state.copyWith(currentPlaylistIndex: playlistIndex);
+
+    try {
+      // Fetch audiobook details and chapters from database
+      final supabase = Supabase.instance.client;
+
+      final results = await Future.wait([
+        supabase
+            .from('audiobooks')
+            .select('*, categories(name_fa), profiles!audiobooks_narrator_id_fkey(display_name, full_name)')
+            .eq('id', audiobookId)
+            .single(),
+        supabase
+            .from('chapters')
+            .select('*')
+            .eq('audiobook_id', audiobookId)
+            .order('chapter_index', ascending: true),
+      ]);
+
+      final audiobook = results[0] as Map<String, dynamic>;
+      final chapters = List<Map<String, dynamic>>.from(results[1] as List);
+
+      if (chapters.isEmpty) {
+        AppLogger.e('PLAYLIST: No chapters for audiobook $audiobookId');
+        state = state.copyWith(
+          errorType: AudioErrorType.audioNotFound,
+          errorMessage: 'هیچ فصلی برای پخش وجود ندارد',
+        );
+        return;
+      }
+
+      // Check ownership/entitlement for this audiobook
+      // NOTE(Issue 1.2 fix): Added robust entitlement check with logging
+      final user = supabase.auth.currentUser;
+      bool isOwned = false;
+      final isFree = audiobook['is_free'] == true;
+
+      AppLogger.audio('PLAYLIST_ENTITLEMENT: Checking access for audiobook $audiobookId - '
+          'isFree=$isFree, userId=${user?.id ?? "null"}');
+
+      if (user != null && !isFree) {
+        try {
+          // Query the entitlements table directly for reliability
+          // NOTE(Issue 1.2 fix): Using 'entitlements' table directly instead of view
+          // to avoid issues if the view doesn't exist yet
+          final entitlement = await supabase
+              .from('entitlements')
+              .select('id')
+              .eq('user_id', user.id)
+              .eq('audiobook_id', audiobookId)
+              .maybeSingle();
+          isOwned = entitlement != null;
+          AppLogger.audio('PLAYLIST_ENTITLEMENT: Result - isOwned=$isOwned');
+        } catch (e) {
+          // If entitlement check fails, log error but continue
+          // We'll treat it as "not owned" which is safer
+          AppLogger.e('PLAYLIST_ENTITLEMENT: Error checking entitlement', error: e);
+          isOwned = false;
+        }
+      } else if (isFree) {
+        AppLogger.audio('PLAYLIST_ENTITLEMENT: Book is free - skipping ownership check');
+      }
+
+      // Determine which chapter(s) to play based on playlist item type
+      final isSingleChapter = item.chapterIndex != null;
+      final startChapterIndex = item.chapterIndex ?? 0;
+
+      // For single chapter items, extract just that chapter
+      // This ensures when it completes, playlist auto-advance triggers
+      List<Map<String, dynamic>> chaptersToPlay;
+      int playFromIndex;
+
+      if (isSingleChapter) {
+        // Validate the chapter index exists
+        if (startChapterIndex < 0 || startChapterIndex >= chapters.length) {
+          AppLogger.e('PLAYLIST: Invalid chapter index $startChapterIndex for audiobook $audiobookId');
+          state = state.copyWith(
+            errorType: AudioErrorType.audioNotFound,
+            errorMessage: 'فصل مورد نظر یافت نشد',
+          );
+          return;
+        }
+        // Single chapter: pass only that chapter (so completion triggers playlist advance)
+        chaptersToPlay = [chapters[startChapterIndex]];
+        playFromIndex = 0;
+        AppLogger.audio('PLAYLIST: Single chapter mode - playing chapter $startChapterIndex');
+      } else {
+        // Whole book: play all chapters from the beginning
+        chaptersToPlay = chapters;
+        playFromIndex = 0;
+      }
+
+      // Check if the target chapter is playable
+      // NOTE(Issue 1.2 fix): Added detailed logging for playability check
+      final targetChapter = chaptersToPlay[playFromIndex];
+      final targetChapterPreview = targetChapter['is_preview'] == true;
+
+      AppLogger.audio('PLAYLIST_PLAYABILITY: audiobook=$audiobookId, isOwned=$isOwned, '
+          'isFree=$isFree, isPreview=$targetChapterPreview');
+
+      if (!isOwned && !isFree && !targetChapterPreview) {
+        AppLogger.w('PLAYLIST: Chapter is locked (not owned=$isOwned, not free=$isFree, not preview=$targetChapterPreview)');
+        state = state.copyWith(
+          errorType: AudioErrorType.unauthorized,
+          errorMessage: 'برای گوش دادن به این محتوا، آن را خریداری کنید',
+        );
+        // Do NOT auto-advance - let user see the error
+        return;
+      }
+
+      AppLogger.audio('PLAYLIST: Playing audiobook $audiobookId - '
+          '${isSingleChapter ? "single chapter $startChapterIndex" : "all ${chapters.length} chapters"} '
+          '(owned=$isOwned, free=$isFree)');
+
+      // DEBUG: Log state before calling play()
+      AppLogger.audio('PLAYLIST_DEBUG: Before play() - playlistId=${state.playlistId}, '
+          'itemsCount=${state.playlistItems.length}, currentIndex=${state.currentPlaylistIndex}');
+
+      // Play the audiobook/chapter using existing play() method
+      await play(
+        audiobook: audiobook,
+        chapters: chaptersToPlay,
+        chapterIndex: playFromIndex,
+        isOwned: isOwned || isFree,
+      );
+
+      // DEBUG: Log state after calling play()
+      AppLogger.audio('PLAYLIST_DEBUG: After play() - playlistId=${state.playlistId}, '
+          'itemsCount=${state.playlistItems.length}, currentIndex=${state.currentPlaylistIndex}');
+
+    } catch (e, st) {
+      AppLogger.e('PLAYLIST: Error loading audiobook $audiobookId', error: e, stackTrace: st);
+      state = state.copyWith(
+        isLoading: false,
+        errorType: AudioErrorType.playbackFailed,
+        errorMessage: 'خطا در بارگذاری محتوا',
+      );
+    }
+  }
+
+  /// Advance to the next item in the playlist.
+  Future<void> _playNextPlaylistItem() async {
+    if (!state.hasNextPlaylistItem) {
+      AppLogger.audio('PLAYLIST: No next item to play');
+      return;
+    }
+
+    final nextIndex = state.currentPlaylistIndex + 1;
+    AppLogger.audio('PLAYLIST: Advancing to next item at index $nextIndex');
+    await _loadAndPlayPlaylistItem(nextIndex);
+  }
+
+  /// Clear the playlist queue and stop playlist playback mode.
+  /// Does NOT stop the current audio - just clears the queue.
+  void clearPlaylistQueue() {
+    if (mounted) {
+      state = state.clearPlaylist();
+      AppLogger.audio('PLAYLIST: Queue cleared');
+    }
+  }
+
+  // ============================================
+  // PROGRESS CALCULATION SYSTEM
+  // ============================================
+  // Album-level completion is calculated as:
+  //   completion_percentage = (sum of listened seconds across all chapters)
+  //                           / (sum of chapter durations) * 100
+  //
+  // Key rules:
+  // - Each chapter's listened time is capped at its duration (prevents >100%)
+  // - Chapters with ≥95% listened count as 100% complete (completion threshold)
+  // - Overall percentage ≥98% is displayed as 100% (near-completion rounding)
+  // - is_completed=true only when explicitly completed (last chapter finishes)
+  // ============================================
+
+  /// Completion threshold: if a chapter is ≥95% listened, count as fully complete
+  static const double _chapterCompletionThreshold = 0.95;
+
+  /// Near-completion threshold: if album is ≥98% complete, round to 100%
+  static const double _albumNearCompletionThreshold = 0.98;
+
   Future<void> _saveProgress({bool completed = false}) async {
     if (state.audiobook == null) return;
 
@@ -771,42 +1447,88 @@ class AudioNotifier extends StateNotifier<AudioState> with WidgetsBindingObserve
       }
 
       final chapter = state.chapters[state.currentChapterIndex];
+      final chapterId = chapter['id'] as int?;
 
-      // Calculate total completed seconds
-      int completedSeconds = 0;
-      for (int i = 0; i < state.currentChapterIndex; i++) {
-        completedSeconds += (state.chapters[i]['duration_seconds'] as int? ?? 0);
+      // Safety check: chapter must have a valid ID
+      if (chapterId == null || chapterId <= 0) {
+        AppLogger.w('Cannot save progress: invalid chapter ID');
+        return;
       }
-      completedSeconds += state.position.inSeconds;
 
-      // Get total duration, with fallback calculation
+      // Get current chapter duration (from player or database)
+      final currentChapterDuration = (chapter['duration_seconds'] as int?) ??
+          state.duration.inSeconds;
+
+      // Cap current position at chapter duration (prevents drift beyond 100%)
+      final currentPositionCapped = state.position.inSeconds.clamp(0,
+          currentChapterDuration > 0 ? currentChapterDuration : state.position.inSeconds);
+
+      // Calculate total completed seconds across ALL chapters
+      // For previous chapters: if we've passed them, count as fully listened
+      // For current chapter: use actual capped position
+      int completedSeconds = 0;
       int totalDuration = 0;
-      final audiobookDuration = state.audiobook!['total_duration_seconds'];
-      if (audiobookDuration != null && (audiobookDuration as num).toInt() > 0) {
-        totalDuration = audiobookDuration.toInt();
-      } else {
-        // Calculate from chapters if not set on audiobook
-        for (final ch in state.chapters) {
-          totalDuration += (ch['duration_seconds'] as int? ?? 0);
+
+      for (int i = 0; i < state.chapters.length; i++) {
+        final chapterDuration = (state.chapters[i]['duration_seconds'] as int?) ?? 0;
+        totalDuration += chapterDuration;
+
+        if (i < state.currentChapterIndex) {
+          // Previous chapters: count as fully listened
+          completedSeconds += chapterDuration;
+        } else if (i == state.currentChapterIndex) {
+          // Current chapter: use actual position, capped at duration
+          // Apply completion threshold: if ≥95% through, count as complete
+          if (chapterDuration > 0) {
+            final chapterProgress = currentPositionCapped / chapterDuration;
+            if (chapterProgress >= _chapterCompletionThreshold) {
+              completedSeconds += chapterDuration; // Count as fully complete
+            } else {
+              completedSeconds += currentPositionCapped;
+            }
+          } else {
+            completedSeconds += currentPositionCapped;
+          }
         }
+        // Future chapters: add 0 (not listened yet)
       }
 
-      // Calculate percentage - if we don't know total duration yet, use 0%
-      // Don't default to 100% when duration is unknown
+      // Fallback: use audiobook's stored total duration if chapters don't have it
+      if (totalDuration == 0) {
+        final audiobookDuration = state.audiobook!['total_duration_seconds'];
+        if (audiobookDuration != null && (audiobookDuration as num).toInt() > 0) {
+          totalDuration = audiobookDuration.toInt();
+        }
+      }
+
+      // Calculate percentage
       int percentage = 0;
       if (totalDuration > 0) {
-        percentage = ((completedSeconds * 100) ~/ totalDuration).clamp(0, 100);
+        final rawPercentage = (completedSeconds * 100.0) / totalDuration;
+
+        // Apply near-completion rounding: if ≥98%, show as 100%
+        if (rawPercentage >= _albumNearCompletionThreshold * 100) {
+          percentage = 100;
+        } else {
+          percentage = rawPercentage.round().clamp(0, 100);
+        }
       } else if (completedSeconds > 0) {
-        // We have listened but don't know total - estimate based on current chapter
-        // Use current duration as rough estimate (assume we're partway through)
+        // Fallback: estimate based on current chapter only
         final currentDuration = state.duration.inSeconds;
         if (currentDuration > 0) {
-          // For single chapter or unknown total, use position within current chapter
           percentage = ((state.position.inSeconds * 100) ~/ currentDuration).clamp(0, 99);
         }
       }
+
+      // Force 100% if explicitly completed
       if (completed) percentage = 100;
 
+      // Debug logging for progress tracking
+      AppLogger.d('PROGRESS_SAVE: audiobookId=${state.audiobook!['id']}, '
+          'chapterId=$chapterId, chapterIndex=${state.currentChapterIndex}, '
+          'pos=${state.position.inSeconds}s, chapterDur=$currentChapterDuration, '
+          'completedSec=$completedSeconds, totalDur=$totalDuration, pct=$percentage%');
+
       // Calculate current listen time if still playing
       int currentListenTime = _totalListenTime;
       if (_playStartTime != null) {
@@ -817,8 +1539,8 @@ class AudioNotifier extends StateNotifier<AudioState> with WidgetsBindingObserve
         {
           'user_id': user.id,
           'audiobook_id': state.audiobook!['id'],
-          'chapter_id': chapter['id'],
-          'current_chapter_id': chapter['id'],
+          'chapter_id': chapterId,
+          'current_chapter_id': chapterId,
           'current_chapter_index': state.currentChapterIndex,
           'position_seconds': state.position.inSeconds,
           'playback_speed': state.playbackSpeed,
@@ -894,7 +1616,7 @@ class AudioNotifier extends StateNotifier<AudioState> with WidgetsBindingObserve
           .eq('audiobook_id', audiobookId);
 
       int totalDuration = 0;
-      for (final chapter in (response as List)) {
+      for (final chapter in response as List) {
         totalDuration += (chapter['duration_seconds'] as int?) ?? 0;
       }
 
diff --git a/lib/providers/home_providers.dart b/lib/providers/home_providers.dart
index 8aed307..92dbce1 100644
--- a/lib/providers/home_providers.dart
+++ b/lib/providers/home_providers.dart
@@ -2,64 +2,182 @@ import 'package:flutter_riverpod/flutter_riverpod.dart';
 import 'package:supabase_flutter/supabase_flutter.dart';
 import 'package:myna/utils/app_logger.dart';
 
-/// Provider for featured audiobooks on home screen
+/// Cache for featured audiobooks (changes infrequently)
+List<Map<String, dynamic>>? _featuredCache;
+DateTime? _featuredCacheTime;
+
+/// Cache for new releases
+List<Map<String, dynamic>>? _newReleasesCache;
+DateTime? _newReleasesCacheTime;
+
+/// Cache for popular audiobooks
+List<Map<String, dynamic>>? _popularCache;
+DateTime? _popularCacheTime;
+
+/// Cache duration for audiobook lists (5 minutes - balances freshness with performance)
+const _audiobooksCacheDuration = Duration(minutes: 5);
+
+/// Provider for suggested audiobooks on home screen (excludes music)
+/// Logic: Featured items first (by play_count), then popular non-featured if not enough
+/// This ensures "پیشنهاد شده" always has content even without featured items
+/// Uses in-memory cache for performance
 final homeFeaturedProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
+  // Return cached data if still fresh
+  if (_featuredCache != null && _featuredCacheTime != null) {
+    final elapsed = DateTime.now().difference(_featuredCacheTime!);
+    if (elapsed < _audiobooksCacheDuration) {
+      return _featuredCache!;
+    }
+  }
+
   try {
-    final response = await Supabase.instance.client
+    // First try to get featured audiobooks, ordered by popularity
+    final featuredResponse = await Supabase.instance.client
         .from('audiobooks')
         .select('*, categories(name_fa), profiles!audiobooks_narrator_id_fkey(display_name, full_name)')
         .eq('status', 'approved')
         .eq('is_featured', true)
+        .eq('is_music', false)
+        .order('play_count', ascending: false)
         .order('created_at', ascending: false)
         .limit(10);
-    return List<Map<String, dynamic>>.from(response);
+
+    final featured = List<Map<String, dynamic>>.from(featuredResponse);
+
+    // If we have enough featured items, return them
+    if (featured.length >= 5) {
+      _featuredCache = featured;
+      _featuredCacheTime = DateTime.now();
+      return featured;
+    }
+
+    // Otherwise, supplement with high play_count non-featured items
+    final remaining = 10 - featured.length;
+    final featuredIds = featured.map((b) => b['id'] as int).toList();
+
+    // Get popular non-featured items to fill the gap
+    var query = Supabase.instance.client
+        .from('audiobooks')
+        .select('*, categories(name_fa), profiles!audiobooks_narrator_id_fkey(display_name, full_name)')
+        .eq('status', 'approved')
+        .eq('is_music', false)
+        .eq('is_featured', false);
+
+    // Exclude already-included featured items using NOT IN filter
+    if (featuredIds.isNotEmpty) {
+      query = query.not('id', 'in', '(${featuredIds.join(",")})');
+    }
+
+    final popularResponse = await query
+        .order('play_count', ascending: false)
+        .order('created_at', ascending: false)
+        .limit(remaining);
+
+    final popular = List<Map<String, dynamic>>.from(popularResponse);
+
+    final result = [...featured, ...popular];
+    _featuredCache = result;
+    _featuredCacheTime = DateTime.now();
+    return result;
   } catch (e) {
-    AppLogger.e('Error fetching featured audiobooks', error: e);
+    AppLogger.e('Error fetching suggested audiobooks', error: e);
     rethrow;
   }
 });
 
-/// Provider for new releases on home screen
+/// Provider for new releases on home screen (excludes music)
+/// Uses in-memory cache for performance
 final homeNewReleasesProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
+  // Return cached data if still fresh
+  if (_newReleasesCache != null && _newReleasesCacheTime != null) {
+    final elapsed = DateTime.now().difference(_newReleasesCacheTime!);
+    if (elapsed < _audiobooksCacheDuration) {
+      return _newReleasesCache!;
+    }
+  }
+
   try {
     final response = await Supabase.instance.client
         .from('audiobooks')
         .select('*, categories(name_fa), profiles!audiobooks_narrator_id_fkey(display_name, full_name)')
         .eq('status', 'approved')
+        .eq('is_music', false) // Exclude music from books section
         .order('created_at', ascending: false)
         .limit(10);
-    return List<Map<String, dynamic>>.from(response);
+    final result = List<Map<String, dynamic>>.from(response);
+
+    _newReleasesCache = result;
+    _newReleasesCacheTime = DateTime.now();
+    return result;
   } catch (e) {
     AppLogger.e('Error fetching new releases', error: e);
     rethrow;
   }
 });
 
-/// Provider for popular audiobooks on home screen
+/// Provider for popular audiobooks on home screen (excludes music)
+/// Shows top audiobooks by play_count (unique listeners)
+/// Secondary sort by created_at for deterministic ordering when counts are equal
+/// Uses in-memory cache for performance
 final homePopularProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
+  // Return cached data if still fresh
+  if (_popularCache != null && _popularCacheTime != null) {
+    final elapsed = DateTime.now().difference(_popularCacheTime!);
+    if (elapsed < _audiobooksCacheDuration) {
+      return _popularCache!;
+    }
+  }
+
   try {
     final response = await Supabase.instance.client
         .from('audiobooks')
         .select('*, categories(name_fa), profiles!audiobooks_narrator_id_fkey(display_name, full_name)')
         .eq('status', 'approved')
+        .eq('is_music', false) // Exclude music from books section
         .order('play_count', ascending: false)
+        .order('created_at', ascending: false) // Secondary sort for deterministic results
         .limit(10);
-    return List<Map<String, dynamic>>.from(response);
+    final result = List<Map<String, dynamic>>.from(response);
+
+    _popularCache = result;
+    _popularCacheTime = DateTime.now();
+    return result;
   } catch (e) {
     AppLogger.e('Error fetching popular audiobooks', error: e);
     rethrow;
   }
 });
 
+/// Cached categories data - categories rarely change, so we cache them
+/// This prevents redundant queries when navigating between screens
+List<Map<String, dynamic>>? _categoriesCache;
+DateTime? _categoriesCacheTime;
+const _categoriesCacheDuration = Duration(minutes: 30);
+
 /// Provider for categories on home screen (full category data)
+/// Uses in-memory cache to avoid redundant fetches
 final homeCategoriesProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
+  // Return cached data if still fresh
+  if (_categoriesCache != null && _categoriesCacheTime != null) {
+    final elapsed = DateTime.now().difference(_categoriesCacheTime!);
+    if (elapsed < _categoriesCacheDuration) {
+      return _categoriesCache!;
+    }
+  }
+
   try {
     final response = await Supabase.instance.client
         .from('categories')
         .select('*')
         .eq('is_active', true)
         .order('sort_order');
-    return List<Map<String, dynamic>>.from(response);
+    final result = List<Map<String, dynamic>>.from(response);
+
+    // Cache the result
+    _categoriesCache = result;
+    _categoriesCacheTime = DateTime.now();
+
+    return result;
   } catch (e) {
     AppLogger.e('Error fetching categories', error: e);
     rethrow;
@@ -67,141 +185,151 @@ final homeCategoriesProvider = FutureProvider<List<Map<String, dynamic>>>((ref)
 });
 
 /// Provider for categories used in forms (narrator upload, admin edit)
+/// Reuses the home categories cache since it contains all needed fields
 final formCategoriesProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
-  try {
-    final response = await Supabase.instance.client
-        .from('categories')
-        .select('id, name_fa, name_en')
-        .eq('is_active', true)
-        .order('sort_order');
-    return List<Map<String, dynamic>>.from(response);
-  } catch (e) {
-    AppLogger.e('Error fetching form categories', error: e);
-    rethrow;
-  }
+  // Reuse homeCategoriesProvider to avoid duplicate fetches
+  final categories = await ref.watch(homeCategoriesProvider.future);
+  // Return only the fields needed for forms
+  return categories.map((c) => {
+    'id': c['id'],
+    'name_fa': c['name_fa'],
+    'name_en': c['name_en'],
+  }).toList();
 });
 
-/// Provider for "Continue Listening" - the most recent INCOMPLETE audiobook
+/// Provider for "Continue Listening" - the most recent INCOMPLETE BOOK (is_music=false)
 /// Includes chapters for immediate playback and time remaining calculation
+/// OPTIMIZED: Runs audiobook and chapters queries in parallel
+/// NOTE: Music continue listening is handled by musicContinueListeningProvider
 final continueListeningProvider = FutureProvider<Map<String, dynamic>?>((ref) async {
   final user = Supabase.instance.client.auth.currentUser;
   if (user == null) return null;
 
   try {
-    // Get the most recent incomplete audiobook (completion < 100%)
+    // Get recent incomplete items - we need to find the first BOOK (is_music=false)
+    // Since listening_progress doesn't have is_music, we fetch multiple and filter
     final progressResponse = await Supabase.instance.client
         .from('listening_progress')
         .select('audiobook_id, completion_percentage, last_played_at, position_seconds, current_chapter_index, total_listen_time_seconds')
         .eq('user_id', user.id as Object)
         .lt('completion_percentage', 100)
         .order('last_played_at', ascending: false)
-        .limit(1);
+        .limit(10); // Fetch more to find a book among possible music items
 
     if ((progressResponse as List).isEmpty) return null;
 
-    final progress = progressResponse.first as Map<String, dynamic>;
-    final audiobookId = progress['audiobook_id'] as int;
-
-    // Fetch audiobook details
-    final audiobookResponse = await Supabase.instance.client
-        .from('audiobooks')
-        .select('*, profiles!audiobooks_narrator_id_fkey(display_name, full_name)')
-        .eq('id', audiobookId)
-        .eq('status', 'approved')
-        .maybeSingle();
-
-    if (audiobookResponse == null) return null;
-
-    // Fetch chapters
-    final chaptersResponse = await Supabase.instance.client
-        .from('chapters')
-        .select('*')
-        .eq('audiobook_id', audiobookId)
-        .order('chapter_index', ascending: true);
+    // Find the first incomplete BOOK (not music)
+    for (final progressItem in progressResponse) {
+      final progress = Map<String, dynamic>.from(progressItem as Map);
+      final audiobookId = progress['audiobook_id'] as int;
 
-    final audiobook = Map<String, dynamic>.from(audiobookResponse);
-    audiobook['progress'] = progress;
-    audiobook['chapters'] = List<Map<String, dynamic>>.from(
-      (chaptersResponse as List).map((c) => Map<String, dynamic>.from(c as Map)),
-    );
+      // Check if this is a book (is_music=false)
+      final audiobookResponse = await Supabase.instance.client
+          .from('audiobooks')
+          .select('*, profiles!audiobooks_narrator_id_fkey(display_name, full_name)')
+          .eq('id', audiobookId)
+          .eq('status', 'approved')
+          .eq('is_music', false) // FILTER: Books only
+          .maybeSingle();
+
+      if (audiobookResponse == null) continue; // Not a book or not approved, try next
+
+      // Found a book! Fetch chapters
+      final chaptersResponse = await Supabase.instance.client
+          .from('chapters')
+          .select('id, title_fa, audio_storage_path, duration_seconds, chapter_index, is_preview, audiobook_id')
+          .eq('audiobook_id', audiobookId)
+          .order('chapter_index', ascending: true);
+
+      final audiobook = Map<String, dynamic>.from(audiobookResponse as Map);
+      audiobook['progress'] = progress;
+      audiobook['chapters'] = List<Map<String, dynamic>>.from(
+        (chaptersResponse as List).map((c) => Map<String, dynamic>.from(c as Map)),
+      );
+
+      AppLogger.d('HOME CONTINUE: Loaded book "${audiobook['title_fa']}" (is_music=false)');
+      return audiobook;
+    }
 
-    return audiobook;
+    // No incomplete books found
+    AppLogger.d('HOME CONTINUE: No incomplete books found (is_music=false)');
+    return null;
   } catch (e) {
-    AppLogger.e('Error fetching continue listening audiobook', error: e);
+    AppLogger.e('Error fetching continue listening book', error: e);
     return null;
   }
 });
 
-/// Provider for recently played audiobooks (up to 3, excluding the continue listening book)
-/// OPTIMIZED: No longer waits for continueListeningProvider - runs independently
-/// The exclusion logic now happens at query time using completion_percentage
+/// Provider for recently played BOOKS (up to 3, excluding the continue listening book)
+/// FILTER: Only shows books (is_music=false), not music
+/// The exclusion logic excludes the first incomplete book (shown in continueListening)
 final homeRecentlyPlayedProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
   final user = Supabase.instance.client.auth.currentUser;
   if (user == null) return [];
 
   try {
-    // Get listening progress for books that are either completed OR not the most recent incomplete
-    // We fetch 4 entries and skip the first incomplete one (which is shown in continueListening)
+    // Get listening progress - we'll filter for books at the audiobooks level
+    // Include is_completed to properly verify completion status
     final progressResponse = await Supabase.instance.client
         .from('listening_progress')
-        .select('audiobook_id, completion_percentage, last_played_at, position_seconds, current_chapter_index')
+        .select('audiobook_id, completion_percentage, is_completed, last_played_at, position_seconds, current_chapter_index')
         .eq('user_id', user.id as Object)
         .order('last_played_at', ascending: false)
-        .limit(5);
+        .limit(15); // Fetch more since some may be music items
 
     if ((progressResponse as List).isEmpty) return [];
 
-    // Find the first incomplete book (this is the "continue listening" book)
+    // Get all audiobook IDs from progress
+    final allAudiobookIds = progressResponse.map((p) => p['audiobook_id'] as int).toList();
+
+    // Fetch ONLY BOOKS (is_music=false)
+    final audiobooksResponse = await Supabase.instance.client
+        .from('audiobooks')
+        .select('*, profiles!audiobooks_narrator_id_fkey(display_name, full_name)')
+        .inFilter('id', allAudiobookIds)
+        .eq('status', 'approved')
+        .eq('is_music', false); // FILTER: Books only
+
+    // Create a map for quick lookup (only books)
+    final booksMap = <int, Map<String, dynamic>>{};
+    for (final book in audiobooksResponse as List) {
+      booksMap[book['id'] as int] = Map<String, dynamic>.from(book as Map);
+    }
+
+    // Find the first incomplete BOOK (this is the "continue listening" book)
     // and exclude it from our results
     int? excludeId;
     for (final p in progressResponse) {
+      final audiobookId = p['audiobook_id'] as int;
+      if (!booksMap.containsKey(audiobookId)) continue; // Skip music items
+
       final completion = (p['completion_percentage'] as num?)?.toInt() ?? 0;
       if (completion < 100) {
-        excludeId = p['audiobook_id'] as int;
+        excludeId = audiobookId;
         break;
       }
     }
 
-    // Filter out the continue listening book and limit to 3
-    final filteredProgress = progressResponse
-        .where((p) => excludeId == null || p['audiobook_id'] != excludeId)
-        .take(3)
-        .toList();
+    // Merge progress into books, exclude continue listening, maintain order, limit to 3
+    final result = <Map<String, dynamic>>[];
+    for (final progress in progressResponse) {
+      if (result.length >= 3) break;
 
-    if (filteredProgress.isEmpty) return [];
+      final audiobookId = progress['audiobook_id'] as int;
+      if (audiobookId == excludeId) continue; // Skip continue listening book
 
-    // Get the audiobook IDs
-    final audiobookIds = filteredProgress.map((p) => p['audiobook_id'] as int).toList();
+      final book = booksMap[audiobookId];
+      if (book == null) continue; // Skip music items (not in booksMap)
 
-    // Fetch audiobook details
-    final audiobooksResponse = await Supabase.instance.client
-        .from('audiobooks')
-        .select('*, profiles!audiobooks_narrator_id_fkey(display_name, full_name)')
-        .inFilter('id', audiobookIds)
-        .eq('status', 'approved');
-
-    // Create a map for quick lookup
-    final audiobooksMap = <int, Map<String, dynamic>>{};
-    for (final book in audiobooksResponse as List) {
-      audiobooksMap[book['id'] as int] = Map<String, dynamic>.from(book as Map);
-    }
-
-    // Merge progress into audiobooks and maintain order
-    final result = <Map<String, dynamic>>[];
-    for (final progress in filteredProgress) {
-      final audiobookId = progress['audiobook_id'] as int;
-      final audiobook = audiobooksMap[audiobookId];
-      if (audiobook != null) {
-        // Clone the audiobook map to avoid modifying shared references
-        final bookWithProgress = Map<String, dynamic>.from(audiobook);
-        bookWithProgress['progress'] = Map<String, dynamic>.from(progress as Map);
-        result.add(bookWithProgress);
-      }
+      final bookWithProgress = Map<String, dynamic>.from(book);
+      bookWithProgress['progress'] = Map<String, dynamic>.from(progress as Map);
+      result.add(bookWithProgress);
     }
 
+    AppLogger.d('HOME RECENTLY: Loaded ${result.length} book items (is_music=false)');
     return result;
   } catch (e) {
-    AppLogger.e('Error fetching recently played audiobooks', error: e);
+    AppLogger.e('Error fetching recently played books', error: e);
     return [];
   }
 });
@@ -325,94 +453,90 @@ class Achievement {
 }
 
 /// Provider for user listening statistics
+/// NOTE(Issue 3 fix): Uses two queries to get accurate stats:
+/// 1. Aggregate query for total time and completed books (no limit, accurate totals)
+/// 2. Recent records query for streak calculation (limited for performance)
 final listeningStatsProvider = FutureProvider<ListeningStats>((ref) async {
   final user = Supabase.instance.client.auth.currentUser;
   if (user == null) return const ListeningStats();
 
   try {
-    // Fetch all listening progress records
-    final response = await Supabase.instance.client
+    // NOTE(Issue 3 fix): Fetch ALL records for accurate aggregation
+    // This fixes the bug where only last 30 records were counted
+    final allRecordsResponse = await Supabase.instance.client
         .from('listening_progress')
-        .select('total_listen_time_seconds, last_played_at, is_completed')
+        .select('total_listen_time_seconds, is_completed')
         .eq('user_id', user.id as Object);
 
-    if ((response as List).isEmpty) {
+    final allRecords = allRecordsResponse as List;
+
+    if (allRecords.isEmpty) {
       return const ListeningStats();
     }
 
-    // Calculate total listen time
+    // Calculate accurate totals from ALL records
     int totalTime = 0;
     int completedBooks = 0;
-    final uniqueDays = <String>{};
 
-    for (final record in response) {
+    for (final record in allRecords) {
       totalTime += (record['total_listen_time_seconds'] as num?)?.toInt() ?? 0;
-
       if (record['is_completed'] == true) {
         completedBooks++;
       }
+    }
 
-      // Track unique days
+    // For streak calculation, fetch recent records with dates
+    // 90 days is enough for streak calculation and limits data transfer
+    final recentRecordsResponse = await Supabase.instance.client
+        .from('listening_progress')
+        .select('last_played_at')
+        .eq('user_id', user.id as Object)
+        .order('last_played_at', ascending: false)
+        .limit(90);
+
+    final recentRecords = recentRecordsResponse as List;
+    final uniqueDays = <int>{}; // Use day-of-epoch for faster comparison
+
+    for (final record in recentRecords) {
       if (record['last_played_at'] != null) {
         final date = DateTime.parse(record['last_played_at'] as String);
-        uniqueDays.add('${date.year}-${date.month}-${date.day}');
+        uniqueDays.add(date.millisecondsSinceEpoch ~/ 86400000); // Days since epoch
       }
     }
 
-    // Calculate current streak (consecutive days ending today or yesterday)
-    // and longest streak (maximum consecutive days ever)
-    final sortedDays = uniqueDays.toList()..sort(); // Oldest first for longest streak calculation
+    // PERFORMANCE: Simplified streak calculation
     int currentStreak = 0;
     int longestStreak = 0;
 
-    if (sortedDays.isNotEmpty) {
-      // Calculate longest streak by scanning all days chronologically
-      int tempStreak = 1;
-      for (int i = 1; i < sortedDays.length; i++) {
-        final prevParts = sortedDays[i - 1].split('-');
-        final currParts = sortedDays[i].split('-');
-        final prevDate = DateTime(int.parse(prevParts[0]), int.parse(prevParts[1]), int.parse(prevParts[2]));
-        final currDate = DateTime(int.parse(currParts[0]), int.parse(currParts[1]), int.parse(currParts[2]));
+    if (uniqueDays.isNotEmpty) {
+      final sortedDays = uniqueDays.toList()..sort((a, b) => b.compareTo(a)); // Newest first
+      final todayEpoch = DateTime.now().millisecondsSinceEpoch ~/ 86400000;
 
-        if (currDate.difference(prevDate).inDays == 1) {
-          tempStreak++;
-        } else {
-          if (tempStreak > longestStreak) {
-            longestStreak = tempStreak;
+      // Check current streak (must start today or yesterday)
+      if (sortedDays.first == todayEpoch || sortedDays.first == todayEpoch - 1) {
+        int checkDay = sortedDays.first;
+        for (final day in sortedDays) {
+          if (day == checkDay) {
+            currentStreak++;
+            checkDay--;
+          } else if (day < checkDay) {
+            break; // Gap found
           }
-          tempStreak = 1;
         }
       }
-      // Don't forget to check the last streak
-      if (tempStreak > longestStreak) {
-        longestStreak = tempStreak;
-      }
 
-      // Calculate current streak (must end today or yesterday)
-      final today = DateTime.now();
-      final todayStr = '${today.year}-${today.month}-${today.day}';
-      final yesterday = today.subtract(const Duration(days: 1));
-      final yesterdayStr = '${yesterday.year}-${yesterday.month}-${yesterday.day}';
-
-      // Sort newest first for current streak
-      sortedDays.sort((a, b) => b.compareTo(a));
-
-      // Check if most recent activity was today or yesterday
-      if (sortedDays.first == todayStr || sortedDays.first == yesterdayStr) {
-        currentStreak = 1;
-        DateTime checkDate = sortedDays.first == todayStr ? today : yesterday;
-
-        // Count consecutive days backwards
-        for (int i = 1; i < sortedDays.length; i++) {
-          checkDate = checkDate.subtract(const Duration(days: 1));
-          final checkStr = '${checkDate.year}-${checkDate.month}-${checkDate.day}';
-          if (sortedDays.contains(checkStr)) {
-            currentStreak++;
-          } else {
-            break;
-          }
+      // Calculate longest streak (simple scan)
+      sortedDays.sort(); // Oldest first
+      int tempStreak = 1;
+      for (int i = 1; i < sortedDays.length; i++) {
+        if (sortedDays[i] - sortedDays[i - 1] == 1) {
+          tempStreak++;
+        } else {
+          if (tempStreak > longestStreak) longestStreak = tempStreak;
+          tempStreak = 1;
         }
       }
+      if (tempStreak > longestStreak) longestStreak = tempStreak;
     }
 
     return ListeningStats(
@@ -427,3 +551,203 @@ final listeningStatsProvider = FutureProvider<ListeningStats>((ref) async {
     return const ListeningStats();
   }
 });
+
+// ============================================
+// MUSIC PROVIDERS
+// ============================================
+// These providers fetch content where is_music = true
+// Used by the موسیقی (Music) tab in the bottom navigation
+
+/// Provider for featured music on music screen
+final musicFeaturedProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
+  try {
+    final response = await Supabase.instance.client
+        .from('audiobooks')
+        .select('*, categories(name_fa), profiles!audiobooks_narrator_id_fkey(display_name, full_name)')
+        .eq('status', 'approved')
+        .eq('is_music', true)
+        .eq('is_featured', true)
+        .order('created_at', ascending: false)
+        .limit(10);
+    return List<Map<String, dynamic>>.from(response);
+  } catch (e) {
+    AppLogger.e('Error fetching featured music', error: e);
+    rethrow;
+  }
+});
+
+/// Provider for new music releases
+final musicNewReleasesProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
+  try {
+    final response = await Supabase.instance.client
+        .from('audiobooks')
+        .select('*, categories(name_fa), profiles!audiobooks_narrator_id_fkey(display_name, full_name)')
+        .eq('status', 'approved')
+        .eq('is_music', true)
+        .order('created_at', ascending: false)
+        .limit(10);
+    return List<Map<String, dynamic>>.from(response);
+  } catch (e) {
+    AppLogger.e('Error fetching new music', error: e);
+    rethrow;
+  }
+});
+
+/// Provider for popular music (by play count)
+/// Secondary sort by created_at for deterministic ordering
+final musicPopularProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
+  try {
+    final response = await Supabase.instance.client
+        .from('audiobooks')
+        .select('*, categories(name_fa), profiles!audiobooks_narrator_id_fkey(display_name, full_name)')
+        .eq('status', 'approved')
+        .eq('is_music', true)
+        .order('play_count', ascending: false)
+        .order('created_at', ascending: false) // Secondary sort for deterministic results
+        .limit(10);
+    return List<Map<String, dynamic>>.from(response);
+  } catch (e) {
+    AppLogger.e('Error fetching popular music', error: e);
+    rethrow;
+  }
+});
+
+/// Provider for all music (for browsing)
+final musicAllProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
+  try {
+    final response = await Supabase.instance.client
+        .from('audiobooks')
+        .select('*, categories(name_fa), profiles!audiobooks_narrator_id_fkey(display_name, full_name)')
+        .eq('status', 'approved')
+        .eq('is_music', true)
+        .order('created_at', ascending: false)
+        .limit(50);
+    return List<Map<String, dynamic>>.from(response);
+  } catch (e) {
+    AppLogger.e('Error fetching all music', error: e);
+    rethrow;
+  }
+});
+
+/// Provider for music categories (سبک‌های موسیقی) for filtering
+final musicCategoriesForFilterProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
+  try {
+    final response = await Supabase.instance.client
+        .from('music_categories')
+        .select('id, name_fa, name_en, icon, is_active')
+        .eq('is_active', true)
+        .order('sort_order');
+    return List<Map<String, dynamic>>.from(response);
+  } catch (e) {
+    AppLogger.e('Error fetching music categories', error: e);
+    rethrow;
+  }
+});
+
+/// State provider for selected music category filter
+/// null means "همه سبک‌ها" (All genres)
+final selectedMusicCategoryProvider = StateProvider<int?>((ref) => null);
+
+/// Provider for "ادامه‌ی شنیدن موسیقی" - recently played music items
+/// Shows music items the user has started listening to (is_music = true)
+final musicContinueListeningProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
+  final user = Supabase.instance.client.auth.currentUser;
+  if (user == null) return [];
+
+  try {
+    // Get listening progress for items, ordered by last played
+    final progressResponse = await Supabase.instance.client
+        .from('listening_progress')
+        .select('audiobook_id, completion_percentage, last_played_at, position_seconds, current_chapter_index')
+        .eq('user_id', user.id as Object)
+        .lt('completion_percentage', 100)
+        .order('last_played_at', ascending: false)
+        .limit(10);
+
+    if ((progressResponse as List).isEmpty) return [];
+
+    final audiobookIds = progressResponse
+        .map((p) => p['audiobook_id'] as int)
+        .toList();
+
+    // Fetch music items only (is_music = true)
+    final audiobooksResponse = await Supabase.instance.client
+        .from('audiobooks')
+        .select('*, profiles!audiobooks_narrator_id_fkey(display_name, full_name)')
+        .inFilter('id', audiobookIds)
+        .eq('status', 'approved')
+        .eq('is_music', true);
+
+    // Create a map for quick lookup
+    final audiobooksMap = <int, Map<String, dynamic>>{};
+    for (final item in audiobooksResponse as List) {
+      audiobooksMap[item['id'] as int] = Map<String, dynamic>.from(item as Map);
+    }
+
+    // Merge progress into items and maintain order by last_played_at
+    final result = <Map<String, dynamic>>[];
+    for (final progress in progressResponse) {
+      final audiobookId = progress['audiobook_id'] as int;
+      final item = audiobooksMap[audiobookId];
+      if (item != null) {
+        final itemWithProgress = Map<String, dynamic>.from(item);
+        itemWithProgress['progress'] = Map<String, dynamic>.from(progress as Map);
+        result.add(itemWithProgress);
+      }
+    }
+
+    return result;
+  } catch (e) {
+    AppLogger.e('Error fetching music continue listening', error: e);
+    return [];
+  }
+});
+
+/// Provider for music filtered by selected category
+/// Uses the junction table audiobook_music_categories for filtering
+final musicByCategoryProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
+  final selectedCategoryId = ref.watch(selectedMusicCategoryProvider);
+
+  try {
+    if (selectedCategoryId == null) {
+      // No filter - return all music
+      final response = await Supabase.instance.client
+          .from('audiobooks')
+          .select('*, categories(name_fa), profiles!audiobooks_narrator_id_fkey(display_name, full_name)')
+          .eq('status', 'approved')
+          .eq('is_music', true)
+          .order('created_at', ascending: false)
+          .limit(50);
+      return List<Map<String, dynamic>>.from(response);
+    }
+
+    // Filter by category using junction table
+    // First get audiobook IDs that have this music category
+    final junctionResponse = await Supabase.instance.client
+        .from('audiobook_music_categories')
+        .select('audiobook_id')
+        .eq('music_category_id', selectedCategoryId);
+
+    final audiobookIds = (junctionResponse as List)
+        .map((row) => row['audiobook_id'] as int)
+        .toList();
+
+    if (audiobookIds.isEmpty) {
+      return [];
+    }
+
+    // Fetch those audiobooks
+    final response = await Supabase.instance.client
+        .from('audiobooks')
+        .select('*, categories(name_fa), profiles!audiobooks_narrator_id_fkey(display_name, full_name)')
+        .eq('status', 'approved')
+        .eq('is_music', true)
+        .inFilter('id', audiobookIds)
+        .order('created_at', ascending: false);
+
+    return List<Map<String, dynamic>>.from(response);
+  } catch (e) {
+    AppLogger.e('Error fetching music by category', error: e);
+    rethrow;
+  }
+});
diff --git a/lib/providers/promotion_providers.dart b/lib/providers/promotion_providers.dart
index a0077ad..4b206a6 100644
--- a/lib/providers/promotion_providers.dart
+++ b/lib/providers/promotion_providers.dart
@@ -2,8 +2,22 @@ import 'package:flutter_riverpod/flutter_riverpod.dart';
 import 'package:supabase_flutter/supabase_flutter.dart';
 import 'package:myna/utils/app_logger.dart';
 
+/// Cache for banners - they change infrequently
+List<Map<String, dynamic>>? _bannersCache;
+DateTime? _bannersCacheTime;
+const _bannersCacheDuration = Duration(minutes: 10);
+
 /// Provider for active banners on home screen (listener view)
+/// Uses in-memory cache to reduce redundant fetches
 final homeBannersProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
+  // Return cached data if still fresh
+  if (_bannersCache != null && _bannersCacheTime != null) {
+    final elapsed = DateTime.now().difference(_bannersCacheTime!);
+    if (elapsed < _bannersCacheDuration) {
+      return _bannersCache!;
+    }
+  }
+
   try {
     final response = await Supabase.instance.client
         .from('promo_banners')
@@ -13,16 +27,36 @@ final homeBannersProvider = FutureProvider<List<Map<String, dynamic>>>((ref) asy
         .or('ends_at.is.null,ends_at.gte.${DateTime.now().toIso8601String()}')
         .order('sort_order')
         .limit(10);
-    return List<Map<String, dynamic>>.from(response);
+    final result = List<Map<String, dynamic>>.from(response);
+
+    // Cache the result
+    _bannersCache = result;
+    _bannersCacheTime = DateTime.now();
+
+    return result;
   } catch (e) {
     AppLogger.e('Error fetching home banners', error: e);
     rethrow;
   }
 });
 
+/// Cache for shelves - they change infrequently
+List<Map<String, dynamic>>? _shelvesCache;
+DateTime? _shelvesCacheTime;
+const _shelvesCacheDuration = Duration(minutes: 10);
+
 /// Provider for active shelves with their audiobooks on home screen
 /// OPTIMIZED: Single batch query instead of N+1 pattern
+/// Uses in-memory cache to reduce redundant fetches
 final homeShelvesProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
+  // Return cached data if still fresh
+  if (_shelvesCache != null && _shelvesCacheTime != null) {
+    final elapsed = DateTime.now().difference(_shelvesCacheTime!);
+    if (elapsed < _shelvesCacheDuration) {
+      return _shelvesCache!;
+    }
+  }
+
   try {
     // Get active shelves
     final shelvesResponse = await Supabase.instance.client
@@ -33,7 +67,11 @@ final homeShelvesProvider = FutureProvider<List<Map<String, dynamic>>>((ref) asy
         .limit(10);
 
     final shelves = List<Map<String, dynamic>>.from(shelvesResponse);
-    if (shelves.isEmpty) return [];
+    if (shelves.isEmpty) {
+      _shelvesCache = [];
+      _shelvesCacheTime = DateTime.now();
+      return [];
+    }
 
     // OPTIMIZATION: Get all shelf IDs and fetch ALL items in ONE query
     final shelfIds = shelves.map((s) => s['id'] as int).toList();
@@ -62,7 +100,13 @@ final homeShelvesProvider = FutureProvider<List<Map<String, dynamic>>>((ref) asy
     }
 
     // Filter out shelves with no audiobooks
-    return shelves.where((s) => (s['audiobooks'] as List).isNotEmpty).toList();
+    final result = shelves.where((s) => (s['audiobooks'] as List).isNotEmpty).toList();
+
+    // Cache the result
+    _shelvesCache = result;
+    _shelvesCacheTime = DateTime.now();
+
+    return result;
   } catch (e) {
     AppLogger.e('Error fetching home shelves', error: e);
     rethrow;
diff --git a/lib/providers/support_providers.dart b/lib/providers/support_providers.dart
index 3ca8d69..915e71b 100644
--- a/lib/providers/support_providers.dart
+++ b/lib/providers/support_providers.dart
@@ -25,7 +25,11 @@ final userTicketsProvider = FutureProvider<List<Map<String, dynamic>>>((ref) asy
 });
 
 /// Provider for ticket detail with messages
+/// NOTE(Issue 8 fix): Added ownership check to prevent users from accessing
+/// other users' tickets. This is a client-side safeguard in addition to RLS.
 final ticketDetailProvider = FutureProvider.family<Map<String, dynamic>?, int>((ref, ticketId) async {
+  final user = Supabase.instance.client.auth.currentUser;
+
   try {
     // Get ticket
     final ticketResponse = await Supabase.instance.client
@@ -38,6 +42,24 @@ final ticketDetailProvider = FutureProvider.family<Map<String, dynamic>?, int>((
 
     final ticket = Map<String, dynamic>.from(ticketResponse);
 
+    // NOTE(Issue 8 fix): Verify the user owns this ticket or is an admin
+    // This prevents users from seeing other users' support conversations
+    final ticketUserId = ticket['user_id'] as String?;
+    if (user != null && ticketUserId != null && ticketUserId != user.id) {
+      // Check if current user is admin (by checking profile role)
+      final profileResponse = await Supabase.instance.client
+          .from('profiles')
+          .select('role')
+          .eq('id', user.id)
+          .maybeSingle();
+
+      final userRole = profileResponse?['role'] as String?;
+      if (userRole != 'admin') {
+        AppLogger.w('Support: User ${user.id} attempted to access ticket $ticketId owned by $ticketUserId');
+        return null; // Block access - user doesn't own this ticket
+      }
+    }
+
     // Get messages
     final messagesResponse = await Supabase.instance.client
         .from('support_messages')
diff --git a/lib/providers/user_providers.dart b/lib/providers/user_providers.dart
index bd1a97c..4fef196 100644
--- a/lib/providers/user_providers.dart
+++ b/lib/providers/user_providers.dart
@@ -28,9 +28,13 @@ void invalidateUserProviders(WidgetRef ref) {
   ref.invalidate(homeRecentlyPlayedProvider);
   ref.invalidate(listeningStatsProvider);
 
-  // Library/ownership providers
-  ref.invalidate(ownedBooksWithProgressProvider);
-  ref.invalidate(wishlistBooksProvider);
+  // Library/ownership providers - invalidate both family and legacy providers
+  ref.invalidate(ownedItemsWithProgressProvider(false));  // Books
+  ref.invalidate(ownedItemsWithProgressProvider(true));   // Music
+  ref.invalidate(ownedBooksWithProgressProvider);         // Legacy
+  ref.invalidate(wishlistItemsProvider(false));           // Books wishlist
+  ref.invalidate(wishlistItemsProvider(true));            // Music wishlist
+  ref.invalidate(wishlistBooksProvider);                  // Legacy
   ref.invalidate(wishlistProvider);
 
   // Support providers
@@ -64,9 +68,13 @@ void invalidateUserProvidersWithContainer(ProviderContainer container) {
   container.invalidate(homeRecentlyPlayedProvider);
   container.invalidate(listeningStatsProvider);
 
-  // Library/ownership providers
-  container.invalidate(ownedBooksWithProgressProvider);
-  container.invalidate(wishlistBooksProvider);
+  // Library/ownership providers - invalidate both family and legacy providers
+  container.invalidate(ownedItemsWithProgressProvider(false));  // Books
+  container.invalidate(ownedItemsWithProgressProvider(true));   // Music
+  container.invalidate(ownedBooksWithProgressProvider);         // Legacy
+  container.invalidate(wishlistItemsProvider(false));           // Books wishlist
+  container.invalidate(wishlistItemsProvider(true));            // Music wishlist
+  container.invalidate(wishlistBooksProvider);                  // Legacy
   container.invalidate(wishlistProvider);
 
   // Support providers
diff --git a/lib/screens/admin/admin_app_settings_screen.dart b/lib/screens/admin/admin_app_settings_screen.dart
index 75adc49..3866f64 100644
--- a/lib/screens/admin/admin_app_settings_screen.dart
+++ b/lib/screens/admin/admin_app_settings_screen.dart
@@ -151,7 +151,7 @@ class _AdminAppSettingsScreenState extends ConsumerState<AdminAppSettingsScreen>
         child: Icon(icon, color: AppColors.primary),
       ),
       title: Text(title, style: const TextStyle(color: AppColors.textPrimary)),
-      subtitle: Text(subtitle, style: TextStyle(color: AppColors.textSecondary, fontSize: 13)),
+      subtitle: Text(subtitle, style: const TextStyle(color: AppColors.textSecondary, fontSize: 13)),
       trailing: const Icon(Icons.edit, color: AppColors.textTertiary, size: 20),
     ),
   );
@@ -172,7 +172,7 @@ class _AdminAppSettingsScreenState extends ConsumerState<AdminAppSettingsScreen>
               final info = CurrencyHelper.getInfo(code);
               return RadioListTile<String>(
                 title: Text('${info.symbol} ${info.name}', style: const TextStyle(color: AppColors.textPrimary)),
-                subtitle: Text(code, style: TextStyle(color: AppColors.textSecondary)),
+                subtitle: Text(code, style: const TextStyle(color: AppColors.textSecondary)),
                 value: code,
                 groupValue: selectedCode,
                 onChanged: (value) => setState(() => selectedCode = value!),
diff --git a/lib/screens/admin/admin_audiobook_detail_screen.dart b/lib/screens/admin/admin_audiobook_detail_screen.dart
index 1ad0911..d702c01 100644
--- a/lib/screens/admin/admin_audiobook_detail_screen.dart
+++ b/lib/screens/admin/admin_audiobook_detail_screen.dart
@@ -118,7 +118,7 @@ class _AdminAudiobookDetailScreenState extends ConsumerState<AdminAudiobookDetai
       widget.onUpdate();
       if (mounted) {
         ScaffoldMessenger.of(context).showSnackBar(
-          SnackBar(content: Text('وضعیت تغییر کرد'), backgroundColor: AppColors.success),
+          const SnackBar(content: Text('وضعیت تغییر کرد'), backgroundColor: AppColors.success),
         );
       }
     } catch (e) {
@@ -172,7 +172,7 @@ class _AdminAudiobookDetailScreenState extends ConsumerState<AdminAudiobookDetai
               maxLines: 4,
               decoration: InputDecoration(
                 hintText: 'دلیل رد را اینجا بنویسید...',
-                hintStyle: TextStyle(color: AppColors.textTertiary),
+                hintStyle: const TextStyle(color: AppColors.textTertiary),
                 filled: true,
                 fillColor: AppColors.background,
                 border: OutlineInputBorder(
@@ -370,7 +370,7 @@ class _AdminAudiobookDetailScreenState extends ConsumerState<AdminAudiobookDetai
             IconButton(
               icon: const Icon(Icons.feedback_outlined),
               tooltip: 'افزودن بازخورد',
-              onPressed: () => _showFeedbackDialog(),
+              onPressed: _showFeedbackDialog,
             ),
             PopupMenuButton<String>(
               icon: const Icon(Icons.more_vert),
@@ -408,6 +408,11 @@ class _AdminAudiobookDetailScreenState extends ConsumerState<AdminAudiobookDetai
                             children: [
                               Text((_audiobook['title_fa'] as String?) ?? 'بدون عنوان', style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold, color: AppColors.textPrimary)),
                               const SizedBox(height: 8),
+                              // Show author/artist based on content type
+                              _buildCreatorInfoRow(),
+                              // Show translator only for books (not music)
+                              if (_audiobook['is_music'] != true && _audiobook['translator_fa'] != null && (_audiobook['translator_fa'] as String).isNotEmpty)
+                                _infoRow(Icons.translate, 'مترجم', _audiobook['translator_fa'] as String),
                               _infoRow(Icons.mic, 'گوینده', (narrator?['display_name'] as String?) ?? (narrator?['full_name'] as String?) ?? 'نامشخص'),
                               _infoRow(Icons.category, 'دسته', (category?['name_fa'] as String?) ?? 'نامشخص'),
                               _infoRow(Icons.attach_money, 'قیمت', _audiobook['is_free'] == true ? 'رایگان' : '${_audiobook['price_toman'] ?? 0}'),
@@ -439,7 +444,7 @@ class _AdminAudiobookDetailScreenState extends ConsumerState<AdminAudiobookDetai
                       color: AppColors.surface,
                       child: SwitchListTile(
                         title: const Text('کتاب ویژه', style: TextStyle(color: AppColors.textPrimary)),
-                        subtitle: Text(isFeatured ? 'در صفحه اصلی نمایش داده می‌شود' : 'در صفحه اصلی نمایش داده نمی‌شود', style: TextStyle(color: AppColors.textSecondary, fontSize: 12)),
+                        subtitle: Text(isFeatured ? 'در صفحه اصلی نمایش داده می‌شود' : 'در صفحه اصلی نمایش داده نمی‌شود', style: const TextStyle(color: AppColors.textSecondary, fontSize: 12)),
                         value: isFeatured,
                         onChanged: (_) => _toggleFeatured(),
                         activeColor: AppColors.primary,
@@ -456,7 +461,7 @@ class _AdminAudiobookDetailScreenState extends ConsumerState<AdminAudiobookDetai
                         width: double.infinity,
                         padding: const EdgeInsets.all(12),
                         decoration: BoxDecoration(color: AppColors.surface, borderRadius: BorderRadius.circular(12)),
-                        child: Text(_audiobook['description_fa'] as String, style: TextStyle(color: AppColors.textSecondary, height: 1.6)),
+                        child: Text(_audiobook['description_fa'] as String, style: const TextStyle(color: AppColors.textSecondary, height: 1.6)),
                       ),
                       const SizedBox(height: 24),
                     ],
@@ -473,7 +478,7 @@ class _AdminAudiobookDetailScreenState extends ConsumerState<AdminAudiobookDetai
                         child: const Center(child: Text('هنوز فصلی اضافه نشده', style: TextStyle(color: AppColors.textTertiary))),
                       )
                     else
-                      Container(
+                      DecoratedBox(
                         decoration: BoxDecoration(color: AppColors.surface, borderRadius: BorderRadius.circular(12)),
                         child: Column(
                           children: List.generate(_chapters.length, (i) {
@@ -537,11 +542,11 @@ class _AdminAudiobookDetailScreenState extends ConsumerState<AdminAudiobookDetai
                     const SizedBox(height: 12),
                     Row(
                       children: [
-                        _statCard(Icons.star, '${((_audiobook['avg_rating'] as num?) ?? 0).toStringAsFixed(1)}', 'امتیاز'),
+                        Expanded(child: _statCard(Icons.star, ((_audiobook['avg_rating'] as num?) ?? 0).toStringAsFixed(1), 'امتیاز')),
                         const SizedBox(width: 12),
-                        _statCard(Icons.reviews, '${(_audiobook['review_count'] as int?) ?? 0}', 'نظر'),
+                        Expanded(child: _statCard(Icons.reviews, '${(_audiobook['review_count'] as int?) ?? 0}', 'نظر')),
                         const SizedBox(width: 12),
-                        _statCard(Icons.shopping_cart, '${(_audiobook['purchase_count'] as int?) ?? 0}', 'خرید'),
+                        Expanded(child: _statCard(Icons.shopping_cart, '${(_audiobook['purchase_count'] as int?) ?? 0}', 'خرید')),
                       ],
                     ),
                   ],
@@ -558,13 +563,27 @@ class _AdminAudiobookDetailScreenState extends ConsumerState<AdminAudiobookDetai
         children: [
           Icon(icon, size: 16, color: AppColors.textTertiary),
           const SizedBox(width: 6),
-          Text('$label: ', style: TextStyle(color: AppColors.textTertiary, fontSize: 12)),
-          Expanded(child: Text(value, style: TextStyle(color: AppColors.textSecondary, fontSize: 12), overflow: TextOverflow.ellipsis)),
+          Text('$label: ', style: const TextStyle(color: AppColors.textTertiary, fontSize: 12)),
+          Expanded(child: Text(value, style: const TextStyle(color: AppColors.textSecondary, fontSize: 12), overflow: TextOverflow.ellipsis)),
         ],
       ),
     );
   }
 
+  /// Build row showing author (for books) or artist (for music)
+  Widget _buildCreatorInfoRow() {
+    final isMusic = _audiobook['is_music'] == true;
+    final authorFa = _audiobook['author_fa'] as String?;
+
+    if (authorFa == null || authorFa.isEmpty) {
+      return const SizedBox.shrink();
+    }
+
+    final label = isMusic ? 'هنرمند' : 'نویسنده';
+    final icon = isMusic ? Icons.person : Icons.edit;
+    return _infoRow(icon, label, authorFa);
+  }
+
   Widget _statusChip(String value, String label, String currentStatus) {
     final isSelected = currentStatus == value;
     return ChoiceChip(
@@ -578,18 +597,19 @@ class _AdminAudiobookDetailScreenState extends ConsumerState<AdminAudiobookDetai
   }
 
   Widget _statCard(IconData icon, String value, String label) {
-    return Expanded(
-      child: Container(
-        padding: const EdgeInsets.all(12),
-        decoration: BoxDecoration(color: AppColors.surface, borderRadius: BorderRadius.circular(12)),
-        child: Column(
-          children: [
-            Icon(icon, color: AppColors.primary),
-            const SizedBox(height: 4),
-            Text(value, style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold, color: AppColors.textPrimary)),
-            Text(label, style: TextStyle(fontSize: 11, color: AppColors.textSecondary)),
-          ],
-        ),
+    return Container(
+      padding: const EdgeInsets.all(12),
+      decoration: BoxDecoration(color: AppColors.surface, borderRadius: BorderRadius.circular(12)),
+      child: Column(
+        children: [
+          Icon(icon, color: AppColors.primary),
+          const SizedBox(height: 4),
+          FittedBox(
+            fit: BoxFit.scaleDown,
+            child: Text(value, style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold, color: AppColors.textPrimary)),
+          ),
+          Text(label, style: const TextStyle(fontSize: 11, color: AppColors.textSecondary)),
+        ],
       ),
     );
   }
@@ -605,7 +625,7 @@ class _AdminAudiobookDetailScreenState extends ConsumerState<AdminAudiobookDetai
           children: [
             const Text('بازخوردها', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold, color: AppColors.textPrimary)),
             TextButton.icon(
-              onPressed: () => _showFeedbackDialog(),
+              onPressed: _showFeedbackDialog,
               icon: const Icon(Icons.add, size: 18),
               label: const Text('افزودن'),
             ),
@@ -628,10 +648,10 @@ class _AdminAudiobookDetailScreenState extends ConsumerState<AdminAudiobookDetai
               );
             }
 
-            return Container(
+            return DecoratedBox(
               decoration: BoxDecoration(color: AppColors.surface, borderRadius: BorderRadius.circular(12)),
               child: Column(
-                children: feedbackList.map((feedback) => _buildFeedbackItem(feedback)).toList(),
+                children: feedbackList.map(_buildFeedbackItem).toList(),
               ),
             );
           },
@@ -687,7 +707,7 @@ class _AdminAudiobookDetailScreenState extends ConsumerState<AdminAudiobookDetai
       },
       child: Container(
         padding: const EdgeInsets.all(12),
-        decoration: BoxDecoration(
+        decoration: const BoxDecoration(
           border: Border(bottom: BorderSide(color: AppColors.background, width: 1)),
         ),
         child: Column(
diff --git a/lib/screens/admin/admin_audiobooks_screen.dart b/lib/screens/admin/admin_audiobooks_screen.dart
index 66b8f2a..579cebd 100644
--- a/lib/screens/admin/admin_audiobooks_screen.dart
+++ b/lib/screens/admin/admin_audiobooks_screen.dart
@@ -33,6 +33,8 @@ class AdminAudiobooksScreen extends ConsumerStatefulWidget {
 class _AdminAudiobooksScreenState extends ConsumerState<AdminAudiobooksScreen> with SingleTickerProviderStateMixin {
   late TabController _tabController;
   String _searchQuery = '';
+  // Content type filter: null = all, false = books only, true = music only
+  bool? _contentTypeFilter;
 
   @override
   void initState() {
@@ -73,8 +75,8 @@ class _AdminAudiobooksScreenState extends ConsumerState<AdminAudiobooksScreen> w
           indicatorColor: AppColors.primary,
           isScrollable: true,
           tabs: const [
-            Tab(text: 'در انتظار'),
-            Tab(text: 'تأیید شده'),
+            Tab(text: 'صف بررسی'),
+            Tab(text: 'منتشر شده'),
             Tab(text: 'رد شده'),
             Tab(text: 'ویژه'),
             Tab(text: 'همه'),
@@ -83,12 +85,37 @@ class _AdminAudiobooksScreenState extends ConsumerState<AdminAudiobooksScreen> w
       ),
       body: Column(
         children: [
+          // Content type filter (Books / Music / All)
+          Padding(
+            padding: const EdgeInsets.fromLTRB(12, 12, 12, 0),
+            child: Row(
+              children: [
+                _buildContentTypeChip(
+                  label: 'همه',
+                  isSelected: _contentTypeFilter == null,
+                  onTap: () => setState(() => _contentTypeFilter = null),
+                ),
+                const SizedBox(width: 8),
+                _buildContentTypeChip(
+                  label: '📚 کتاب‌ها',
+                  isSelected: _contentTypeFilter == false,
+                  onTap: () => setState(() => _contentTypeFilter = false),
+                ),
+                const SizedBox(width: 8),
+                _buildContentTypeChip(
+                  label: '🎵 موسیقی',
+                  isSelected: _contentTypeFilter == true,
+                  onTap: () => setState(() => _contentTypeFilter = true),
+                ),
+              ],
+            ),
+          ),
           // Search bar
           Padding(
             padding: const EdgeInsets.all(12),
             child: TextField(
               decoration: InputDecoration(
-                hintText: 'جستجوی کتاب...',
+                hintText: _contentTypeFilter == true ? 'جستجوی موسیقی...' : 'جستجوی کتاب...',
                 prefixIcon: const Icon(Icons.search),
                 filled: true,
                 fillColor: AppColors.surface,
@@ -102,11 +129,11 @@ class _AdminAudiobooksScreenState extends ConsumerState<AdminAudiobooksScreen> w
             child: TabBarView(
               controller: _tabController,
               children: [
-                _AudiobooksList(status: 'pending', searchQuery: _searchQuery, onRefresh: _refreshAll),
-                _AudiobooksList(status: 'approved', searchQuery: _searchQuery, onRefresh: _refreshAll),
-                _AudiobooksList(status: 'rejected', searchQuery: _searchQuery, onRefresh: _refreshAll),
-                _AudiobooksList(status: 'featured', searchQuery: _searchQuery, onRefresh: _refreshAll),
-                _AudiobooksList(status: 'all', searchQuery: _searchQuery, onRefresh: _refreshAll),
+                _AudiobooksList(status: 'pending', searchQuery: _searchQuery, contentTypeFilter: _contentTypeFilter, onRefresh: _refreshAll),
+                _AudiobooksList(status: 'approved', searchQuery: _searchQuery, contentTypeFilter: _contentTypeFilter, onRefresh: _refreshAll),
+                _AudiobooksList(status: 'rejected', searchQuery: _searchQuery, contentTypeFilter: _contentTypeFilter, onRefresh: _refreshAll),
+                _AudiobooksList(status: 'featured', searchQuery: _searchQuery, contentTypeFilter: _contentTypeFilter, onRefresh: _refreshAll),
+                _AudiobooksList(status: 'all', searchQuery: _searchQuery, contentTypeFilter: _contentTypeFilter, onRefresh: _refreshAll),
               ],
             ),
           ),
@@ -124,7 +151,34 @@ class _AdminAudiobooksScreenState extends ConsumerState<AdminAudiobooksScreen> w
         },
         backgroundColor: AppColors.primary,
         icon: const Icon(Icons.add),
-        label: const Text('آپلود کتاب'),
+        label: const Text('آپلود محتوا'),
+      ),
+    );
+  }
+
+  Widget _buildContentTypeChip({
+    required String label,
+    required bool isSelected,
+    required VoidCallback onTap,
+  }) {
+    return GestureDetector(
+      onTap: onTap,
+      child: Container(
+        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
+        decoration: BoxDecoration(
+          color: isSelected ? AppColors.primary : AppColors.surface,
+          borderRadius: BorderRadius.circular(20),
+          border: Border.all(
+            color: isSelected ? AppColors.primary : AppColors.border,
+          ),
+        ),
+        child: Text(
+          label,
+          style: AppTypography.chip.copyWith(
+            color: isSelected ? Colors.white : AppColors.textSecondary,
+            fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
+          ),
+        ),
       ),
     );
   }
@@ -133,9 +187,15 @@ class _AdminAudiobooksScreenState extends ConsumerState<AdminAudiobooksScreen> w
 class _AudiobooksList extends ConsumerWidget {
   final String status;
   final String searchQuery;
+  final bool? contentTypeFilter; // null = all, false = books, true = music
   final VoidCallback onRefresh;
 
-  const _AudiobooksList({required this.status, required this.searchQuery, required this.onRefresh});
+  const _AudiobooksList({
+    required this.status,
+    required this.searchQuery,
+    required this.contentTypeFilter,
+    required this.onRefresh,
+  });
 
   @override
   Widget build(BuildContext context, WidgetRef ref) {
@@ -146,8 +206,15 @@ class _AudiobooksList extends ConsumerWidget {
       error: (e, _) => Center(child: Text('خطا: $e', style: const TextStyle(color: AppColors.error))),
       data: (audiobooks) {
         var filtered = audiobooks;
+
+        // Apply content type filter (Books / Music)
+        if (contentTypeFilter != null) {
+          filtered = filtered.where((book) => book['is_music'] == contentTypeFilter).toList();
+        }
+
+        // Apply search filter
         if (searchQuery.isNotEmpty) {
-          filtered = audiobooks.where((book) {
+          filtered = filtered.where((book) {
             final titleFa = (book['title_fa'] ?? '').toString().toLowerCase();
             final titleEn = (book['title_en'] ?? '').toString().toLowerCase();
             final narrator = book['profiles'] as Map<String, dynamic>?;
@@ -157,13 +224,23 @@ class _AudiobooksList extends ConsumerWidget {
         }
 
         if (filtered.isEmpty) {
+          final isMusic = contentTypeFilter == true;
           return Center(
             child: Column(
               mainAxisAlignment: MainAxisAlignment.center,
               children: [
-                Icon(Icons.library_books_outlined, size: 64, color: AppColors.textTertiary),
+                Icon(
+                  isMusic ? Icons.music_note_outlined : Icons.library_books_outlined,
+                  size: 64,
+                  color: AppColors.textTertiary,
+                ),
                 const SizedBox(height: 16),
-                Text(searchQuery.isEmpty ? 'کتابی یافت نشد' : 'نتیجه‌ای یافت نشد', style: TextStyle(color: AppColors.textSecondary)),
+                Text(
+                  searchQuery.isEmpty
+                      ? (isMusic ? 'موسیقی یافت نشد' : 'کتابی یافت نشد')
+                      : 'نتیجه‌ای یافت نشد',
+                  style: const TextStyle(color: AppColors.textSecondary),
+                ),
               ],
             ),
           );
@@ -188,6 +265,24 @@ class _AudiobookCard extends StatelessWidget {
 
   const _AudiobookCard({required this.audiobook, required this.onAction});
 
+  /// Build row showing author (for books) or artist (for music)
+  Widget _buildCreatorRow(Map<String, dynamic> book) {
+    final isMusic = book['is_music'] == true;
+    final authorFa = book['author_fa'] as String?;
+
+    if (authorFa == null || authorFa.isEmpty) {
+      return const SizedBox.shrink();
+    }
+
+    final label = isMusic ? 'هنرمند' : 'نویسنده';
+    return Text(
+      '$label: $authorFa',
+      style: const TextStyle(color: AppColors.textSecondary, fontSize: 12),
+      maxLines: 1,
+      overflow: TextOverflow.ellipsis,
+    );
+  }
+
   @override
   Widget build(BuildContext context) {
     final narrator = audiobook['profiles'] as Map<String, dynamic>?;
@@ -195,6 +290,7 @@ class _AudiobookCard extends StatelessWidget {
     final status = audiobook['status'] as String? ?? 'draft';
     final isFeatured = audiobook['is_featured'] == true;
     final isPending = status == 'submitted' || status == 'under_review';
+    final isMusic = audiobook['is_music'] == true;
 
     return Card(
       color: AppColors.surface,
@@ -213,13 +309,34 @@ class _AudiobookCard extends StatelessWidget {
               Row(
                 crossAxisAlignment: CrossAxisAlignment.start,
                 children: [
-                  // Cover
-                  ClipRRect(
-                    borderRadius: BorderRadius.circular(8),
-                    child: audiobook['cover_url'] != null
-                        ? Image.network(audiobook['cover_url'] as String, width: 60, height: 80, fit: BoxFit.cover,
-                            errorBuilder: (_, __, ___) => Container(width: 60, height: 80, color: AppColors.surfaceLight, child: const Icon(Icons.book, color: AppColors.textTertiary)))
-                        : Container(width: 60, height: 80, color: AppColors.surfaceLight, child: const Icon(Icons.book, color: AppColors.textTertiary)),
+                  // Cover with content type badge
+                  Stack(
+                    children: [
+                      ClipRRect(
+                        borderRadius: BorderRadius.circular(8),
+                        child: audiobook['cover_url'] != null
+                            ? Image.network(audiobook['cover_url'] as String, width: 60, height: 80, fit: BoxFit.cover,
+                                errorBuilder: (_, __, ___) => Container(width: 60, height: 80, color: AppColors.surfaceLight, child: Icon(isMusic ? Icons.music_note : Icons.book, color: AppColors.textTertiary)))
+                            : Container(width: 60, height: 80, color: AppColors.surfaceLight, child: Icon(isMusic ? Icons.music_note : Icons.book, color: AppColors.textTertiary)),
+                      ),
+                      // Content type badge (top-left)
+                      Positioned(
+                        top: 4,
+                        left: 4,
+                        child: Container(
+                          padding: const EdgeInsets.all(4),
+                          decoration: BoxDecoration(
+                            color: isMusic ? Colors.purple.withOpacity(0.9) : AppColors.primary.withOpacity(0.9),
+                            borderRadius: BorderRadius.circular(4),
+                          ),
+                          child: Icon(
+                            isMusic ? Icons.music_note : Icons.headphones,
+                            color: Colors.white,
+                            size: 12,
+                          ),
+                        ),
+                      ),
+                    ],
                   ),
                   const SizedBox(width: 12),
                   // Info
@@ -236,11 +353,13 @@ class _AudiobookCard extends StatelessWidget {
                           ],
                         ),
                         const SizedBox(height: 4),
-                        Text('گوینده: ${narrator?['display_name'] ?? narrator?['full_name'] ?? 'نامشخص'}', style: TextStyle(color: AppColors.textSecondary, fontSize: 12)),
-                        Text('دسته: ${category?['name_fa'] ?? 'نامشخص'}', style: TextStyle(color: AppColors.textSecondary, fontSize: 12)),
+                        // Show author/artist name based on content type
+                        _buildCreatorRow(audiobook),
+                        Text('گوینده: ${narrator?['display_name'] ?? narrator?['full_name'] ?? 'نامشخص'}', style: const TextStyle(color: AppColors.textSecondary, fontSize: 12)),
+                        Text('دسته: ${category?['name_fa'] ?? 'نامشخص'}', style: const TextStyle(color: AppColors.textSecondary, fontSize: 12)),
                         Row(
                           children: [
-                            Text(audiobook['is_free'] == true ? 'رایگان' : '${(audiobook['price_toman'] as num?) ?? 0}', style: TextStyle(color: AppColors.primary, fontSize: 12)),
+                            Text(audiobook['is_free'] == true ? 'رایگان' : '${(audiobook['price_toman'] as num?) ?? 0}', style: const TextStyle(color: AppColors.primary, fontSize: 12)),
                             const Spacer(),
                             _StatusBadge(status: status),
                           ],
@@ -252,6 +371,19 @@ class _AudiobookCard extends StatelessWidget {
               ),
               if (isPending) ...[
                 const SizedBox(height: 12),
+                // Show "Start Review" button if status is 'submitted'
+                if (status == 'submitted') ...[
+                  SizedBox(
+                    width: double.infinity,
+                    child: OutlinedButton.icon(
+                      onPressed: () => _markUnderReview(context),
+                      icon: const Icon(Icons.visibility, size: 18),
+                      label: const Text('شروع بررسی'),
+                      style: OutlinedButton.styleFrom(foregroundColor: Colors.blue, side: const BorderSide(color: Colors.blue)),
+                    ),
+                  ),
+                  const SizedBox(height: 8),
+                ],
                 Row(
                   children: [
                     Expanded(
@@ -295,7 +427,29 @@ class _AudiobookCard extends StatelessWidget {
     );
   }
 
+  Future<void> _markUnderReview(BuildContext context) async {
+    FocusScope.of(context).unfocus();
+
+    try {
+      await Supabase.instance.client.from('audiobooks').update({
+        'status': 'under_review',
+      }).eq('id', audiobook['id'] as Object);
+
+      if (context.mounted) {
+        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('وضعیت به "در حال بررسی" تغییر کرد'), backgroundColor: Colors.blue));
+        onAction();
+      }
+    } catch (e) {
+      if (context.mounted) {
+        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('خطا: $e'), backgroundColor: AppColors.error));
+      }
+    }
+  }
+
   Future<void> _approveAudiobook(BuildContext context) async {
+    // Dismiss keyboard before showing feedback
+    FocusScope.of(context).unfocus();
+
     try {
       await Supabase.instance.client.from('audiobooks').update({
         'status': 'approved',
@@ -315,21 +469,27 @@ class _AudiobookCard extends StatelessWidget {
   }
 
   Future<void> _showRejectDialog(BuildContext context) async {
+    // Dismiss keyboard before showing dialog
+    FocusScope.of(context).unfocus();
+
     final reasonController = TextEditingController();
     final result = await showDialog<bool>(
       context: context,
-      builder: (context) => AlertDialog(
-        backgroundColor: AppColors.surface,
-        title: const Text('رد کتاب', style: TextStyle(color: AppColors.textPrimary)),
-        content: TextField(
-          controller: reasonController,
-          maxLines: 3,
-          decoration: InputDecoration(labelText: 'دلیل رد', hintText: 'دلیل رد کتاب را بنویسید...', filled: true, fillColor: AppColors.background, border: OutlineInputBorder(borderRadius: BorderRadius.circular(8))),
+      builder: (context) => Directionality(
+        textDirection: TextDirection.rtl,
+        child: AlertDialog(
+          backgroundColor: AppColors.surface,
+          title: const Text('رد کتاب', style: TextStyle(color: AppColors.textPrimary)),
+          content: TextField(
+            controller: reasonController,
+            maxLines: 3,
+            decoration: InputDecoration(labelText: 'دلیل رد', hintText: 'دلیل رد کتاب را بنویسید...', filled: true, fillColor: AppColors.background, border: OutlineInputBorder(borderRadius: BorderRadius.circular(8))),
+          ),
+          actions: [
+            TextButton(onPressed: () => Navigator.pop(context, false), child: const Text('انصراف')),
+            ElevatedButton(onPressed: () => Navigator.pop(context, true), style: ElevatedButton.styleFrom(backgroundColor: AppColors.error), child: const Text('رد کتاب')),
+          ],
         ),
-        actions: [
-          TextButton(onPressed: () => Navigator.pop(context, false), child: const Text('انصراف')),
-          ElevatedButton(onPressed: () => Navigator.pop(context, true), style: ElevatedButton.styleFrom(backgroundColor: AppColors.error), child: const Text('رد کتاب')),
-        ],
       ),
     );
 
@@ -363,17 +523,45 @@ class _StatusBadge extends StatelessWidget {
   Widget build(BuildContext context) {
     Color color;
     String label;
+    IconData icon;
     switch (status) {
-      case 'approved': color = AppColors.success; label = 'تأیید شده'; break;
-      case 'rejected': color = AppColors.error; label = 'رد شده'; break;
-      case 'submitted': color = AppColors.warning; label = 'ارسال شده'; break;
-      case 'under_review': color = Colors.orange; label = 'در حال بررسی'; break;
-      case 'draft': default: color = AppColors.textTertiary; label = 'پیش‌نویس';
+      case 'approved':
+        color = AppColors.success;
+        label = 'منتشر شده';
+        icon = Icons.check_circle;
+        break;
+      case 'rejected':
+        color = AppColors.error;
+        label = 'رد شده';
+        icon = Icons.cancel;
+        break;
+      case 'submitted':
+        color = AppColors.warning;
+        label = 'ارسال شده';
+        icon = Icons.schedule;
+        break;
+      case 'under_review':
+        color = Colors.blue;
+        label = 'در حال بررسی';
+        icon = Icons.visibility;
+        break;
+      case 'draft':
+      default:
+        color = AppColors.textTertiary;
+        label = 'پیش‌نویس';
+        icon = Icons.edit_note;
     }
     return Container(
       padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
       decoration: BoxDecoration(color: color.withOpacity(0.15), borderRadius: BorderRadius.circular(6)),
-      child: Text(label, style: TextStyle(color: color, fontSize: 12, fontWeight: FontWeight.w600)),
+      child: Row(
+        mainAxisSize: MainAxisSize.min,
+        children: [
+          Icon(icon, size: 12, color: color),
+          const SizedBox(width: 4),
+          Text(label, style: TextStyle(color: color, fontSize: 12, fontWeight: FontWeight.w600)),
+        ],
+      ),
     );
   }
 }
\ No newline at end of file
diff --git a/lib/screens/admin/admin_banner_form_screen.dart b/lib/screens/admin/admin_banner_form_screen.dart
index 40e5366..e52462f 100644
--- a/lib/screens/admin/admin_banner_form_screen.dart
+++ b/lib/screens/admin/admin_banner_form_screen.dart
@@ -174,10 +174,14 @@ class _AdminBannerFormScreenState extends ConsumerState<AdminBannerFormScreen> {
     try {
       // Upload image if selected
       String? imageUrl = _imageUrlController.text.trim();
+      String? newImagePath; // Track new image for cleanup if DB fails
+
       if (_newImageBytes != null) {
         final uploadedUrl = await _uploadBannerImage();
         if (uploadedUrl != null) {
           imageUrl = uploadedUrl;
+          // Extract path for potential cleanup
+          newImagePath = 'banners/banner_${DateTime.now().millisecondsSinceEpoch}.jpg';
         } else {
           // Upload failed
           setState(() => _isLoading = false);
@@ -195,13 +199,24 @@ class _AdminBannerFormScreenState extends ConsumerState<AdminBannerFormScreen> {
         'is_active': _isActive,
       };
 
-      if (_isEditing) {
-        await Supabase.instance.client
-            .from('promo_banners')
-            .update(data)
-            .eq('id', widget.banner!['id'] as Object);
-      } else {
-        await Supabase.instance.client.from('promo_banners').insert(data);
+      // Save to DB - with orphan image cleanup on failure
+      try {
+        if (_isEditing) {
+          await Supabase.instance.client
+              .from('promo_banners')
+              .update(data)
+              .eq('id', widget.banner!['id'] as Object);
+        } else {
+          await Supabase.instance.client.from('promo_banners').insert(data);
+        }
+      } catch (dbError) {
+        // DB operation failed - clean up newly uploaded image if any
+        if (newImagePath != null) {
+          try {
+            await Supabase.instance.client.storage.from(Env.coversBucket).remove([newImagePath]);
+          } catch (_) {}
+        }
+        rethrow;
       }
 
       if (mounted) {
@@ -433,7 +448,7 @@ class _AdminBannerFormScreenState extends ConsumerState<AdminBannerFormScreen> {
                                     (book['title_fa'] as String?) ?? '',
                                     style: const TextStyle(color: AppColors.textPrimary),
                                   ),
-                                  subtitle: Text('ID: ${book['id']}', style: TextStyle(color: AppColors.textTertiary, fontSize: 11)),
+                                  subtitle: Text('ID: ${book['id']}', style: const TextStyle(color: AppColors.textTertiary, fontSize: 11)),
                                   onTap: () {
                                     setState(() {
                                       _selectedAudiobook = book;
@@ -527,7 +542,7 @@ class _AdminBannerFormScreenState extends ConsumerState<AdminBannerFormScreen> {
                           title: const Text('فعال', style: TextStyle(color: AppColors.textPrimary)),
                           subtitle: Text(
                             _isActive ? 'بنر در صفحه اصلی نمایش داده می‌شود' : 'بنر مخفی است',
-                            style: TextStyle(color: AppColors.textSecondary, fontSize: 12),
+                            style: const TextStyle(color: AppColors.textSecondary, fontSize: 12),
                           ),
                           value: _isActive,
                           onChanged: (v) => setState(() => _isActive = v),
diff --git a/lib/screens/admin/admin_bulk_chapter_upload_screen.dart b/lib/screens/admin/admin_bulk_chapter_upload_screen.dart
index e23c060..970eb2a 100644
--- a/lib/screens/admin/admin_bulk_chapter_upload_screen.dart
+++ b/lib/screens/admin/admin_bulk_chapter_upload_screen.dart
@@ -53,7 +53,7 @@ class AdminBulkChapterUploadScreen extends ConsumerStatefulWidget {
 }
 
 class _AdminBulkChapterUploadScreenState extends ConsumerState<AdminBulkChapterUploadScreen> {
-  List<ChapterToUpload> _chapters = [];
+  final List<ChapterToUpload> _chapters = [];
   bool _isSelectingFiles = false;
   bool _isUploading = false;
   String? _error;
@@ -227,20 +227,31 @@ class _AdminBulkChapterUploadScreenState extends ConsumerState<AdminBulkChapterU
 
           setState(() => chapter.uploadProgress = 0.6);
 
-          // Create chapter record
+          // Create chapter record - with orphan file cleanup on failure
           final chapterIndex = _existingChapterCount + _uploadedCount + 1;
 
-          await Supabase.instance.client.from('chapters').insert({
-            'audiobook_id': widget.audiobookId,
-            'title_fa': chapter.titleFa.trim(),
-            'title_en': chapter.titleEn?.trim().isEmpty == true ? null : chapter.titleEn?.trim(),
-            'chapter_index': chapterIndex,
-            'audio_storage_path': path,
-            'duration_seconds': 0,
-            'file_size_bytes': chapter.fileSize,
-            'audio_format': extension,
-            'is_preview': chapter.isPreview,
-          });
+          try {
+            await Supabase.instance.client.from('chapters').insert({
+              'audiobook_id': widget.audiobookId,
+              'title_fa': chapter.titleFa.trim(),
+              'title_en': chapter.titleEn?.trim().isEmpty == true ? null : chapter.titleEn?.trim(),
+              'chapter_index': chapterIndex,
+              'audio_storage_path': path,
+              'duration_seconds': 0,
+              'file_size_bytes': chapter.fileSize,
+              'audio_format': extension,
+              'is_preview': chapter.isPreview,
+            });
+          } catch (dbError) {
+            // DB insert failed - clean up orphan file from storage
+            AppLogger.w('Admin bulk chapter DB insert failed, cleaning up uploaded file: $path');
+            try {
+              await Supabase.instance.client.storage.from(Env.audioBucket).remove([path]);
+            } catch (cleanupError) {
+              AppLogger.e('Failed to cleanup orphan audio file: $path', error: cleanupError);
+            }
+            rethrow;
+          }
 
           setState(() {
             chapter.uploadProgress = 1.0;
@@ -252,7 +263,7 @@ class _AdminBulkChapterUploadScreenState extends ConsumerState<AdminBulkChapterU
           AppLogger.e('Chapter upload error', error: e);
           setState(() {
             chapter.isUploading = false;
-            chapter.error = e.toString();
+            chapter.error = AudioValidator.getUploadErrorMessage(e);
           });
         }
       }
@@ -286,7 +297,7 @@ class _AdminBulkChapterUploadScreenState extends ConsumerState<AdminBulkChapterU
       }
     } catch (e) {
       AppLogger.e('Bulk upload error', error: e);
-      setState(() => _error = e.toString());
+      setState(() => _error = AudioValidator.getUploadErrorMessage(e));
     } finally {
       setState(() => _isUploading = false);
     }
@@ -334,7 +345,7 @@ class _AdminBulkChapterUploadScreenState extends ConsumerState<AdminBulkChapterU
                               const SizedBox(height: 2),
                               Text(
                                 Formatters.formatFileSize(chapter.fileSize),
-                                style: TextStyle(
+                                style: const TextStyle(
                                   fontSize: 11,
                                   color: AppColors.textTertiary,
                                 ),
@@ -381,7 +392,7 @@ class _AdminBulkChapterUploadScreenState extends ConsumerState<AdminBulkChapterU
                       const Text('نمونه رایگان'),
                     ],
                   ),
-                  Text(
+                  const Text(
                     'فصل‌های نمونه برای همه کاربران قابل پخش است',
                     style: TextStyle(
                       fontSize: 11,
@@ -455,7 +466,7 @@ class _AdminBulkChapterUploadScreenState extends ConsumerState<AdminBulkChapterU
               color: AppColors.surface,
               child: Row(
                 children: [
-                  Icon(
+                  const Icon(
                     Icons.library_music,
                     color: AppColors.primary,
                     size: 24,
@@ -475,7 +486,7 @@ class _AdminBulkChapterUploadScreenState extends ConsumerState<AdminBulkChapterU
                         if (_uploadedCount > 0)
                           Text(
                             '$_uploadedCount فصل آپلود شده',
-                            style: TextStyle(
+                            style: const TextStyle(
                               color: AppColors.success,
                               fontSize: 12,
                             ),
@@ -633,13 +644,13 @@ class _AdminBulkChapterUploadScreenState extends ConsumerState<AdminBulkChapterU
                 borderRadius: BorderRadius.circular(12),
                 border: Border.all(color: AppColors.border),
               ),
-              child: Column(
+              child: const Column(
                 children: [
                   Row(
                     children: [
                       Icon(Icons.info_outline, color: AppColors.primary, size: 20),
-                      const SizedBox(width: 8),
-                      const Text(
+                      SizedBox(width: 8),
+                      Text(
                         'فرمت‌های مجاز',
                         style: TextStyle(
                           color: AppColors.textPrimary,
@@ -648,9 +659,9 @@ class _AdminBulkChapterUploadScreenState extends ConsumerState<AdminBulkChapterU
                       ),
                     ],
                   ),
-                  const SizedBox(height: 8),
+                  SizedBox(height: 8),
                   Text(
-                    'MP3 یا M4A • حداکثر ۵۰ مگابایت • حداکثر ۶۰ دقیقه',
+                    'MP3 یا M4A • حداکثر ${AudioValidator.kServerMaxFileSizeMB} مگابایت • حداکثر ۲۴۰ دقیقه',
                     style: TextStyle(
                       color: AppColors.textSecondary,
                       fontSize: 12,
@@ -735,7 +746,7 @@ class _AdminBulkChapterUploadScreenState extends ConsumerState<AdminBulkChapterU
               children: [
                 Text(
                   Formatters.formatFileSize(chapter.fileSize),
-                  style: TextStyle(color: AppColors.textTertiary, fontSize: 12),
+                  style: const TextStyle(color: AppColors.textTertiary, fontSize: 12),
                 ),
                 if (chapter.isPreview) ...[
                   const SizedBox(width: 8),
@@ -753,7 +764,7 @@ class _AdminBulkChapterUploadScreenState extends ConsumerState<AdminBulkChapterU
                 ],
                 if (chapter.error != null) ...[
                   const SizedBox(width: 8),
-                  Expanded(
+                  const Expanded(
                     child: Text(
                       'خطا',
                       style: TextStyle(color: AppColors.error, fontSize: 11),
diff --git a/lib/screens/admin/admin_categories_screen.dart b/lib/screens/admin/admin_categories_screen.dart
index 85253c0..14470e7 100644
--- a/lib/screens/admin/admin_categories_screen.dart
+++ b/lib/screens/admin/admin_categories_screen.dart
@@ -3,18 +3,42 @@ import 'package:flutter_riverpod/flutter_riverpod.dart';
 import 'package:supabase_flutter/supabase_flutter.dart';
 import 'package:myna/theme/app_theme.dart';
 
+/// Provider for book categories
 final adminCategoriesProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
   final response = await Supabase.instance.client.from('categories').select('*').order('sort_order');
   return List<Map<String, dynamic>>.from(response);
 });
 
-class AdminCategoriesScreen extends ConsumerWidget {
+/// Provider for music categories (سبک‌های موسیقی)
+final adminMusicCategoriesProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
+  final response = await Supabase.instance.client.from('music_categories').select('*').order('sort_order');
+  return List<Map<String, dynamic>>.from(response);
+});
+
+class AdminCategoriesScreen extends ConsumerStatefulWidget {
   const AdminCategoriesScreen({super.key});
 
   @override
-  Widget build(BuildContext context, WidgetRef ref) {
-    final categoriesAsync = ref.watch(adminCategoriesProvider);
+  ConsumerState<AdminCategoriesScreen> createState() => _AdminCategoriesScreenState();
+}
+
+class _AdminCategoriesScreenState extends ConsumerState<AdminCategoriesScreen> with SingleTickerProviderStateMixin {
+  late TabController _tabController;
+
+  @override
+  void initState() {
+    super.initState();
+    _tabController = TabController(length: 2, vsync: this);
+  }
 
+  @override
+  void dispose() {
+    _tabController.dispose();
+    super.dispose();
+  }
+
+  @override
+  Widget build(BuildContext context) {
     return Directionality(
       textDirection: TextDirection.rtl,
       child: Scaffold(
@@ -24,59 +48,198 @@ class AdminCategoriesScreen extends ConsumerWidget {
           title: const Text('مدیریت دسته‌بندی‌ها'),
           centerTitle: true,
           actions: [
-            IconButton(icon: const Icon(Icons.refresh), onPressed: () => ref.invalidate(adminCategoriesProvider)),
+            IconButton(
+              icon: const Icon(Icons.refresh),
+              onPressed: () {
+                ref.invalidate(adminCategoriesProvider);
+                ref.invalidate(adminMusicCategoriesProvider);
+              },
+            ),
           ],
+          bottom: TabBar(
+            controller: _tabController,
+            indicatorColor: AppColors.primary,
+            labelColor: AppColors.primary,
+            unselectedLabelColor: AppColors.textSecondary,
+            tabs: const [
+              Tab(icon: Icon(Icons.menu_book), text: 'کتاب‌ها'),
+              Tab(icon: Icon(Icons.music_note), text: 'موسیقی'),
+            ],
+          ),
         ),
         floatingActionButton: FloatingActionButton(
-          onPressed: () => _showAddEditDialog(context, ref, null),
+          onPressed: () {
+            if (_tabController.index == 0) {
+              _showBookCategoryDialog(context, null);
+            } else {
+              _showMusicCategoryDialog(context, null);
+            }
+          },
           backgroundColor: AppColors.primary,
           child: const Icon(Icons.add),
         ),
-        body: categoriesAsync.when(
-          loading: () => const Center(child: CircularProgressIndicator(color: AppColors.primary)),
-          error: (e, _) => Center(child: Text('خطا: $e', style: const TextStyle(color: AppColors.error))),
-          data: (categories) {
-            if (categories.isEmpty) {
-              return const Center(child: Text('دسته‌بندی یافت نشد', style: TextStyle(color: AppColors.textSecondary)));
-            }
-            return ReorderableListView.builder(
-              padding: const EdgeInsets.all(16),
-              itemCount: categories.length,
-              onReorder: (oldIndex, newIndex) => _reorder(ref, categories, oldIndex, newIndex),
-              itemBuilder: (context, index) {
-                final cat = categories[index];
-                return Card(
-                  key: ValueKey(cat['id']),
-                  color: AppColors.surface,
-                  margin: const EdgeInsets.only(bottom: 8),
-                  child: ListTile(
-                    leading: Container(
-                      width: 40,
-                      height: 40,
-                      decoration: BoxDecoration(color: AppColors.primary.withOpacity(0.1), borderRadius: BorderRadius.circular(8)),
-                      child: Center(child: Text('${index + 1}', style: const TextStyle(color: AppColors.primary, fontWeight: FontWeight.bold))),
-                    ),
-                    title: Text((cat['name_fa'] as String?) ?? '', style: const TextStyle(color: AppColors.textPrimary)),
-                    subtitle: Text((cat['is_active'] as bool?) == true ? 'فعال' : 'غیرفعال', style: TextStyle(color: (cat['is_active'] as bool?) == true ? AppColors.success : AppColors.error, fontSize: 12)),
-                    trailing: Row(
-                      mainAxisSize: MainAxisSize.min,
-                      children: [
-                        IconButton(icon: const Icon(Icons.edit, color: AppColors.primary), onPressed: () => _showAddEditDialog(context, ref, cat)),
-                        IconButton(icon: const Icon(Icons.delete, color: AppColors.error), onPressed: () => _deleteCategory(context, ref, cat['id'] as int)),
-                        const Icon(Icons.drag_handle, color: AppColors.textTertiary),
-                      ],
-                    ),
-                  ),
-                );
-              },
-            );
-          },
+        body: TabBarView(
+          controller: _tabController,
+          children: [
+            _buildBookCategoriesTab(),
+            _buildMusicCategoriesTab(),
+          ],
         ),
       ),
     );
   }
 
-  Future<void> _showAddEditDialog(BuildContext context, WidgetRef ref, Map<String, dynamic>? category) async {
+  /// Book categories tab
+  Widget _buildBookCategoriesTab() {
+    final categoriesAsync = ref.watch(adminCategoriesProvider);
+
+    return categoriesAsync.when(
+      loading: () => const Center(child: CircularProgressIndicator(color: AppColors.primary)),
+      error: (e, _) => Center(child: Text('خطا: $e', style: const TextStyle(color: AppColors.error))),
+      data: (categories) {
+        return RefreshIndicator(
+          onRefresh: () async => ref.invalidate(adminCategoriesProvider),
+          color: AppColors.primary,
+          child: categories.isEmpty
+              ? ListView(
+                  physics: const AlwaysScrollableScrollPhysics(),
+                  children: [
+                    SizedBox(
+                      height: MediaQuery.of(context).size.height * 0.6,
+                      child: const Center(
+                        child: Text('دسته‌بندی کتاب یافت نشد', style: TextStyle(color: AppColors.textSecondary)),
+                      ),
+                    ),
+                  ],
+                )
+              : ReorderableListView.builder(
+                  padding: const EdgeInsets.all(16),
+                  itemCount: categories.length,
+                  onReorder: (oldIndex, newIndex) => _reorderBookCategories(categories, oldIndex, newIndex),
+                  itemBuilder: (context, index) {
+                    final cat = categories[index];
+                    return Card(
+                      key: ValueKey('book_${cat['id']}'),
+                      color: AppColors.surface,
+                      margin: const EdgeInsets.only(bottom: 8),
+                      child: ListTile(
+                        leading: Container(
+                          width: 40,
+                          height: 40,
+                          decoration: BoxDecoration(color: AppColors.primary.withOpacity(0.1), borderRadius: BorderRadius.circular(8)),
+                          child: Center(child: Text('${index + 1}', style: const TextStyle(color: AppColors.primary, fontWeight: FontWeight.bold))),
+                        ),
+                        title: Text((cat['name_fa'] as String?) ?? '', style: const TextStyle(color: AppColors.textPrimary)),
+                        subtitle: Text((cat['is_active'] as bool?) == true ? 'فعال' : 'غیرفعال', style: TextStyle(color: (cat['is_active'] as bool?) == true ? AppColors.success : AppColors.error, fontSize: 12)),
+                        trailing: Row(
+                          mainAxisSize: MainAxisSize.min,
+                          children: [
+                            IconButton(icon: const Icon(Icons.edit, color: AppColors.primary), onPressed: () => _showBookCategoryDialog(context, cat)),
+                            IconButton(icon: const Icon(Icons.delete, color: AppColors.error), onPressed: () => _deleteBookCategory(context, cat['id'] as int)),
+                            const Icon(Icons.drag_handle, color: AppColors.textTertiary),
+                          ],
+                        ),
+                      ),
+                    );
+                  },
+                ),
+        );
+      },
+    );
+  }
+
+  /// Music categories tab
+  Widget _buildMusicCategoriesTab() {
+    final musicCategoriesAsync = ref.watch(adminMusicCategoriesProvider);
+
+    return musicCategoriesAsync.when(
+      loading: () => const Center(child: CircularProgressIndicator(color: AppColors.primary)),
+      error: (e, _) => Center(child: Text('خطا: $e', style: const TextStyle(color: AppColors.error))),
+      data: (categories) {
+        return RefreshIndicator(
+          onRefresh: () async => ref.invalidate(adminMusicCategoriesProvider),
+          color: AppColors.primary,
+          child: categories.isEmpty
+              ? ListView(
+                  physics: const AlwaysScrollableScrollPhysics(),
+                  children: [
+                    SizedBox(
+                      height: MediaQuery.of(context).size.height * 0.6,
+                      child: Center(
+                        child: Column(
+                          mainAxisAlignment: MainAxisAlignment.center,
+                          children: [
+                            Icon(Icons.music_off, size: 64, color: AppColors.textTertiary.withOpacity(0.5)),
+                            const SizedBox(height: 16),
+                            const Text('سبک موسیقی یافت نشد', style: TextStyle(color: AppColors.textSecondary)),
+                            const SizedBox(height: 8),
+                            TextButton.icon(
+                              onPressed: () => _showMusicCategoryDialog(context, null),
+                              icon: const Icon(Icons.add),
+                              label: const Text('افزودن سبک جدید'),
+                            ),
+                          ],
+                        ),
+                      ),
+                    ),
+                  ],
+                )
+              : ReorderableListView.builder(
+                  padding: const EdgeInsets.all(16),
+                  itemCount: categories.length,
+                  onReorder: (oldIndex, newIndex) => _reorderMusicCategories(categories, oldIndex, newIndex),
+                  itemBuilder: (context, index) {
+                    final cat = categories[index];
+                    final icon = cat['icon'] as String? ?? '🎵';
+                    return Card(
+                      key: ValueKey('music_${cat['id']}'),
+                      color: AppColors.surface,
+                      margin: const EdgeInsets.only(bottom: 8),
+                      child: ListTile(
+                        leading: Container(
+                          width: 40,
+                          height: 40,
+                          decoration: BoxDecoration(color: AppColors.primary.withOpacity(0.1), borderRadius: BorderRadius.circular(8)),
+                          child: Center(child: Text(icon, style: const TextStyle(fontSize: 20))),
+                        ),
+                        title: Text((cat['name_fa'] as String?) ?? '', style: const TextStyle(color: AppColors.textPrimary)),
+                        subtitle: Row(
+                          children: [
+                            Text(
+                              (cat['is_active'] as bool?) == true ? 'فعال' : 'غیرفعال',
+                              style: TextStyle(
+                                color: (cat['is_active'] as bool?) == true ? AppColors.success : AppColors.error,
+                                fontSize: 12,
+                              ),
+                            ),
+                            if ((cat['name_en'] as String?)?.isNotEmpty == true) ...[
+                              const SizedBox(width: 8),
+                              Text(
+                                '(${cat['name_en']})',
+                                style: const TextStyle(color: AppColors.textTertiary, fontSize: 11),
+                              ),
+                            ],
+                          ],
+                        ),
+                        trailing: Row(
+                          mainAxisSize: MainAxisSize.min,
+                          children: [
+                            IconButton(icon: const Icon(Icons.edit, color: AppColors.primary), onPressed: () => _showMusicCategoryDialog(context, cat)),
+                            IconButton(icon: const Icon(Icons.delete, color: AppColors.error), onPressed: () => _deleteMusicCategory(context, cat['id'] as int)),
+                            const Icon(Icons.drag_handle, color: AppColors.textTertiary),
+                          ],
+                        ),
+                      ),
+                    );
+                  },
+                ),
+        );
+      },
+    );
+  }
+
+  /// Dialog for adding/editing book categories
+  Future<void> _showBookCategoryDialog(BuildContext context, Map<String, dynamic>? category) async {
     final nameController = TextEditingController(text: (category?['name_fa'] as String?) ?? '');
     bool isActive = (category?['is_active'] as bool?) ?? true;
 
@@ -85,7 +248,7 @@ class AdminCategoriesScreen extends ConsumerWidget {
       builder: (context) => StatefulBuilder(
         builder: (context, setState) => AlertDialog(
           backgroundColor: AppColors.surface,
-          title: Text(category == null ? 'افزودن دسته‌بندی' : 'ویرایش دسته‌بندی', style: const TextStyle(color: AppColors.textPrimary)),
+          title: Text(category == null ? 'افزودن دسته‌بندی کتاب' : 'ویرایش دسته‌بندی کتاب', style: const TextStyle(color: AppColors.textPrimary)),
           content: Column(
             mainAxisSize: MainAxisSize.min,
             children: [
@@ -131,19 +294,165 @@ class AdminCategoriesScreen extends ConsumerWidget {
         }
         ref.invalidate(adminCategoriesProvider);
         if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('ذخیره شد'), backgroundColor: AppColors.success));
+      } on PostgrestException catch (e) {
+        // Handle unique constraint violation (duplicate slug/name)
+        if (e.code == '23505') {
+          if (context.mounted) {
+            ScaffoldMessenger.of(context).showSnackBar(
+              const SnackBar(
+                content: Text('این دسته‌بندی یا نام مشابه آن از قبل وجود دارد.'),
+                backgroundColor: AppColors.error,
+              ),
+            );
+          }
+        } else {
+          if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('خطا: ${e.message}'), backgroundColor: AppColors.error));
+        }
+      } catch (e) {
+        if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('خطا: $e'), backgroundColor: AppColors.error));
+      }
+    }
+  }
+
+  /// Dialog for adding/editing music categories
+  Future<void> _showMusicCategoryDialog(BuildContext context, Map<String, dynamic>? category) async {
+    final nameFaController = TextEditingController(text: (category?['name_fa'] as String?) ?? '');
+    final nameEnController = TextEditingController(text: (category?['name_en'] as String?) ?? '');
+    final iconController = TextEditingController(text: (category?['icon'] as String?) ?? '🎵');
+    bool isActive = (category?['is_active'] as bool?) ?? true;
+
+    final result = await showDialog<bool>(
+      context: context,
+      builder: (context) => StatefulBuilder(
+        builder: (context, setState) => AlertDialog(
+          backgroundColor: AppColors.surface,
+          title: Text(
+            category == null ? 'افزودن سبک موسیقی' : 'ویرایش سبک موسیقی',
+            style: const TextStyle(color: AppColors.textPrimary),
+          ),
+          content: SingleChildScrollView(
+            child: Column(
+              mainAxisSize: MainAxisSize.min,
+              children: [
+                // Icon selector
+                Row(
+                  children: [
+                    Container(
+                      width: 60,
+                      height: 60,
+                      decoration: BoxDecoration(
+                        color: AppColors.primary.withOpacity(0.1),
+                        borderRadius: BorderRadius.circular(12),
+                      ),
+                      child: Center(
+                        child: Text(
+                          iconController.text.isNotEmpty ? iconController.text : '🎵',
+                          style: const TextStyle(fontSize: 32),
+                        ),
+                      ),
+                    ),
+                    const SizedBox(width: 12),
+                    Expanded(
+                      child: TextField(
+                        controller: iconController,
+                        decoration: InputDecoration(
+                          labelText: 'آیکون (ایموجی)',
+                          hintText: '🎵',
+                          filled: true,
+                          fillColor: AppColors.background,
+                          border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
+                        ),
+                        onChanged: (_) => setState(() {}),
+                      ),
+                    ),
+                  ],
+                ),
+                const SizedBox(height: 16),
+                TextField(
+                  controller: nameFaController,
+                  decoration: InputDecoration(
+                    labelText: 'نام فارسی *',
+                    hintText: 'مثال: پاپ',
+                    filled: true,
+                    fillColor: AppColors.background,
+                    border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
+                  ),
+                ),
+                const SizedBox(height: 12),
+                TextField(
+                  controller: nameEnController,
+                  decoration: InputDecoration(
+                    labelText: 'نام انگلیسی (اختیاری)',
+                    hintText: 'Example: Pop',
+                    filled: true,
+                    fillColor: AppColors.background,
+                    border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
+                  ),
+                  textDirection: TextDirection.ltr,
+                ),
+                const SizedBox(height: 12),
+                SwitchListTile(
+                  title: const Text('فعال', style: TextStyle(color: AppColors.textPrimary)),
+                  subtitle: const Text('نمایش در لیست انتخاب', style: TextStyle(color: AppColors.textSecondary, fontSize: 12)),
+                  value: isActive,
+                  onChanged: (v) => setState(() => isActive = v),
+                  activeColor: AppColors.primary,
+                ),
+              ],
+            ),
+          ),
+          actions: [
+            TextButton(onPressed: () => Navigator.pop(context, false), child: const Text('انصراف')),
+            ElevatedButton(onPressed: () => Navigator.pop(context, true), child: Text(category == null ? 'افزودن' : 'ذخیره')),
+          ],
+        ),
+      ),
+    );
+
+    if (result == true && nameFaController.text.trim().isNotEmpty) {
+      try {
+        final data = {
+          'name_fa': nameFaController.text.trim(),
+          'name_en': nameEnController.text.trim().isEmpty ? null : nameEnController.text.trim(),
+          'icon': iconController.text.trim().isEmpty ? '🎵' : iconController.text.trim(),
+          'is_active': isActive,
+        };
+
+        if (category == null) {
+          data['sort_order'] = 999;
+          await Supabase.instance.client.from('music_categories').insert(data);
+        } else {
+          await Supabase.instance.client.from('music_categories').update(data).eq('id', category['id'] as int);
+        }
+        ref.invalidate(adminMusicCategoriesProvider);
+        if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('ذخیره شد'), backgroundColor: AppColors.success));
+      } on PostgrestException catch (e) {
+        // Handle unique constraint violation (duplicate slug/name)
+        if (e.code == '23505') {
+          if (context.mounted) {
+            ScaffoldMessenger.of(context).showSnackBar(
+              const SnackBar(
+                content: Text('این سبک موسیقی یا نام مشابه آن از قبل وجود دارد.'),
+                backgroundColor: AppColors.error,
+              ),
+            );
+          }
+        } else {
+          if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('خطا: ${e.message}'), backgroundColor: AppColors.error));
+        }
       } catch (e) {
         if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('خطا: $e'), backgroundColor: AppColors.error));
       }
     }
   }
 
-  Future<void> _deleteCategory(BuildContext context, WidgetRef ref, int id) async {
+  Future<void> _deleteBookCategory(BuildContext context, int id) async {
     final confirm = await showDialog<bool>(
       context: context,
       builder: (context) => AlertDialog(
         backgroundColor: AppColors.surface,
         title: const Text('حذف دسته‌بندی', style: TextStyle(color: AppColors.error)),
-        content: const Text('آیا مطمئن هستید؟', style: TextStyle(color: AppColors.textPrimary)),
+        content: const Text('آیا مطمئن هستید؟ این عملیات قابل بازگشت نیست.', style: TextStyle(color: AppColors.textPrimary)),
         actions: [
           TextButton(onPressed: () => Navigator.pop(context, false), child: const Text('انصراف')),
           ElevatedButton(onPressed: () => Navigator.pop(context, true), style: ElevatedButton.styleFrom(backgroundColor: AppColors.error), child: const Text('حذف')),
@@ -162,7 +471,32 @@ class AdminCategoriesScreen extends ConsumerWidget {
     }
   }
 
-  Future<void> _reorder(WidgetRef ref, List<Map<String, dynamic>> categories, int oldIndex, int newIndex) async {
+  Future<void> _deleteMusicCategory(BuildContext context, int id) async {
+    final confirm = await showDialog<bool>(
+      context: context,
+      builder: (context) => AlertDialog(
+        backgroundColor: AppColors.surface,
+        title: const Text('حذف سبک موسیقی', style: TextStyle(color: AppColors.error)),
+        content: const Text('آیا مطمئن هستید؟ این عملیات قابل بازگشت نیست.', style: TextStyle(color: AppColors.textPrimary)),
+        actions: [
+          TextButton(onPressed: () => Navigator.pop(context, false), child: const Text('انصراف')),
+          ElevatedButton(onPressed: () => Navigator.pop(context, true), style: ElevatedButton.styleFrom(backgroundColor: AppColors.error), child: const Text('حذف')),
+        ],
+      ),
+    );
+
+    if (confirm == true) {
+      try {
+        await Supabase.instance.client.from('music_categories').delete().eq('id', id);
+        ref.invalidate(adminMusicCategoriesProvider);
+        if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('حذف شد'), backgroundColor: AppColors.success));
+      } catch (e) {
+        if (context.mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('خطا: $e'), backgroundColor: AppColors.error));
+      }
+    }
+  }
+
+  Future<void> _reorderBookCategories(List<Map<String, dynamic>> categories, int oldIndex, int newIndex) async {
     if (newIndex > oldIndex) newIndex--;
     final item = categories.removeAt(oldIndex);
     categories.insert(newIndex, item);
@@ -176,4 +510,19 @@ class AdminCategoriesScreen extends ConsumerWidget {
       ref.invalidate(adminCategoriesProvider);
     }
   }
-}
\ No newline at end of file
+
+  Future<void> _reorderMusicCategories(List<Map<String, dynamic>> categories, int oldIndex, int newIndex) async {
+    if (newIndex > oldIndex) newIndex--;
+    final item = categories.removeAt(oldIndex);
+    categories.insert(newIndex, item);
+
+    try {
+      for (int i = 0; i < categories.length; i++) {
+        await Supabase.instance.client.from('music_categories').update({'sort_order': i}).eq('id', categories[i]['id'] as int);
+      }
+      ref.invalidate(adminMusicCategoriesProvider);
+    } catch (e) {
+      ref.invalidate(adminMusicCategoriesProvider);
+    }
+  }
+}
diff --git a/lib/screens/admin/admin_chapter_management_screen.dart b/lib/screens/admin/admin_chapter_management_screen.dart
index 033b0bd..49c8041 100644
--- a/lib/screens/admin/admin_chapter_management_screen.dart
+++ b/lib/screens/admin/admin_chapter_management_screen.dart
@@ -324,14 +324,14 @@ class _AdminChapterManagementScreenState
                       ),
                       const Text('نمونه رایگان'),
                       const SizedBox(width: 8),
-                      Icon(
+                      const Icon(
                         Icons.info_outline,
                         size: 16,
                         color: AppColors.textTertiary,
                       ),
                     ],
                   ),
-                  Text(
+                  const Text(
                     'فصل‌های نمونه برای همه کاربران قابل پخش است',
                     style: TextStyle(
                       fontSize: 11,
@@ -585,18 +585,29 @@ class _AdminChapterManagementScreenState
           ? 1
           : (_chapters.map((c) => (c['chapter_index'] as int?) ?? 0).reduce((a, b) => a > b ? a : b) + 1);
 
-      // Create chapter record
-      await Supabase.instance.client.from('chapters').insert({
-        'audiobook_id': widget.audiobookId,
-        'title_fa': chapterInfo['title_fa'],
-        'title_en': chapterInfo['title_en'],
-        'chapter_index': nextIndex,
-        'audio_storage_path': path,
-        'duration_seconds': 0,
-        'file_size_bytes': file.size,
-        'audio_format': extension,
-        'is_preview': (chapterInfo['is_preview'] as bool?) ?? false,
-      });
+      // Create chapter record - with orphan file cleanup on failure
+      try {
+        await Supabase.instance.client.from('chapters').insert({
+          'audiobook_id': widget.audiobookId,
+          'title_fa': chapterInfo['title_fa'],
+          'title_en': chapterInfo['title_en'],
+          'chapter_index': nextIndex,
+          'audio_storage_path': path,
+          'duration_seconds': 0,
+          'file_size_bytes': file.size,
+          'audio_format': extension,
+          'is_preview': (chapterInfo['is_preview'] as bool?) ?? false,
+        });
+      } catch (dbError) {
+        // DB insert failed - clean up orphan file from storage
+        AppLogger.w('Admin chapter DB insert failed, cleaning up uploaded file: $path');
+        try {
+          await Supabase.instance.client.storage.from(Env.audioBucket).remove([path]);
+        } catch (cleanupError) {
+          AppLogger.e('Failed to cleanup orphan audio file: $path', error: cleanupError);
+        }
+        rethrow;
+      }
 
       setState(() => _uploadProgress = 0.9);
 
@@ -637,11 +648,11 @@ class _AdminChapterManagementScreenState
         textDirection: TextDirection.rtl,
         child: AlertDialog(
           backgroundColor: AppColors.surface,
-          title: Row(
+          title: const Row(
             children: [
               Icon(Icons.warning_amber_rounded, color: AppColors.error, size: 28),
-              const SizedBox(width: 8),
-              const Text('خطای فایل صوتی'),
+              SizedBox(width: 8),
+              Text('خطای فایل صوتی'),
             ],
           ),
           content: Text(errorMessage),
@@ -690,7 +701,7 @@ class _AdminChapterManagementScreenState
                             crossAxisAlignment: CrossAxisAlignment.start,
                             children: [
                               Text(fileName, style: const TextStyle(fontSize: 12), overflow: TextOverflow.ellipsis),
-                              Text(Formatters.formatFileSize(fileSize), style: TextStyle(fontSize: 11, color: AppColors.textTertiary)),
+                              Text(Formatters.formatFileSize(fileSize), style: const TextStyle(fontSize: 11, color: AppColors.textTertiary)),
                             ],
                           ),
                         ),
@@ -725,7 +736,7 @@ class _AdminChapterManagementScreenState
                       const Text('نمونه رایگان'),
                     ],
                   ),
-                  Text('فصل‌های نمونه برای همه کاربران قابل پخش است', style: TextStyle(fontSize: 11, color: AppColors.textTertiary)),
+                  const Text('فصل‌های نمونه برای همه کاربران قابل پخش است', style: TextStyle(fontSize: 11, color: AppColors.textTertiary)),
                 ],
               ),
             ),
@@ -783,40 +794,42 @@ class _AdminChapterManagementScreenState
           ),
           centerTitle: true,
         ),
+        // LAYOUT FIX: Removed FAB, using unified bottom bar to prevent overlap
         body: Column(
           children: [
-            // Instructions banner
-            Container(
-              padding: const EdgeInsets.all(12),
-              margin: const EdgeInsets.all(16),
-              decoration: BoxDecoration(
-                color: AppColors.primary.withOpacity(0.1),
-                borderRadius: BorderRadius.circular(8),
-                border: Border.all(color: AppColors.primary.withOpacity(0.3)),
-              ),
-              child: Row(
-                children: [
-                  const Icon(Icons.info_outline,
-                      color: AppColors.primary, size: 20),
-                  const SizedBox(width: 8),
-                  Expanded(
-                    child: Text(
-                      'شماره ترتیب هر فصل را وارد کنید یا فصل‌ها را بکشید',
-                      style: TextStyle(
-                        color: AppColors.primary,
-                        fontSize: 12,
+            // Instructions banner (only show when chapters exist)
+            if (_chapters.isNotEmpty)
+              Container(
+                padding: const EdgeInsets.all(12),
+                margin: const EdgeInsets.fromLTRB(16, 16, 16, 0),
+                decoration: BoxDecoration(
+                  color: AppColors.primary.withOpacity(0.1),
+                  borderRadius: BorderRadius.circular(8),
+                  border: Border.all(color: AppColors.primary.withOpacity(0.3)),
+                ),
+                child: const Row(
+                  children: [
+                    Icon(Icons.info_outline,
+                        color: AppColors.primary, size: 20),
+                    SizedBox(width: 8),
+                    Expanded(
+                      child: Text(
+                        'شماره ترتیب هر فصل را وارد کنید یا فصل‌ها را بکشید',
+                        style: TextStyle(
+                          color: AppColors.primary,
+                          fontSize: 12,
+                        ),
                       ),
                     ),
-                  ),
-                ],
+                  ],
+                ),
               ),
-            ),
 
             // Error message
             if (_error != null)
               Container(
                 padding: const EdgeInsets.all(12),
-                margin: const EdgeInsets.symmetric(horizontal: 16),
+                margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                 decoration: BoxDecoration(
                   color: AppColors.error.withOpacity(0.1),
                   borderRadius: BorderRadius.circular(8),
@@ -841,7 +854,7 @@ class _AdminChapterManagementScreenState
             if (_isUploading)
               Container(
                 padding: const EdgeInsets.all(16),
-                margin: const EdgeInsets.symmetric(horizontal: 16),
+                margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                 decoration: BoxDecoration(
                   color: AppColors.surface,
                   borderRadius: BorderRadius.circular(12),
@@ -876,13 +889,13 @@ class _AdminChapterManagementScreenState
                     const SizedBox(height: 8),
                     Text(
                       '${(_uploadProgress * 100).toInt()}%',
-                      style: TextStyle(color: AppColors.textSecondary, fontSize: 12),
+                      style: const TextStyle(color: AppColors.textSecondary, fontSize: 12),
                     ),
                   ],
                 ),
               ),
 
-            // Chapters list
+            // Chapters list (takes remaining space)
             Expanded(
               child: _isLoading
                   ? const Center(
@@ -894,16 +907,11 @@ class _AdminChapterManagementScreenState
                       : _buildChaptersList(),
             ),
 
-            // Save order button (only show when chapters exist)
-            if (_chapters.length > 1) _buildSaveOrderButton(),
+            // Unified bottom action bar (no FAB overlap)
+            _buildBottomActionBar(),
           ],
         ),
-        floatingActionButton: FloatingActionButton.extended(
-          onPressed: _isUploading ? null : _addChapter,
-          backgroundColor: _isUploading ? AppColors.surfaceLight : AppColors.primary,
-          icon: const Icon(Icons.add),
-          label: const Text('افزودن فصل'),
-        ),
+        // No floatingActionButton - all actions are in the bottom bar
       ),
     );
   }
@@ -965,86 +973,91 @@ class _AdminChapterManagementScreenState
       color: AppColors.surface,
       margin: const EdgeInsets.only(bottom: 8),
       child: Padding(
-        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
+        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 8),
         child: Row(
           children: [
-            // Order number input
+            // Order number input - compact
             SizedBox(
-              width: 50,
+              width: 44,
               child: TextField(
                 controller: controller,
                 keyboardType: TextInputType.number,
                 textAlign: TextAlign.center,
                 style: const TextStyle(
                   color: AppColors.textPrimary,
-                  fontSize: 14,
+                  fontSize: 13,
                   fontWeight: FontWeight.w600,
                 ),
                 decoration: InputDecoration(
                   isDense: true,
-                  contentPadding: const EdgeInsets.symmetric(horizontal: 8, vertical: 10),
+                  contentPadding: const EdgeInsets.symmetric(horizontal: 4, vertical: 8),
                   filled: true,
                   fillColor: AppColors.background,
                   border: OutlineInputBorder(
-                    borderRadius: BorderRadius.circular(8),
+                    borderRadius: BorderRadius.circular(6),
                     borderSide: BorderSide.none,
                   ),
                   enabledBorder: OutlineInputBorder(
-                    borderRadius: BorderRadius.circular(8),
-                    borderSide: BorderSide(color: AppColors.border, width: 1),
+                    borderRadius: BorderRadius.circular(6),
+                    borderSide: const BorderSide(color: AppColors.border, width: 1),
                   ),
                   focusedBorder: OutlineInputBorder(
-                    borderRadius: BorderRadius.circular(8),
-                    borderSide: BorderSide(color: AppColors.primary, width: 1.5),
+                    borderRadius: BorderRadius.circular(6),
+                    borderSide: const BorderSide(color: AppColors.primary, width: 1.5),
                   ),
                 ),
               ),
             ),
-            const SizedBox(width: 12),
-            // Chapter info
+            const SizedBox(width: 8),
+            // Chapter info - use Expanded to take remaining space
             Expanded(
               child: Column(
                 crossAxisAlignment: CrossAxisAlignment.start,
+                mainAxisSize: MainAxisSize.min,
                 children: [
                   Text(
                     (chapter['title_fa'] as String?) ?? 'بدون عنوان',
                     style: const TextStyle(
                       color: AppColors.textPrimary,
                       fontWeight: FontWeight.w500,
-                      fontSize: 14,
+                      fontSize: 13,
                     ),
                     maxLines: 1,
                     overflow: TextOverflow.ellipsis,
                   ),
                   const SizedBox(height: 4),
+                  // Metadata row - wrap in Flexible to prevent overflow
                   Row(
                     children: [
-                      Icon(Icons.access_time, size: 12, color: AppColors.textTertiary),
-                      const SizedBox(width: 4),
+                      const Icon(Icons.access_time, size: 11, color: AppColors.textTertiary),
+                      const SizedBox(width: 2),
                       Text(
                         _formatDuration(chapter['duration_seconds'] as int?),
-                        style: TextStyle(color: AppColors.textTertiary, fontSize: 11),
+                        style: const TextStyle(color: AppColors.textTertiary, fontSize: 10),
                       ),
-                      const SizedBox(width: 8),
-                      Icon(Icons.storage, size: 12, color: AppColors.textTertiary),
-                      const SizedBox(width: 4),
-                      Text(
-                        _formatFileSize(chapter['file_size_bytes'] as int?),
-                        style: TextStyle(color: AppColors.textTertiary, fontSize: 11),
+                      const SizedBox(width: 6),
+                      const Icon(Icons.storage, size: 11, color: AppColors.textTertiary),
+                      const SizedBox(width: 2),
+                      Flexible(
+                        child: Text(
+                          _formatFileSize(chapter['file_size_bytes'] as int?),
+                          style: const TextStyle(color: AppColors.textTertiary, fontSize: 10),
+                          overflow: TextOverflow.ellipsis,
+                        ),
                       ),
                       if (isPreview) ...[
-                        const SizedBox(width: 8),
+                        const SizedBox(width: 4),
                         Container(
-                          padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
+                          padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 1),
                           decoration: BoxDecoration(
                             color: AppColors.success.withOpacity(0.2),
-                            borderRadius: BorderRadius.circular(4),
+                            borderRadius: BorderRadius.circular(3),
                           ),
                           child: const Text(
                             'رایگان',
                             style: TextStyle(
                               color: AppColors.success,
-                              fontSize: 10,
+                              fontSize: 9,
                             ),
                           ),
                         ),
@@ -1054,30 +1067,45 @@ class _AdminChapterManagementScreenState
                 ],
               ),
             ),
-            // Actions
-            IconButton(
-              icon: const Icon(Icons.comment_outlined, color: AppColors.warning, size: 20),
-              onPressed: () => _openChapterFeedback(chapter),
-              tooltip: 'بازخورد',
-              visualDensity: VisualDensity.compact,
+            // Actions - more compact with smaller touch targets
+            SizedBox(
+              width: 28,
+              height: 28,
+              child: IconButton(
+                icon: const Icon(Icons.comment_outlined, color: AppColors.warning, size: 18),
+                onPressed: () => _openChapterFeedback(chapter),
+                tooltip: 'بازخورد',
+                padding: EdgeInsets.zero,
+                constraints: const BoxConstraints(),
+              ),
             ),
-            IconButton(
-              icon: const Icon(Icons.edit_outlined, color: AppColors.primary, size: 20),
-              onPressed: () => _editChapter(chapter),
-              tooltip: 'ویرایش',
-              visualDensity: VisualDensity.compact,
+            SizedBox(
+              width: 28,
+              height: 28,
+              child: IconButton(
+                icon: const Icon(Icons.edit_outlined, color: AppColors.primary, size: 18),
+                onPressed: () => _editChapter(chapter),
+                tooltip: 'ویرایش',
+                padding: EdgeInsets.zero,
+                constraints: const BoxConstraints(),
+              ),
             ),
-            IconButton(
-              icon: const Icon(Icons.delete_outline, color: AppColors.error, size: 20),
-              onPressed: () => _deleteChapter(chapter),
-              tooltip: 'حذف',
-              visualDensity: VisualDensity.compact,
+            SizedBox(
+              width: 28,
+              height: 28,
+              child: IconButton(
+                icon: const Icon(Icons.delete_outline, color: AppColors.error, size: 18),
+                onPressed: () => _deleteChapter(chapter),
+                tooltip: 'حذف',
+                padding: EdgeInsets.zero,
+                constraints: const BoxConstraints(),
+              ),
             ),
             ReorderableDragStartListener(
               index: index,
               child: const Padding(
-                padding: EdgeInsets.all(8),
-                child: Icon(Icons.drag_handle, color: AppColors.textTertiary, size: 20),
+                padding: EdgeInsets.only(right: 4),
+                child: Icon(Icons.drag_handle, color: AppColors.textTertiary, size: 18),
               ),
             ),
           ],
@@ -1086,7 +1114,16 @@ class _AdminChapterManagementScreenState
     );
   }
 
-  Widget _buildSaveOrderButton() {
+  /// Unified bottom action bar with all actions:
+  /// - Add chapter button
+  /// - Save order button (when >1 chapter)
+  ///
+  /// FIX: Prevents overlapping buttons on small screens by:
+  /// 1. Using SafeArea with proper padding
+  /// 2. All buttons in a single Column (no floating/positioned elements)
+  Widget _buildBottomActionBar() {
+    final bool hasMultipleChapters = _chapters.length > 1;
+
     return Container(
       padding: EdgeInsets.only(
         left: 16,
@@ -1094,43 +1131,68 @@ class _AdminChapterManagementScreenState
         top: 12,
         bottom: MediaQuery.of(context).padding.bottom + 12,
       ),
-      decoration: BoxDecoration(
+      decoration: const BoxDecoration(
         color: AppColors.surface,
         border: Border(
           top: BorderSide(color: AppColors.border),
         ),
       ),
-      child: Row(
+      child: Column(
+        mainAxisSize: MainAxisSize.min,
         children: [
-          Expanded(
-            child: Text(
-              'شماره ترتیب هر فصل را وارد کنید',
-              style: TextStyle(
-                color: AppColors.textSecondary,
-                fontSize: 12,
+          // Row 1: Add chapter button (always visible)
+          SizedBox(
+            width: double.infinity,
+            child: ElevatedButton.icon(
+              onPressed: _isUploading ? null : _addChapter,
+              style: ElevatedButton.styleFrom(
+                backgroundColor: _isUploading ? AppColors.surfaceLight : AppColors.primary,
+                foregroundColor: Colors.white,
+                padding: const EdgeInsets.symmetric(vertical: 14),
+                minimumSize: const Size(44, 48),
               ),
+              icon: const Icon(Icons.add, size: 20),
+              label: const Text('افزودن فصل', style: TextStyle(fontSize: 15, fontWeight: FontWeight.w600)),
             ),
           ),
-          const SizedBox(width: 12),
-          ElevatedButton.icon(
-            onPressed: _isSaving ? null : _saveManualOrder,
-            style: ElevatedButton.styleFrom(
-              backgroundColor: AppColors.primary,
-              foregroundColor: AppColors.background,
-              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
-            ),
-            icon: _isSaving
-                ? const SizedBox(
-                    width: 18,
-                    height: 18,
-                    child: CircularProgressIndicator(
-                      strokeWidth: 2,
-                      color: AppColors.background,
+
+          // Row 2: Save order (only when >1 chapter)
+          if (hasMultipleChapters) ...[
+            const SizedBox(height: 12),
+            Row(
+              children: [
+                const Expanded(
+                  child: Text(
+                    'شماره ترتیب هر فصل را وارد کنید',
+                    style: TextStyle(
+                      color: AppColors.textSecondary,
+                      fontSize: 12,
                     ),
-                  )
-                : const Icon(Icons.save, size: 18),
-            label: const Text('ذخیره ترتیب فصل‌ها'),
-          ),
+                  ),
+                ),
+                const SizedBox(width: 12),
+                OutlinedButton.icon(
+                  onPressed: _isSaving ? null : _saveManualOrder,
+                  style: OutlinedButton.styleFrom(
+                    foregroundColor: AppColors.primary,
+                    padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
+                    minimumSize: const Size(44, 44),
+                  ),
+                  icon: _isSaving
+                      ? const SizedBox(
+                          width: 16,
+                          height: 16,
+                          child: CircularProgressIndicator(
+                            strokeWidth: 2,
+                            color: AppColors.primary,
+                          ),
+                        )
+                      : const Icon(Icons.save, size: 16),
+                  label: const Text('ذخیره ترتیب', style: TextStyle(fontSize: 13)),
+                ),
+              ],
+            ),
+          ],
         ],
       ),
     );
diff --git a/lib/screens/admin/admin_dashboard_screen.dart b/lib/screens/admin/admin_dashboard_screen.dart
index e0c8e58..ea19670 100644
--- a/lib/screens/admin/admin_dashboard_screen.dart
+++ b/lib/screens/admin/admin_dashboard_screen.dart
@@ -3,8 +3,10 @@ import 'package:flutter_riverpod/flutter_riverpod.dart';
 import 'package:supabase_flutter/supabase_flutter.dart';
 import 'package:myna/theme/app_theme.dart';
 import 'package:myna/utils/app_logger.dart';
+import 'package:myna/screens/admin/admin_creators_screen.dart';
 
-/// Admin stats provider - fetches stats via direct queries instead of RPC
+/// Admin stats provider - fetches stats via direct queries
+/// PERFORMANCE: Only fetch necessary columns, limit purchase query
 final adminStatsProvider = FutureProvider<Map<String, dynamic>>((ref) async {
   try {
     final supabase = Supabase.instance.client;
@@ -31,10 +33,11 @@ final adminStatsProvider = FutureProvider<Map<String, dynamic>>((ref) async {
           .from('profiles')
           .select('id')
           .eq('role', 'narrator'),
-      // Total purchases count and revenue
+      // PERFORMANCE: Only fetch amount column, limited to recent 500 purchases
       supabase
           .from('purchases')
-          .select('*'),
+          .select('amount')
+          .limit(500),
     ]);
 
     final pendingBooks = (results[0] as List).length;
@@ -43,10 +46,10 @@ final adminStatsProvider = FutureProvider<Map<String, dynamic>>((ref) async {
     final narrators = (results[3] as List).length;
     final purchases = results[4] as List;
     final totalPurchases = purchases.length;
-    // Try different column names for purchase amount
+    // Calculate revenue from fetched purchases
     final totalRevenue = purchases.fold<int>(
       0,
-      (sum, p) => sum + ((p['amount'] as int?) ?? (p['price_toman'] as int?) ?? (p['amount_toman'] as int?) ?? 0),
+      (sum, p) => sum + ((p['amount'] as int?) ?? 0),
     );
 
     return {
@@ -152,6 +155,23 @@ class AdminDashboardScreen extends ConsumerWidget {
                     );
                   },
                 ),
+                const SizedBox(height: 24),
+
+                // Quick Actions section
+                const Text('دسترسی سریع', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold, color: AppColors.textPrimary)),
+                const SizedBox(height: 12),
+                _buildQuickActionTile(
+                  context,
+                  icon: Icons.people_alt,
+                  title: 'مدیریت سازندگان',
+                  subtitle: 'نویسندگان، گویندگان، هنرمندان و ...',
+                  onTap: () {
+                    Navigator.push(
+                      context,
+                      MaterialPageRoute<void>(builder: (_) => const AdminCreatorsScreen()),
+                    );
+                  },
+                ),
               ],
             ),
           ),
@@ -161,6 +181,34 @@ class AdminDashboardScreen extends ConsumerWidget {
     );
   }
 
+  Widget _buildQuickActionTile(
+    BuildContext context, {
+    required IconData icon,
+    required String title,
+    required String subtitle,
+    required VoidCallback onTap,
+  }) {
+    return Card(
+      color: AppColors.surface,
+      margin: EdgeInsets.zero,
+      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
+      child: ListTile(
+        onTap: onTap,
+        leading: Container(
+          padding: const EdgeInsets.all(8),
+          decoration: BoxDecoration(
+            color: AppColors.primary.withOpacity(0.1),
+            borderRadius: BorderRadius.circular(8),
+          ),
+          child: Icon(icon, color: AppColors.primary),
+        ),
+        title: Text(title, style: const TextStyle(fontWeight: FontWeight.w600, color: AppColors.textPrimary)),
+        subtitle: Text(subtitle, style: const TextStyle(fontSize: 12, color: AppColors.textSecondary)),
+        trailing: const Icon(Icons.chevron_left, color: AppColors.textTertiary),
+      ),
+    );
+  }
+
   String _formatNumber(num number) {
     final numValue = number.toInt();
     if (numValue >= 1000000) return '${(numValue / 1000000).toStringAsFixed(1)}M';
diff --git a/lib/screens/admin/admin_edit_audiobook_screen.dart b/lib/screens/admin/admin_edit_audiobook_screen.dart
index 9bee866..01f1c5e 100644
--- a/lib/screens/admin/admin_edit_audiobook_screen.dart
+++ b/lib/screens/admin/admin_edit_audiobook_screen.dart
@@ -2,10 +2,12 @@ import 'dart:typed_data';
 import 'package:flutter/material.dart';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
 import 'package:supabase_flutter/supabase_flutter.dart';
-import 'package:file_picker/file_picker.dart';
+import 'package:image_picker/image_picker.dart';
 import 'package:myna/theme/app_theme.dart';
 import 'package:myna/utils/app_logger.dart';
 import 'package:myna/screens/admin/admin_chapter_management_screen.dart';
+import 'package:myna/widgets/admin/audiobook_creators_sheet.dart';
+import 'package:myna/services/creator_service.dart';
 
 class AdminEditAudiobookScreen extends ConsumerStatefulWidget {
   final Map<String, dynamic> audiobook;
@@ -40,8 +42,11 @@ class _AdminEditAudiobookScreenState extends ConsumerState<AdminEditAudiobookScr
   int? _selectedCategoryId;
   bool _isFree = true;
   bool _isFeatured = false;
+  bool _isParastoBrand = false; // Show as "پرستو" brand instead of narrator name
+  bool _isMusic = false; // Content type: false = audiobook, true = music
   bool _isLoading = true;
   bool _isSaving = false;
+  bool _isSyncingCreators = false; // For manual creator sync button
   String? _error;
 
   // Cover image
@@ -83,6 +88,8 @@ class _AdminEditAudiobookScreenState extends ConsumerState<AdminEditAudiobookScr
     _selectedCategoryId = audiobook['category_id'] as int?;
     _isFree = (audiobook['is_free'] as bool?) ?? true;
     _isFeatured = (audiobook['is_featured'] as bool?) ?? false;
+    _isParastoBrand = (audiobook['is_parasto_brand'] as bool?) ?? false;
+    _isMusic = (audiobook['is_music'] as bool?) ?? false;
     _priceController.text = ((audiobook['price_toman'] as int?) ?? 0).toString();
     _existingCoverUrl = audiobook['cover_url'] as String?;
   }
@@ -109,20 +116,20 @@ class _AdminEditAudiobookScreenState extends ConsumerState<AdminEditAudiobookScr
 
   Future<void> _pickCoverImage() async {
     try {
-      final result = await FilePicker.platform.pickFiles(
-        type: FileType.image,
-        allowMultiple: false,
-        withData: true,
+      final picker = ImagePicker();
+      final XFile? image = await picker.pickImage(
+        source: ImageSource.gallery,
+        maxWidth: 1200,
+        maxHeight: 1200,
+        imageQuality: 85,
       );
 
-      if (result != null && result.files.isNotEmpty) {
-        final file = result.files.first;
-        if (file.bytes != null) {
-          setState(() {
-            _newCoverBytes = file.bytes;
-            _newCoverFileName = file.name;
-          });
-        }
+      if (image != null) {
+        final bytes = await image.readAsBytes();
+        setState(() {
+          _newCoverBytes = bytes;
+          _newCoverFileName = image.name;
+        });
       }
     } catch (e) {
       setState(() => _error = 'خطا در انتخاب تصویر: $e');
@@ -168,45 +175,92 @@ class _AdminEditAudiobookScreenState extends ConsumerState<AdminEditAudiobookScr
 
     try {
       String? coverUrl = _existingCoverUrl;
+      String? newCoverPath; // Track new cover for cleanup if DB fails
 
       // Upload new cover if selected
       if (_newCoverBytes != null) {
         coverUrl = await _uploadNewCover();
+        // Extract path from URL for potential cleanup
+        if (coverUrl != null) {
+          try {
+            final uri = Uri.parse(coverUrl);
+            final pathSegments = uri.pathSegments;
+            final bucketIndex = pathSegments.indexOf('audiobook-covers');
+            if (bucketIndex != -1 && bucketIndex < pathSegments.length - 1) {
+              newCoverPath = pathSegments.sublist(bucketIndex + 1).join('/');
+            }
+          } catch (_) {}
+        }
       }
 
       final price = _isFree ? 0 : int.tryParse(_priceController.text) ?? 0;
 
-      await Supabase.instance.client
-          .from('audiobooks')
-          .update({
-            'title_fa': _titleFaController.text.trim(),
-            'title_en': _titleEnController.text.trim().isEmpty
-                ? null
-                : _titleEnController.text.trim(),
-            'author_fa': _authorFaController.text.trim().isEmpty
-                ? null
-                : _authorFaController.text.trim(),
-            'author_en': _authorEnController.text.trim().isEmpty
-                ? null
-                : _authorEnController.text.trim(),
-            'translator_fa': _translatorFaController.text.trim().isEmpty
-                ? null
-                : _translatorFaController.text.trim(),
-            'translator_en': _translatorEnController.text.trim().isEmpty
-                ? null
-                : _translatorEnController.text.trim(),
-            'description_fa': _descriptionFaController.text.trim(),
-            'description_en': _descriptionEnController.text.trim().isEmpty
-                ? null
-                : _descriptionEnController.text.trim(),
-            'category_id': _selectedCategoryId,
-            'cover_url': coverUrl,
-            'price_toman': price,
-            'is_free': _isFree,
-            'is_featured': _isFeatured,
-            'updated_at': DateTime.now().toIso8601String(),
-          })
-          .eq('id', widget.audiobook['id'] as Object);
+      final audiobookId = widget.audiobook['id'] as int;
+
+      // Update audiobook - with orphan cover cleanup on failure
+      try {
+        await Supabase.instance.client
+            .from('audiobooks')
+            .update({
+              'title_fa': _titleFaController.text.trim(),
+              'title_en': _titleEnController.text.trim().isEmpty
+                  ? null
+                  : _titleEnController.text.trim(),
+              'author_fa': _authorFaController.text.trim().isEmpty
+                  ? null
+                  : _authorFaController.text.trim(),
+              'author_en': _authorEnController.text.trim().isEmpty
+                  ? null
+                  : _authorEnController.text.trim(),
+              'translator_fa': _translatorFaController.text.trim().isEmpty
+                  ? null
+                  : _translatorFaController.text.trim(),
+              'translator_en': _translatorEnController.text.trim().isEmpty
+                  ? null
+                  : _translatorEnController.text.trim(),
+              'description_fa': _descriptionFaController.text.trim(),
+              'description_en': _descriptionEnController.text.trim().isEmpty
+                  ? null
+                  : _descriptionEnController.text.trim(),
+              'category_id': _selectedCategoryId,
+              'cover_url': coverUrl,
+              'price_toman': price,
+              'is_free': _isFree,
+              'is_featured': _isFeatured,
+              'is_parasto_brand': _isParastoBrand, // Display as "پرستو" brand
+              'updated_at': DateTime.now().toIso8601String(),
+            })
+            .eq('id', audiobookId);
+      } catch (dbError) {
+        // DB update failed - clean up newly uploaded cover if any
+        if (newCoverPath != null) {
+          AppLogger.w('Admin audiobook DB update failed, cleaning up new cover: $newCoverPath');
+          try {
+            await Supabase.instance.client.storage.from('audiobook-covers').remove([newCoverPath]);
+          } catch (cleanupError) {
+            AppLogger.e('Failed to cleanup orphan cover: $newCoverPath', error: cleanupError);
+          }
+        }
+        rethrow;
+      }
+
+      // Auto-sync creators from the author/translator fields
+      // For music: author_fa is the artist/singer
+      // For books: author_fa is the author, translator_fa is the translator
+      final creatorService = CreatorService();
+      await creatorService.syncCreatorsForAudiobook(
+        audiobookId: audiobookId,
+        isMusic: _isMusic,
+        // Book fields - author_fa/translator_fa are the legacy fields shown on this form
+        authorName: _isMusic ? null : _authorFaController.text,
+        authorNameEn: _isMusic ? null : _authorEnController.text,
+        translatorName: _isMusic ? null : _translatorFaController.text,
+        translatorNameEn: _isMusic ? null : _translatorEnController.text,
+        // Music fields - for music, author_fa is the artist/singer
+        artistName: _isMusic ? _authorFaController.text : null,
+        artistNameEn: _isMusic ? _authorEnController.text : null,
+      );
+      AppLogger.d('Creator sync completed for audiobook $audiobookId');
 
       widget.onUpdate();
 
@@ -228,6 +282,52 @@ class _AdminEditAudiobookScreenState extends ConsumerState<AdminEditAudiobookScr
     }
   }
 
+  /// Manually sync creators from the current form fields.
+  /// Useful for backfilling older content that was created before auto-sync.
+  Future<void> _manualSyncCreators() async {
+    final audiobookId = widget.audiobook['id'] as int;
+
+    setState(() {
+      _isSyncingCreators = true;
+      _error = null;
+    });
+
+    try {
+      final creatorService = CreatorService();
+      final success = await creatorService.syncCreatorsForAudiobook(
+        audiobookId: audiobookId,
+        isMusic: _isMusic,
+        // Book fields
+        authorName: _isMusic ? null : _authorFaController.text,
+        authorNameEn: _isMusic ? null : _authorEnController.text,
+        translatorName: _isMusic ? null : _translatorFaController.text,
+        translatorNameEn: _isMusic ? null : _translatorEnController.text,
+        // Music fields - for music, author_fa is the artist
+        artistName: _isMusic ? _authorFaController.text : null,
+        artistNameEn: _isMusic ? _authorEnController.text : null,
+      );
+
+      if (mounted) {
+        if (success) {
+          ScaffoldMessenger.of(context).showSnackBar(
+            const SnackBar(
+              content: Text('سازندگان با موفقیت همگام‌سازی شدند'),
+              backgroundColor: AppColors.success,
+            ),
+          );
+        } else {
+          setState(() => _error = 'خطا در همگام‌سازی سازندگان');
+        }
+      }
+    } catch (e) {
+      setState(() => _error = 'خطا در همگام‌سازی: $e');
+    } finally {
+      if (mounted) {
+        setState(() => _isSyncingCreators = false);
+      }
+    }
+  }
+
   @override
   Widget build(BuildContext context) {
     final narrator = widget.audiobook['profiles'] as Map<String, dynamic>?;
@@ -304,7 +404,7 @@ class _AdminEditAudiobookScreenState extends ConsumerState<AdminEditAudiobookScr
                       ),
                       const SizedBox(height: 24),
 
-                      // Author/Translator Section
+                      // Author/Translator Section (dynamic for music vs books)
                       Container(
                         padding: const EdgeInsets.all(16),
                         decoration: BoxDecoration(
@@ -317,11 +417,15 @@ class _AdminEditAudiobookScreenState extends ConsumerState<AdminEditAudiobookScr
                           children: [
                             Row(
                               children: [
-                                const Icon(Icons.person, color: AppColors.primary, size: 20),
+                                Icon(
+                                  _isMusic ? Icons.person : Icons.edit,
+                                  color: AppColors.primary,
+                                  size: 20,
+                                ),
                                 const SizedBox(width: 8),
-                                const Text(
-                                  'اطلاعات نویسنده و مترجم',
-                                  style: TextStyle(
+                                Text(
+                                  _isMusic ? 'اطلاعات هنرمند' : 'اطلاعات نویسنده و مترجم',
+                                  style: const TextStyle(
                                     fontSize: 14,
                                     fontWeight: FontWeight.bold,
                                     color: AppColors.textPrimary,
@@ -331,50 +435,54 @@ class _AdminEditAudiobookScreenState extends ConsumerState<AdminEditAudiobookScr
                             ),
                             const SizedBox(height: 16),
 
-                            // Author Farsi
+                            // Author/Artist Farsi
                             TextFormField(
                               controller: _authorFaController,
-                              decoration: const InputDecoration(
-                                labelText: 'نام نویسنده (فارسی)',
-                                hintText: 'مثال: آنتوان دو سنت‌اگزوپری',
-                                prefixIcon: Icon(Icons.edit),
+                              decoration: InputDecoration(
+                                labelText: _isMusic ? 'نام هنرمند (فارسی)' : 'نام نویسنده (فارسی)',
+                                hintText: _isMusic ? 'مثال: محسن چاوشی' : 'مثال: آنتوان دو سنت‌اگزوپری',
+                                prefixIcon: Icon(_isMusic ? Icons.person : Icons.edit),
                               ),
                             ),
                             const SizedBox(height: 12),
 
-                            // Author English
+                            // Author/Artist English
                             TextFormField(
                               controller: _authorEnController,
-                              decoration: const InputDecoration(
-                                labelText: 'نام نویسنده (انگلیسی - اختیاری)',
-                                hintText: 'Example: Antoine de Saint-Exupéry',
-                                prefixIcon: Icon(Icons.edit),
+                              decoration: InputDecoration(
+                                labelText: _isMusic ? 'نام هنرمند (انگلیسی - اختیاری)' : 'نام نویسنده (انگلیسی - اختیاری)',
+                                hintText: _isMusic ? 'Example: Mohsen Chavoshi' : 'Example: Antoine de Saint-Exupéry',
+                                prefixIcon: Icon(_isMusic ? Icons.person : Icons.edit),
                               ),
                               textDirection: TextDirection.ltr,
                             ),
-                            const SizedBox(height: 12),
 
-                            // Translator Farsi
-                            TextFormField(
-                              controller: _translatorFaController,
-                              decoration: const InputDecoration(
-                                labelText: 'نام مترجم (فارسی - اختیاری)',
-                                hintText: 'مثال: احمد شاملو',
-                                prefixIcon: Icon(Icons.translate),
+                            // Translator fields (only for books, not music)
+                            if (!_isMusic) ...[
+                              const SizedBox(height: 12),
+
+                              // Translator Farsi
+                              TextFormField(
+                                controller: _translatorFaController,
+                                decoration: const InputDecoration(
+                                  labelText: 'نام مترجم (فارسی - اختیاری)',
+                                  hintText: 'مثال: احمد شاملو',
+                                  prefixIcon: Icon(Icons.translate),
+                                ),
                               ),
-                            ),
-                            const SizedBox(height: 12),
-
-                            // Translator English
-                            TextFormField(
-                              controller: _translatorEnController,
-                              decoration: const InputDecoration(
-                                labelText: 'نام مترجم (انگلیسی - اختیاری)',
-                                hintText: 'Example: Ahmad Shamlou',
-                                prefixIcon: Icon(Icons.translate),
+                              const SizedBox(height: 12),
+
+                              // Translator English
+                              TextFormField(
+                                controller: _translatorEnController,
+                                decoration: const InputDecoration(
+                                  labelText: 'نام مترجم (انگلیسی - اختیاری)',
+                                  hintText: 'Example: Ahmad Shamlou',
+                                  prefixIcon: Icon(Icons.translate),
+                                ),
+                                textDirection: TextDirection.ltr,
                               ),
-                              textDirection: TextDirection.ltr,
-                            ),
+                            ],
                           ],
                         ),
                       ),
@@ -434,6 +542,10 @@ class _AdminEditAudiobookScreenState extends ConsumerState<AdminEditAudiobookScr
                       _buildFeaturedToggle(),
                       const SizedBox(height: 16),
 
+                      // Parasto Brand Toggle
+                      _buildParastoBrandToggle(),
+                      const SizedBox(height: 16),
+
                       // Price Section
                       _buildPriceSection(),
                       const SizedBox(height: 24),
@@ -464,6 +576,43 @@ class _AdminEditAudiobookScreenState extends ConsumerState<AdminEditAudiobookScr
                           side: const BorderSide(color: AppColors.primary),
                         ),
                       ),
+                      const SizedBox(height: 12),
+
+                      // Creators Management Button
+                      OutlinedButton.icon(
+                        onPressed: () {
+                          AudiobookCreatorsSheet.show(
+                            context,
+                            audiobookId: widget.audiobook['id'] as int,
+                            isMusic: _isMusic,
+                          );
+                        },
+                        icon: const Icon(Icons.people),
+                        label: const Text('مدیریت سازندگان (نویسنده، گوینده، ...)'),
+                        style: OutlinedButton.styleFrom(
+                          padding: const EdgeInsets.symmetric(vertical: 16),
+                          side: BorderSide(color: AppColors.primary.withOpacity(0.7)),
+                        ),
+                      ),
+                      const SizedBox(height: 12),
+
+                      // Manual Creator Sync Button (for backfilling old content)
+                      OutlinedButton.icon(
+                        onPressed: _isSyncingCreators ? null : _manualSyncCreators,
+                        icon: _isSyncingCreators
+                            ? const SizedBox(
+                                width: 16,
+                                height: 16,
+                                child: CircularProgressIndicator(strokeWidth: 2),
+                              )
+                            : const Icon(Icons.sync, size: 20),
+                        label: const Text('همگام‌سازی سازندگان از روی نام‌ها'),
+                        style: OutlinedButton.styleFrom(
+                          padding: const EdgeInsets.symmetric(vertical: 16),
+                          side: BorderSide(color: AppColors.textSecondary.withOpacity(0.5)),
+                          foregroundColor: AppColors.textSecondary,
+                        ),
+                      ),
                       const SizedBox(height: 24),
 
                       // Error Message
@@ -593,6 +742,59 @@ class _AdminEditAudiobookScreenState extends ConsumerState<AdminEditAudiobookScr
     );
   }
 
+  Widget _buildParastoBrandToggle() {
+    return Container(
+      padding: const EdgeInsets.all(16),
+      decoration: BoxDecoration(
+        color: AppColors.surface,
+        borderRadius: BorderRadius.circular(12),
+        border: _isParastoBrand
+            ? Border.all(color: AppColors.primary.withOpacity(0.5), width: 2)
+            : null,
+      ),
+      child: Row(
+        children: [
+          Icon(
+            _isParastoBrand ? Icons.verified : Icons.verified_outlined,
+            color: _isParastoBrand ? AppColors.primary : AppColors.textTertiary,
+          ),
+          const SizedBox(width: 12),
+          Expanded(
+            child: Column(
+              crossAxisAlignment: CrossAxisAlignment.start,
+              children: [
+                const Text(
+                  'نمایش به نام پرستو',
+                  style: TextStyle(
+                    fontSize: 16,
+                    fontWeight: FontWeight.bold,
+                    color: AppColors.textPrimary,
+                  ),
+                ),
+                Text(
+                  _isParastoBrand
+                      ? 'این کتاب به نام «پرستو» نمایش داده می‌شود'
+                      : 'نام گوینده نمایش داده می‌شود',
+                  style: const TextStyle(
+                    fontSize: 12,
+                    color: AppColors.textSecondary,
+                  ),
+                ),
+              ],
+            ),
+          ),
+          Switch(
+            value: _isParastoBrand,
+            onChanged: (value) {
+              setState(() => _isParastoBrand = value);
+            },
+            activeColor: AppColors.primary,
+          ),
+        ],
+      ),
+    );
+  }
+
   Widget _buildFeaturedToggle() {
     return Container(
       padding: const EdgeInsets.all(16),
diff --git a/lib/screens/admin/admin_feedback_dialog.dart b/lib/screens/admin/admin_feedback_dialog.dart
index be0dafb..23a0acf 100644
--- a/lib/screens/admin/admin_feedback_dialog.dart
+++ b/lib/screens/admin/admin_feedback_dialog.dart
@@ -198,7 +198,7 @@ class _AdminFeedbackDialogState extends ConsumerState<AdminFeedbackDialog> {
                 style: const TextStyle(color: AppColors.textPrimary),
                 decoration: InputDecoration(
                   hintText: _getHintText(),
-                  hintStyle: TextStyle(color: AppColors.textTertiary),
+                  hintStyle: const TextStyle(color: AppColors.textTertiary),
                   filled: true,
                   fillColor: AppColors.background,
                   border: OutlineInputBorder(
diff --git a/lib/screens/admin/admin_profile_screen.dart b/lib/screens/admin/admin_profile_screen.dart
index c417774..ea5ea20 100644
--- a/lib/screens/admin/admin_profile_screen.dart
+++ b/lib/screens/admin/admin_profile_screen.dart
@@ -117,16 +117,33 @@ class _AdminProfileScreenState extends ConsumerState<AdminProfileScreen> {
 
     try {
       String? finalAvatarUrl = _avatarUrl;
+      String? newAvatarPath; // Track new avatar for cleanup if DB fails
+
       if (_newAvatarBytes != null) {
         finalAvatarUrl = await _uploadAvatar();
+        // Extract path from URL for potential cleanup
+        if (finalAvatarUrl != null) {
+          newAvatarPath = '${user.id}/avatar_${DateTime.now().millisecondsSinceEpoch}.jpg';
+        }
       }
 
-      await Supabase.instance.client.from('profiles').update({
-        'display_name': _displayNameController.text.trim(),
-        'bio': _bioController.text.trim(),
-        if (finalAvatarUrl != null) 'avatar_url': finalAvatarUrl,
-        'updated_at': DateTime.now().toIso8601String(),
-      }).eq('id', user.id);
+      // Update profile - with orphan avatar cleanup on failure
+      try {
+        await Supabase.instance.client.from('profiles').update({
+          'display_name': _displayNameController.text.trim(),
+          'bio': _bioController.text.trim(),
+          if (finalAvatarUrl != null) 'avatar_url': finalAvatarUrl,
+          'updated_at': DateTime.now().toIso8601String(),
+        }).eq('id', user.id);
+      } catch (dbError) {
+        // DB update failed - clean up newly uploaded avatar if any
+        if (newAvatarPath != null) {
+          try {
+            await Supabase.instance.client.storage.from('avatars').remove([newAvatarPath]);
+          } catch (_) {}
+        }
+        rethrow;
+      }
 
       if (mounted) {
         _showSuccess('پروفایل ذخیره شد');
@@ -244,7 +261,7 @@ class _AdminProfileScreenState extends ConsumerState<AdminProfileScreen> {
                         ),
                       ),
                       const SizedBox(height: 8),
-                      Center(child: Text('برای تغییر تصویر ضربه بزنید', style: TextStyle(color: AppColors.textTertiary, fontSize: 12))),
+                      const Center(child: Text('برای تغییر تصویر ضربه بزنید', style: TextStyle(color: AppColors.textTertiary, fontSize: 12))),
                       const SizedBox(height: 32),
 
                       // Display Name
@@ -288,7 +305,7 @@ class _AdminProfileScreenState extends ConsumerState<AdminProfileScreen> {
                           prefixIcon: const Icon(Icons.email_outlined),
                           suffixIcon: const Icon(Icons.lock_outline, size: 18),
                         ),
-                        style: TextStyle(color: AppColors.textTertiary),
+                        style: const TextStyle(color: AppColors.textTertiary),
                       ),
                       const SizedBox(height: 32),
 
diff --git a/lib/screens/admin/admin_promotions_screen.dart b/lib/screens/admin/admin_promotions_screen.dart
index ad3574a..3748dad 100644
--- a/lib/screens/admin/admin_promotions_screen.dart
+++ b/lib/screens/admin/admin_promotions_screen.dart
@@ -65,7 +65,7 @@ class _BannersTab extends ConsumerWidget {
             children: [
               const Icon(Icons.error_outline, color: AppColors.error, size: 48),
               const SizedBox(height: 16),
-              Text('خطا در بارگذاری بنرها', style: TextStyle(color: AppColors.error)),
+              const Text('خطا در بارگذاری بنرها', style: TextStyle(color: AppColors.error)),
               const SizedBox(height: 8),
               ElevatedButton(
                 onPressed: () => ref.invalidate(adminBannersProvider),
@@ -190,7 +190,7 @@ class _BannerCard extends StatelessWidget {
                   const SizedBox(height: 4),
                   Text(
                     banner['subtitle_fa'] as String,
-                    style: TextStyle(color: AppColors.textSecondary, fontSize: 13),
+                    style: const TextStyle(color: AppColors.textSecondary, fontSize: 13),
                     maxLines: 2,
                     overflow: TextOverflow.ellipsis,
                   ),
@@ -206,12 +206,12 @@ class _BannerCard extends StatelessWidget {
                     const SizedBox(width: 4),
                     Text(
                       targetType == 'audiobook' ? 'کتاب' : targetType == 'shelf' ? 'قفسه' : 'دسته‌بندی',
-                      style: TextStyle(color: AppColors.textTertiary, fontSize: 12),
+                      style: const TextStyle(color: AppColors.textTertiary, fontSize: 12),
                     ),
                     const Spacer(),
                     Text(
                       'ترتیب: ${banner['sort_order'] ?? 0}',
-                      style: TextStyle(color: AppColors.textTertiary, fontSize: 12),
+                      style: const TextStyle(color: AppColors.textTertiary, fontSize: 12),
                     ),
                   ],
                 ),
@@ -323,7 +323,7 @@ class _ShelvesTab extends ConsumerWidget {
             children: [
               const Icon(Icons.error_outline, color: AppColors.error, size: 48),
               const SizedBox(height: 16),
-              Text('خطا در بارگذاری قفسه‌ها', style: TextStyle(color: AppColors.error)),
+              const Text('خطا در بارگذاری قفسه‌ها', style: TextStyle(color: AppColors.error)),
               const SizedBox(height: 8),
               ElevatedButton(
                 onPressed: () => ref.invalidate(adminShelvesProvider),
@@ -430,7 +430,7 @@ class _ShelfCard extends StatelessWidget {
               const SizedBox(height: 8),
               Text(
                 shelf['description_fa'] as String,
-                style: TextStyle(color: AppColors.textSecondary, fontSize: 13),
+                style: const TextStyle(color: AppColors.textSecondary, fontSize: 13),
                 maxLines: 2,
                 overflow: TextOverflow.ellipsis,
               ),
@@ -438,7 +438,7 @@ class _ShelfCard extends StatelessWidget {
             const SizedBox(height: 8),
             Text(
               'ترتیب: ${shelf['sort_order'] ?? 0}',
-              style: TextStyle(color: AppColors.textTertiary, fontSize: 12),
+              style: const TextStyle(color: AppColors.textTertiary, fontSize: 12),
             ),
             const SizedBox(height: 12),
             Row(
diff --git a/lib/screens/admin/admin_reviews_screen.dart b/lib/screens/admin/admin_reviews_screen.dart
index 915f487..a5f059d 100644
--- a/lib/screens/admin/admin_reviews_screen.dart
+++ b/lib/screens/admin/admin_reviews_screen.dart
@@ -59,7 +59,7 @@ class AdminReviewsScreen extends ConsumerWidget {
                                 crossAxisAlignment: CrossAxisAlignment.start,
                                 children: [
                                   Text((profile?['display_name'] as String?) ?? (profile?['full_name'] as String?) ?? 'کاربر', style: const TextStyle(fontWeight: FontWeight.bold, color: AppColors.textPrimary)),
-                                  Text('کتاب: ${(audiobook?['title_fa'] as String?) ?? 'نامشخص'}', style: TextStyle(color: AppColors.textSecondary, fontSize: 12)),
+                                  Text('کتاب: ${(audiobook?['title_fa'] as String?) ?? 'نامشخص'}', style: const TextStyle(color: AppColors.textSecondary, fontSize: 12)),
                                 ],
                               ),
                             ),
@@ -74,7 +74,7 @@ class AdminReviewsScreen extends ConsumerWidget {
                         ],
                         if (review['content'] != null) ...[
                           const SizedBox(height: 4),
-                          Text(review['content'] as String, style: TextStyle(color: AppColors.textSecondary)),
+                          Text(review['content'] as String, style: const TextStyle(color: AppColors.textSecondary)),
                         ],
                         const SizedBox(height: 8),
                         Row(
diff --git a/lib/screens/admin/admin_settings_screen.dart b/lib/screens/admin/admin_settings_screen.dart
index ccc7cc1..0a18589 100644
--- a/lib/screens/admin/admin_settings_screen.dart
+++ b/lib/screens/admin/admin_settings_screen.dart
@@ -48,7 +48,7 @@ class AdminSettingsScreen extends ConsumerWidget {
                         children: [
                           const Text('پروفایل مدیر', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16, color: AppColors.textPrimary)),
                           const SizedBox(height: 4),
-                          Text(user?.email ?? '', style: TextStyle(color: AppColors.textSecondary, fontSize: 13)),
+                          Text(user?.email ?? '', style: const TextStyle(color: AppColors.textSecondary, fontSize: 13)),
                         ],
                       ),
                     ),
@@ -132,7 +132,7 @@ class AdminSettingsScreen extends ConsumerWidget {
         child: Icon(icon, color: AppColors.primary),
       ),
       title: Text(title, style: const TextStyle(color: AppColors.textPrimary)),
-      subtitle: Text(subtitle, style: TextStyle(color: AppColors.textSecondary, fontSize: 12)),
+      subtitle: Text(subtitle, style: const TextStyle(color: AppColors.textSecondary, fontSize: 12)),
       trailing: const Icon(Icons.chevron_left, color: AppColors.textTertiary),
     ),
   );
@@ -150,7 +150,7 @@ class AdminSettingsScreen extends ConsumerWidget {
               child: const Icon(Icons.headphones, color: AppColors.primary),
             ),
             const SizedBox(width: 12),
-            const Text('مینا', style: TextStyle(color: AppColors.textPrimary)),
+            const Text('پرستو', style: TextStyle(color: AppColors.textPrimary)),
           ],
         ),
         content: Column(
@@ -159,9 +159,9 @@ class AdminSettingsScreen extends ConsumerWidget {
           children: [
             _aboutRow('نسخه', '۱.۰.۰'),
             _aboutRow('پلتفرم', 'iOS, Android, Web'),
-            _aboutRow('توسعه‌دهنده', 'تیم مینا'),
+            _aboutRow('توسعه‌دهنده', 'تیم پرستو'),
             const SizedBox(height: 12),
-            Text('اپلیکیشن کتاب صوتی فارسی', style: TextStyle(color: AppColors.textSecondary)),
+            const Text('اپلیکیشن کتاب صوتی فارسی', style: TextStyle(color: AppColors.textSecondary)),
           ],
         ),
         actions: [TextButton(onPressed: () => Navigator.pop(context), child: const Text('بستن'))],
@@ -173,7 +173,7 @@ class AdminSettingsScreen extends ConsumerWidget {
     padding: const EdgeInsets.only(bottom: 8),
     child: Row(
       children: [
-        Text('$label: ', style: TextStyle(color: AppColors.textTertiary)),
+        Text('$label: ', style: const TextStyle(color: AppColors.textTertiary)),
         Text(value, style: const TextStyle(color: AppColors.textPrimary)),
       ],
     ),
diff --git a/lib/screens/admin/admin_shelf_form_screen.dart b/lib/screens/admin/admin_shelf_form_screen.dart
index 9a04d38..4456ebe 100644
--- a/lib/screens/admin/admin_shelf_form_screen.dart
+++ b/lib/screens/admin/admin_shelf_form_screen.dart
@@ -110,12 +110,12 @@ class _AdminShelfFormScreenState extends ConsumerState<AdminShelfFormScreen> {
                       // Info Card
                       Card(
                         color: AppColors.primary.withOpacity(0.1),
-                        child: Padding(
-                          padding: const EdgeInsets.all(12),
+                        child: const Padding(
+                          padding: EdgeInsets.all(12),
                           child: Row(
                             children: [
-                              const Icon(Icons.info_outline, color: AppColors.primary),
-                              const SizedBox(width: 12),
+                              Icon(Icons.info_outline, color: AppColors.primary),
+                              SizedBox(width: 12),
                               Expanded(
                                 child: Text(
                                   'قفسه‌ها در صفحه اصلی شنوندگان به صورت یک بخش افقی نمایش داده می‌شوند.',
@@ -169,7 +169,7 @@ class _AdminShelfFormScreenState extends ConsumerState<AdminShelfFormScreen> {
                           title: const Text('فعال', style: TextStyle(color: AppColors.textPrimary)),
                           subtitle: Text(
                             _isActive ? 'قفسه در صفحه اصلی نمایش داده می‌شود' : 'قفسه مخفی است',
-                            style: TextStyle(color: AppColors.textSecondary, fontSize: 12),
+                            style: const TextStyle(color: AppColors.textSecondary, fontSize: 12),
                           ),
                           value: _isActive,
                           onChanged: (v) => setState(() => _isActive = v),
@@ -193,7 +193,7 @@ class _AdminShelfFormScreenState extends ConsumerState<AdminShelfFormScreen> {
 
                       if (_isEditing) ...[
                         const SizedBox(height: 16),
-                        Text(
+                        const Text(
                           'پس از ایجاد قفسه، می‌توانید از طریق دکمه "مدیریت کتاب‌ها" کتاب‌ها را به قفسه اضافه کنید.',
                           style: TextStyle(color: AppColors.textTertiary, fontSize: 12),
                           textAlign: TextAlign.center,
diff --git a/lib/screens/admin/admin_shelf_items_screen.dart b/lib/screens/admin/admin_shelf_items_screen.dart
index 5583e8a..4e6a17d 100644
--- a/lib/screens/admin/admin_shelf_items_screen.dart
+++ b/lib/screens/admin/admin_shelf_items_screen.dart
@@ -298,7 +298,7 @@ class _AdminShelfItemsScreenState extends ConsumerState<AdminShelfItemsScreen> {
                               const SizedBox(height: 16),
                               const Text('هنوز کتابی به این قفسه اضافه نشده', style: TextStyle(color: AppColors.textSecondary)),
                               const SizedBox(height: 8),
-                              Text('از بخش بالا کتاب جستجو و اضافه کنید', style: TextStyle(color: AppColors.textTertiary, fontSize: 12)),
+                              const Text('از بخش بالا کتاب جستجو و اضافه کنید', style: TextStyle(color: AppColors.textTertiary, fontSize: 12)),
                             ],
                           ),
                         )
@@ -316,7 +316,7 @@ class _AdminShelfItemsScreenState extends ConsumerState<AdminShelfItemsScreen> {
                                   const Spacer(),
                                   const Icon(Icons.drag_indicator, size: 16, color: AppColors.textTertiary),
                                   const SizedBox(width: 4),
-                                  Text('بکشید برای تغییر ترتیب', style: TextStyle(color: AppColors.textTertiary, fontSize: 11)),
+                                  const Text('بکشید برای تغییر ترتیب', style: TextStyle(color: AppColors.textTertiary, fontSize: 11)),
                                 ],
                               ),
                             ),
@@ -362,7 +362,7 @@ class _AdminShelfItemsScreenState extends ConsumerState<AdminShelfItemsScreen> {
                                       ),
                                       subtitle: Text(
                                         'ترتیب: ${index + 1}',
-                                        style: TextStyle(color: AppColors.textTertiary, fontSize: 11),
+                                        style: const TextStyle(color: AppColors.textTertiary, fontSize: 11),
                                       ),
                                       trailing: IconButton(
                                         icon: const Icon(Icons.remove_circle, color: AppColors.error),
diff --git a/lib/screens/admin/admin_shell.dart b/lib/screens/admin/admin_shell.dart
index 62e0210..08bbc11 100644
--- a/lib/screens/admin/admin_shell.dart
+++ b/lib/screens/admin/admin_shell.dart
@@ -20,14 +20,6 @@ class AdminShell extends ConsumerStatefulWidget {
 class _AdminShellState extends ConsumerState<AdminShell> {
   int _currentIndex = 0;
 
-  final _screens = const [
-    AdminDashboardScreen(),
-    AdminAudiobooksScreen(),
-    AdminUsersScreen(),
-    AdminSupportScreen(),
-    AdminSettingsScreen(),
-  ];
-
   @override
   Widget build(BuildContext context) {
     final openTicketsAsync = ref.watch(adminOpenTicketsCountProvider);
@@ -38,8 +30,19 @@ class _AdminShellState extends ConsumerState<AdminShell> {
       child: Scaffold(
         body: Column(
           children: [
-            // Main content
-            Expanded(child: _screens[_currentIndex]),
+            // Main content - use IndexedStack to preserve state when switching tabs
+            Expanded(
+              child: IndexedStack(
+                index: _currentIndex,
+                children: const [
+                  AdminDashboardScreen(),
+                  AdminAudiobooksScreen(),
+                  AdminUsersScreen(),
+                  AdminSupportScreen(),
+                  AdminSettingsScreen(),
+                ],
+              ),
+            ),
             // Mini player at bottom (if audio is playing)
             if (audio.hasAudio) const MiniPlayer(),
           ],
diff --git a/lib/screens/admin/admin_support_screen.dart b/lib/screens/admin/admin_support_screen.dart
index 7eb290c..560348b 100644
--- a/lib/screens/admin/admin_support_screen.dart
+++ b/lib/screens/admin/admin_support_screen.dart
@@ -57,20 +57,29 @@ class _AdminSupportScreenState extends ConsumerState<AdminSupportScreen> {
               ),
             ),
 
-            // Filter Chips
+            // Filter Chips - scrollable to prevent overflow on small screens
             Container(
               padding: const EdgeInsets.symmetric(horizontal: 16),
               child: Row(
                 children: [
                   const Text('فیلتر:', style: TextStyle(color: AppColors.textSecondary)),
                   const SizedBox(width: 12),
-                  _buildFilterChip(null, 'همه'),
-                  const SizedBox(width: 8),
-                  _buildFilterChip('open', 'باز'),
-                  const SizedBox(width: 8),
-                  _buildFilterChip('in_progress', 'در حال بررسی'),
-                  const SizedBox(width: 8),
-                  _buildFilterChip('closed', 'بسته'),
+                  Expanded(
+                    child: SingleChildScrollView(
+                      scrollDirection: Axis.horizontal,
+                      child: Row(
+                        children: [
+                          _buildFilterChip(null, 'همه'),
+                          const SizedBox(width: 8),
+                          _buildFilterChip('open', 'باز'),
+                          const SizedBox(width: 8),
+                          _buildFilterChip('in_progress', 'در حال بررسی'),
+                          const SizedBox(width: 8),
+                          _buildFilterChip('closed', 'بسته'),
+                        ],
+                      ),
+                    ),
+                  ),
                 ],
               ),
             ),
@@ -106,7 +115,7 @@ class _AdminSupportScreenState extends ConsumerState<AdminSupportScreen> {
                           const SizedBox(height: 16),
                           Text(
                             _statusFilter == null ? 'تیکتی وجود ندارد' : 'تیکتی با این وضعیت یافت نشد',
-                            style: TextStyle(color: AppColors.textSecondary),
+                            style: const TextStyle(color: AppColors.textSecondary),
                           ),
                         ],
                       ),
@@ -306,7 +315,7 @@ class _AdminTicketCard extends StatelessWidget {
                       Expanded(
                         child: Text(
                           (audiobook['title_fa'] as String?) ?? '',
-                          style: TextStyle(color: AppColors.textSecondary, fontSize: 12),
+                          style: const TextStyle(color: AppColors.textSecondary, fontSize: 12),
                           maxLines: 1,
                           overflow: TextOverflow.ellipsis,
                         ),
@@ -321,7 +330,7 @@ class _AdminTicketCard extends StatelessWidget {
                   const Icon(Icons.tag, size: 14, color: AppColors.textTertiary),
                   Text(
                     ' #${ticket['id']}',
-                    style: TextStyle(color: AppColors.textTertiary, fontSize: 11),
+                    style: const TextStyle(color: AppColors.textTertiary, fontSize: 11),
                   ),
                   const SizedBox(width: 16),
                   const Icon(Icons.access_time, size: 14, color: AppColors.textTertiary),
@@ -330,7 +339,7 @@ class _AdminTicketCard extends StatelessWidget {
                     updatedAt != null
                         ? '${updatedAt.month}/${updatedAt.day} - ${updatedAt.hour.toString().padLeft(2, '0')}:${updatedAt.minute.toString().padLeft(2, '0')}'
                         : '',
-                    style: TextStyle(color: AppColors.textTertiary, fontSize: 11),
+                    style: const TextStyle(color: AppColors.textTertiary, fontSize: 11),
                   ),
                   const Spacer(),
                   const Icon(Icons.chevron_left, color: AppColors.textTertiary),
@@ -387,7 +396,7 @@ class _AdminTicketCard extends StatelessWidget {
         color: AppColors.textTertiary.withOpacity(0.1),
         borderRadius: BorderRadius.circular(4),
       ),
-      child: Text(label, style: TextStyle(color: AppColors.textSecondary, fontSize: 10)),
+      child: Text(label, style: const TextStyle(color: AppColors.textSecondary, fontSize: 10)),
     );
   }
 
diff --git a/lib/screens/admin/admin_ticket_detail_screen.dart b/lib/screens/admin/admin_ticket_detail_screen.dart
index 459c6a0..3bf4adf 100644
--- a/lib/screens/admin/admin_ticket_detail_screen.dart
+++ b/lib/screens/admin/admin_ticket_detail_screen.dart
@@ -120,7 +120,7 @@ class _AdminTicketDetailScreenState extends ConsumerState<AdminTicketDetailScree
                 ListTile(
                   leading: const Icon(Icons.circle, color: AppColors.warning),
                   title: const Text('باز', style: TextStyle(color: AppColors.textPrimary)),
-                  subtitle: Text('تیکت نیاز به بررسی دارد', style: TextStyle(color: AppColors.textTertiary)),
+                  subtitle: const Text('تیکت نیاز به بررسی دارد', style: TextStyle(color: AppColors.textTertiary)),
                   onTap: () {
                     Navigator.pop(context);
                     _changeStatus('open');
@@ -129,7 +129,7 @@ class _AdminTicketDetailScreenState extends ConsumerState<AdminTicketDetailScree
                 ListTile(
                   leading: const Icon(Icons.circle, color: AppColors.primary),
                   title: const Text('در حال بررسی', style: TextStyle(color: AppColors.textPrimary)),
-                  subtitle: Text('تیکت در حال پیگیری است', style: TextStyle(color: AppColors.textTertiary)),
+                  subtitle: const Text('تیکت در حال پیگیری است', style: TextStyle(color: AppColors.textTertiary)),
                   onTap: () {
                     Navigator.pop(context);
                     _changeStatus('in_progress');
@@ -138,7 +138,7 @@ class _AdminTicketDetailScreenState extends ConsumerState<AdminTicketDetailScree
                 ListTile(
                   leading: const Icon(Icons.circle, color: AppColors.success),
                   title: const Text('بسته شده', style: TextStyle(color: AppColors.textPrimary)),
-                  subtitle: Text('مشکل حل شده است', style: TextStyle(color: AppColors.textTertiary)),
+                  subtitle: const Text('مشکل حل شده است', style: TextStyle(color: AppColors.textTertiary)),
                   onTap: () {
                     Navigator.pop(context);
                     _changeStatus('closed');
@@ -241,7 +241,7 @@ class _AdminTicketDetailScreenState extends ConsumerState<AdminTicketDetailScree
                                 ),
                                 Text(
                                   (profile?['email'] as String?) ?? '',
-                                  style: TextStyle(color: AppColors.textTertiary, fontSize: 12),
+                                  style: const TextStyle(color: AppColors.textTertiary, fontSize: 12),
                                 ),
                               ],
                             ),
@@ -274,7 +274,7 @@ class _AdminTicketDetailScreenState extends ConsumerState<AdminTicketDetailScree
                           const SizedBox(width: 12),
                           Text(
                             'ایجاد: ${_formatDate(ticket['created_at'])}',
-                            style: TextStyle(color: AppColors.textTertiary, fontSize: 11),
+                            style: const TextStyle(color: AppColors.textTertiary, fontSize: 11),
                           ),
                         ],
                       ),
@@ -454,7 +454,7 @@ class _AdminTicketDetailScreenState extends ConsumerState<AdminTicketDetailScree
         color: AppColors.textTertiary.withOpacity(0.1),
         borderRadius: BorderRadius.circular(4),
       ),
-      child: Text(label, style: TextStyle(color: AppColors.textSecondary, fontSize: 11)),
+      child: Text(label, style: const TextStyle(color: AppColors.textSecondary, fontSize: 11)),
     );
   }
 }
@@ -484,10 +484,10 @@ class _MessageBubble extends StatelessWidget {
         mainAxisAlignment: isAdmin ? MainAxisAlignment.end : MainAxisAlignment.start,
         children: [
           if (!isAdmin) ...[
-            CircleAvatar(
+            const CircleAvatar(
               radius: 18,
               backgroundColor: AppColors.surfaceLight,
-              child: const Icon(Icons.person, color: AppColors.textSecondary, size: 20),
+              child: Icon(Icons.person, color: AppColors.textSecondary, size: 20),
             ),
             const SizedBox(width: 8),
           ],
@@ -524,7 +524,7 @@ class _MessageBubble extends StatelessWidget {
                       if (createdAt != null)
                         Text(
                           '${createdAt.hour.toString().padLeft(2, '0')}:${createdAt.minute.toString().padLeft(2, '0')}',
-                          style: TextStyle(color: AppColors.textTertiary, fontSize: 10),
+                          style: const TextStyle(color: AppColors.textTertiary, fontSize: 10),
                         ),
                     ],
                   ),
@@ -539,10 +539,10 @@ class _MessageBubble extends StatelessWidget {
           ),
           if (isAdmin) ...[
             const SizedBox(width: 8),
-            CircleAvatar(
+            const CircleAvatar(
               radius: 18,
               backgroundColor: AppColors.primary,
-              child: const Icon(Icons.support_agent, color: Colors.white, size: 20),
+              child: Icon(Icons.support_agent, color: Colors.white, size: 20),
             ),
           ],
         ],
diff --git a/lib/screens/admin/admin_upload_audiobook_screen.dart b/lib/screens/admin/admin_upload_audiobook_screen.dart
index 827e467..b2e859c 100644
--- a/lib/screens/admin/admin_upload_audiobook_screen.dart
+++ b/lib/screens/admin/admin_upload_audiobook_screen.dart
@@ -2,12 +2,13 @@ import 'dart:typed_data';
 import 'package:flutter/material.dart';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
 import 'package:supabase_flutter/supabase_flutter.dart';
-import 'package:file_picker/file_picker.dart';
+import 'package:image_picker/image_picker.dart';
 import 'package:myna/theme/app_theme.dart';
 import 'package:myna/config/env.dart';
 import 'package:myna/utils/app_logger.dart';
 import 'package:myna/screens/admin/admin_bulk_chapter_upload_screen.dart';
 import 'package:myna/providers/home_providers.dart';
+import 'package:myna/services/creator_service.dart';
 
 /// Provider to fetch narrators (users with role='narrator')
 final narratorsProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
@@ -20,6 +21,16 @@ final narratorsProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async
   return List<Map<String, dynamic>>.from(response);
 });
 
+/// Provider to fetch music categories (سبک‌های موسیقی)
+final musicCategoriesProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
+  final response = await Supabase.instance.client
+      .from('music_categories')
+      .select('id, name_fa, name_en, icon, is_active')
+      .eq('is_active', true)
+      .order('sort_order');
+  return List<Map<String, dynamic>>.from(response);
+});
+
 class AdminUploadAudiobookScreen extends ConsumerStatefulWidget {
   const AdminUploadAudiobookScreen({super.key});
 
@@ -30,17 +41,53 @@ class AdminUploadAudiobookScreen extends ConsumerStatefulWidget {
 class _AdminUploadAudiobookScreenState extends ConsumerState<AdminUploadAudiobookScreen> {
   final _formKey = GlobalKey<FormState>();
 
-  // Form controllers
+  // Core form controllers
   final _titleFaController = TextEditingController();
   final _titleEnController = TextEditingController();
   final _descriptionFaController = TextEditingController();
   final _descriptionEnController = TextEditingController();
   final _priceController = TextEditingController(text: '0');
 
+  // BOOK metadata controllers (کتاب صوتی)
+  final _authorNameController = TextEditingController();
+  final _authorNameEnController = TextEditingController();
+  final _coAuthorsController = TextEditingController();
+  final _translatorController = TextEditingController();
+  final _translatorEnController = TextEditingController();
+  final _narratorNameController = TextEditingController();
+  final _narratorNameEnController = TextEditingController();
+  final _publisherController = TextEditingController();
+  final _publisherEnController = TextEditingController();
+  final _publicationYearController = TextEditingController();
+  final _isbnController = TextEditingController();
+
+  // MUSIC metadata controllers (موسیقی)
+  final _artistNameController = TextEditingController();
+  final _artistNameEnController = TextEditingController();
+  final _featuredArtistsController = TextEditingController();
+  final _composerController = TextEditingController();
+  final _composerEnController = TextEditingController();
+  final _lyricistController = TextEditingController();
+  final _lyricistEnController = TextEditingController();
+  final _albumTitleController = TextEditingController();
+  final _albumTitleEnController = TextEditingController();
+  final _labelController = TextEditingController();
+  final _labelEnController = TextEditingController();
+  final _genreController = TextEditingController();
+  final _genreEnController = TextEditingController();
+  final _releaseYearController = TextEditingController();
+
+  // Note: Legacy author/translator columns are now filled from the new metadata controllers
+  // For books: _authorNameController -> author_fa, _translatorController -> translator_fa
+  // For music: _artistNameController -> author_fa
+
   // State
   String? _selectedNarratorId;
   int? _selectedCategoryId;
+  final List<int> _selectedMusicCategoryIds = []; // For music: multiple categories
   bool _isFree = true;
+  bool _isMusic = false; // Content type: false = audiobook, true = music
+  bool _isParastoBrand = true; // Default to Parasto brand (narrator optional)
   bool _isLoading = false;
   String? _error;
 
@@ -50,30 +97,61 @@ class _AdminUploadAudiobookScreenState extends ConsumerState<AdminUploadAudioboo
 
   @override
   void dispose() {
+    // Core controllers
     _titleFaController.dispose();
     _titleEnController.dispose();
     _descriptionFaController.dispose();
     _descriptionEnController.dispose();
     _priceController.dispose();
+
+    // Book metadata controllers
+    _authorNameController.dispose();
+    _authorNameEnController.dispose();
+    _coAuthorsController.dispose();
+    _translatorController.dispose();
+    _translatorEnController.dispose();
+    _narratorNameController.dispose();
+    _narratorNameEnController.dispose();
+    _publisherController.dispose();
+    _publisherEnController.dispose();
+    _publicationYearController.dispose();
+    _isbnController.dispose();
+
+    // Music metadata controllers
+    _artistNameController.dispose();
+    _artistNameEnController.dispose();
+    _featuredArtistsController.dispose();
+    _composerController.dispose();
+    _composerEnController.dispose();
+    _lyricistController.dispose();
+    _lyricistEnController.dispose();
+    _albumTitleController.dispose();
+    _albumTitleEnController.dispose();
+    _labelController.dispose();
+    _labelEnController.dispose();
+    _genreController.dispose();
+    _genreEnController.dispose();
+    _releaseYearController.dispose();
+
     super.dispose();
   }
 
   Future<void> _pickCoverImage() async {
     try {
-      final result = await FilePicker.platform.pickFiles(
-        type: FileType.image,
-        allowMultiple: false,
-        withData: true,
+      final picker = ImagePicker();
+      final XFile? image = await picker.pickImage(
+        source: ImageSource.gallery,
+        maxWidth: 1200,
+        maxHeight: 1200,
+        imageQuality: 85,
       );
 
-      if (result != null && result.files.isNotEmpty) {
-        final file = result.files.first;
-        if (file.bytes != null) {
-          setState(() {
-            _coverImageBytes = file.bytes;
-            _coverFileName = file.name;
-          });
-        }
+      if (image != null) {
+        final bytes = await image.readAsBytes();
+        setState(() {
+          _coverImageBytes = bytes;
+          _coverFileName = image.name;
+        });
       }
     } catch (e) {
       setState(() => _error = 'خطا در انتخاب تصویر: $e');
@@ -82,11 +160,12 @@ class _AdminUploadAudiobookScreenState extends ConsumerState<AdminUploadAudioboo
 
   Future<String?> _uploadCoverImage() async {
     if (_coverImageBytes == null || _coverFileName == null) return null;
-    if (_selectedNarratorId == null) return null;
 
     final timestamp = DateTime.now().millisecondsSinceEpoch;
     final extension = _coverFileName!.split('.').last;
-    final path = '$_selectedNarratorId/$timestamp.$extension';
+    // Use narrator ID if selected, otherwise use 'parasto' folder
+    final folder = _selectedNarratorId ?? 'parasto';
+    final path = '$folder/$timestamp.$extension';
 
     try {
       await Supabase.instance.client.storage
@@ -107,13 +186,20 @@ class _AdminUploadAudiobookScreenState extends ConsumerState<AdminUploadAudioboo
   Future<void> _submitBook() async {
     if (!_formKey.currentState!.validate()) return;
 
-    if (_selectedNarratorId == null) {
-      setState(() => _error = 'لطفاً گوینده را انتخاب کنید');
+    // For audiobooks, category is required. For music, at least one music category is required.
+    if (!_isMusic && _selectedCategoryId == null) {
+      setState(() => _error = 'لطفاً دسته‌بندی را انتخاب کنید');
       return;
     }
 
-    if (_selectedCategoryId == null) {
-      setState(() => _error = 'لطفاً دسته‌بندی را انتخاب کنید');
+    if (_isMusic && _selectedMusicCategoryIds.isEmpty) {
+      setState(() => _error = 'لطفاً حداقل یک سبک موسیقی انتخاب کنید');
+      return;
+    }
+
+    // Narrator is optional - if not selected, must be Parasto brand
+    if (_selectedNarratorId == null && !_isParastoBrand) {
+      setState(() => _error = 'برای آپلود بدون گوینده، باید گزینه «پرستو» فعال باشد');
       return;
     }
 
@@ -135,51 +221,211 @@ class _AdminUploadAudiobookScreenState extends ConsumerState<AdminUploadAudioboo
         throw Exception('خطا در آپلود تصویر جلد');
       }
 
-      // 2. Create audiobook record
+      // 2. Create audiobook record - with orphan file cleanup on failure
       final price = _isFree ? 0 : int.tryParse(_priceController.text) ?? 0;
 
-      final response = await Supabase.instance.client
-          .from('audiobooks')
-          .insert({
-            'title_fa': _titleFaController.text.trim(),
-            'title_en': _titleEnController.text.trim().isEmpty
-                ? null
-                : _titleEnController.text.trim(),
-            'description_fa': _descriptionFaController.text.trim(),
-            'description_en': _descriptionEnController.text.trim().isEmpty
-                ? null
-                : _descriptionEnController.text.trim(),
-            'category_id': _selectedCategoryId,
-            'narrator_id': _selectedNarratorId,
-            'cover_url': coverUrl,
-            'price_toman': price,
-            'is_free': _isFree,
-            'status': 'draft', // Admin creates as draft, can approve later
-            'language': 'fa',
-            'chapter_count': 0,
-            'total_duration_seconds': 0,
-            'play_count': 0,
-            'purchase_count': 0,
-            'review_count': 0,
-            'is_featured': false,
-          })
-          .select()
-          .single();
+      // Get current admin's user ID to use as narrator_id if no narrator selected
+      final adminId = Supabase.instance.client.auth.currentUser?.id;
+
+      // For legacy compatibility, map new metadata fields to old author/translator columns
+      // Books: use author_name, translator
+      // Music: use artist_name
+      final legacyAuthorFa = _isMusic
+          ? _artistNameController.text.trim()
+          : _authorNameController.text.trim();
+      final legacyAuthorEn = _isMusic
+          ? _artistNameEnController.text.trim()
+          : _authorNameEnController.text.trim();
+      final legacyTranslatorFa = _isMusic
+          ? null
+          : _translatorController.text.trim();
+      final legacyTranslatorEn = _isMusic
+          ? null
+          : _translatorEnController.text.trim();
+
+      // Extract cover path from URL for potential cleanup
+      String? coverPath;
+      try {
+        final uri = Uri.parse(coverUrl);
+        final pathSegments = uri.pathSegments;
+        final bucketIndex = pathSegments.indexOf('audiobook-covers');
+        if (bucketIndex != -1 && bucketIndex < pathSegments.length - 1) {
+          coverPath = pathSegments.sublist(bucketIndex + 1).join('/');
+        }
+      } catch (_) {}
+
+      late final Map<String, dynamic> response;
+      try {
+        response = await Supabase.instance.client
+            .from('audiobooks')
+            .insert({
+              'title_fa': _titleFaController.text.trim(),
+              'title_en': _titleEnController.text.trim().isEmpty
+                  ? null
+                  : _titleEnController.text.trim(),
+              // Legacy columns (for backwards compatibility)
+              'author_fa': legacyAuthorFa.isEmpty ? null : legacyAuthorFa,
+              'author_en': legacyAuthorEn.isEmpty ? null : legacyAuthorEn,
+              'translator_fa': legacyTranslatorFa?.isEmpty ?? true ? null : legacyTranslatorFa,
+              'translator_en': legacyTranslatorEn?.isEmpty ?? true ? null : legacyTranslatorEn,
+              'description_fa': _descriptionFaController.text.trim(),
+              'description_en': _descriptionEnController.text.trim().isEmpty
+                  ? null
+                  : _descriptionEnController.text.trim(),
+              'category_id': _isMusic ? null : _selectedCategoryId, // Only for books
+              'narrator_id': _selectedNarratorId ?? adminId, // Use admin's ID if no narrator
+              'cover_url': coverUrl,
+              'price_toman': price,
+              'is_free': _isFree,
+              'is_music': _isMusic, // Content type flag
+              'is_parasto_brand': _isParastoBrand, // Display as "پرستو" brand
+              'status': 'draft', // Admin creates as draft, can approve later
+              'language': 'fa',
+              'chapter_count': 0,
+              'total_duration_seconds': 0,
+              'play_count': 0,
+              'purchase_count': 0,
+              'review_count': 0,
+              'is_featured': false,
+            })
+            .select()
+            .single();
+      } catch (dbError) {
+        // DB insert failed - clean up orphan cover file from storage
+        if (coverPath != null) {
+          AppLogger.w('Admin audiobook DB insert failed, cleaning up cover: $coverPath');
+          try {
+            await Supabase.instance.client.storage.from(Env.coversBucket).remove([coverPath]);
+          } catch (cleanupError) {
+            AppLogger.e('Failed to cleanup orphan cover: $coverPath', error: cleanupError);
+          }
+        }
+        rethrow;
+      }
 
       final audiobookId = response['id'] as int?;
       final audiobookTitle = (response['title_fa'] as String?) ?? '';
 
-      AppLogger.i('Admin created book with ID: $audiobookId');
+      AppLogger.i('Admin created ${_isMusic ? "music" : "book"} with ID: $audiobookId');
 
       if (audiobookId == null || audiobookId <= 0) {
-        throw Exception('شناسه کتاب برگردانده نشد');
+        throw Exception('شناسه محتوا برگردانده نشد');
+      }
+
+      // 3. Insert into book_metadata or music_metadata table
+      if (_isMusic) {
+        // Insert music metadata
+        await Supabase.instance.client
+            .from('music_metadata')
+            .insert({
+              'audiobook_id': audiobookId,
+              'artist_name': _artistNameController.text.trim().isEmpty
+                  ? null : _artistNameController.text.trim(),
+              'artist_name_en': _artistNameEnController.text.trim().isEmpty
+                  ? null : _artistNameEnController.text.trim(),
+              'featured_artists': _featuredArtistsController.text.trim().isEmpty
+                  ? null : _featuredArtistsController.text.trim(),
+              'composer': _composerController.text.trim().isEmpty
+                  ? null : _composerController.text.trim(),
+              'composer_en': _composerEnController.text.trim().isEmpty
+                  ? null : _composerEnController.text.trim(),
+              'lyricist': _lyricistController.text.trim().isEmpty
+                  ? null : _lyricistController.text.trim(),
+              'lyricist_en': _lyricistEnController.text.trim().isEmpty
+                  ? null : _lyricistEnController.text.trim(),
+              'album_title': _albumTitleController.text.trim().isEmpty
+                  ? null : _albumTitleController.text.trim(),
+              'album_title_en': _albumTitleEnController.text.trim().isEmpty
+                  ? null : _albumTitleEnController.text.trim(),
+              'label': _labelController.text.trim().isEmpty
+                  ? null : _labelController.text.trim(),
+              'label_en': _labelEnController.text.trim().isEmpty
+                  ? null : _labelEnController.text.trim(),
+              'genre': _genreController.text.trim().isEmpty
+                  ? null : _genreController.text.trim(),
+              'genre_en': _genreEnController.text.trim().isEmpty
+                  ? null : _genreEnController.text.trim(),
+              'release_year': _releaseYearController.text.trim().isEmpty
+                  ? null : int.tryParse(_releaseYearController.text.trim()),
+            });
+        AppLogger.i('Music metadata inserted for audiobook $audiobookId');
+      } else {
+        // Insert book metadata
+        await Supabase.instance.client
+            .from('book_metadata')
+            .insert({
+              'audiobook_id': audiobookId,
+              'author_name': _authorNameController.text.trim().isEmpty
+                  ? null : _authorNameController.text.trim(),
+              'author_name_en': _authorNameEnController.text.trim().isEmpty
+                  ? null : _authorNameEnController.text.trim(),
+              'co_authors': _coAuthorsController.text.trim().isEmpty
+                  ? null : _coAuthorsController.text.trim(),
+              'translator': _translatorController.text.trim().isEmpty
+                  ? null : _translatorController.text.trim(),
+              'translator_en': _translatorEnController.text.trim().isEmpty
+                  ? null : _translatorEnController.text.trim(),
+              'narrator_name': _narratorNameController.text.trim().isEmpty
+                  ? null : _narratorNameController.text.trim(),
+              'narrator_name_en': _narratorNameEnController.text.trim().isEmpty
+                  ? null : _narratorNameEnController.text.trim(),
+              'publisher': _publisherController.text.trim().isEmpty
+                  ? null : _publisherController.text.trim(),
+              'publisher_en': _publisherEnController.text.trim().isEmpty
+                  ? null : _publisherEnController.text.trim(),
+              'publication_year': _publicationYearController.text.trim().isEmpty
+                  ? null : int.tryParse(_publicationYearController.text.trim()),
+              'isbn': _isbnController.text.trim().isEmpty
+                  ? null : _isbnController.text.trim(),
+            });
+        AppLogger.i('Book metadata inserted for audiobook $audiobookId');
       }
 
-      // 3. Show success and navigate to bulk chapter upload
+      // 4. If music, insert music category associations
+      if (_isMusic && _selectedMusicCategoryIds.isNotEmpty) {
+        final musicCategoryRows = _selectedMusicCategoryIds.map((catId) => {
+          'audiobook_id': audiobookId,
+          'music_category_id': catId,
+        }).toList();
+
+        await Supabase.instance.client
+            .from('audiobook_music_categories')
+            .insert(musicCategoryRows);
+      }
+
+      // 5. Auto-sync creators from metadata fields
+      final creatorService = CreatorService();
+      await creatorService.syncCreatorsForAudiobook(
+        audiobookId: audiobookId,
+        isMusic: _isMusic,
+        // Book fields
+        authorName: _isMusic ? null : _authorNameController.text,
+        authorNameEn: _isMusic ? null : _authorNameEnController.text,
+        translatorName: _isMusic ? null : _translatorController.text,
+        translatorNameEn: _isMusic ? null : _translatorEnController.text,
+        narratorName: _isMusic ? null : _narratorNameController.text,
+        narratorNameEn: _isMusic ? null : _narratorNameEnController.text,
+        publisherName: _isMusic ? null : _publisherController.text,
+        publisherNameEn: _isMusic ? null : _publisherEnController.text,
+        // Music fields
+        artistName: _isMusic ? _artistNameController.text : null,
+        artistNameEn: _isMusic ? _artistNameEnController.text : null,
+        composerName: _isMusic ? _composerController.text : null,
+        composerNameEn: _isMusic ? _composerEnController.text : null,
+        lyricistName: _isMusic ? _lyricistController.text : null,
+        lyricistNameEn: _isMusic ? _lyricistEnController.text : null,
+        labelName: _isMusic ? _labelController.text : null,
+        labelNameEn: _isMusic ? _labelEnController.text : null,
+      );
+      AppLogger.i('Creator sync completed for audiobook $audiobookId');
+
+      // 6. Show success and navigate to bulk chapter upload
       if (mounted) {
         ScaffoldMessenger.of(context).showSnackBar(
-          const SnackBar(
-            content: Text('کتاب با موفقیت ایجاد شد. حالا فصل‌ها را اضافه کنید.'),
+          SnackBar(
+            content: Text(_isMusic
+                ? 'موسیقی با موفقیت ایجاد شد. حالا فایل‌ها را اضافه کنید.'
+                : 'کتاب با موفقیت ایجاد شد. حالا فصل‌ها را اضافه کنید.'),
             backgroundColor: AppColors.success,
           ),
         );
@@ -191,7 +437,7 @@ class _AdminUploadAudiobookScreenState extends ConsumerState<AdminUploadAudioboo
             builder: (context) => AdminBulkChapterUploadScreen(
               audiobookId: audiobookId,
               audiobookTitle: audiobookTitle,
-              narratorId: _selectedNarratorId!,
+              narratorId: _selectedNarratorId ?? adminId ?? '',
             ),
           ),
         );
@@ -214,6 +460,7 @@ class _AdminUploadAudiobookScreenState extends ConsumerState<AdminUploadAudioboo
   Widget build(BuildContext context) {
     final categoriesAsync = ref.watch(formCategoriesProvider);
     final narratorsAsync = ref.watch(narratorsProvider);
+    final musicCategoriesAsync = ref.watch(musicCategoriesProvider);
 
     return Directionality(
       textDirection: TextDirection.rtl,
@@ -221,7 +468,7 @@ class _AdminUploadAudiobookScreenState extends ConsumerState<AdminUploadAudioboo
         backgroundColor: AppColors.background,
         appBar: AppBar(
           backgroundColor: AppColors.background,
-          title: const Text('آپلود کتاب (ادمین)'),
+          title: Text(_isMusic ? 'آپلود موسیقی (ادمین)' : 'آپلود کتاب (ادمین)'),
           centerTitle: true,
         ),
         body: SingleChildScrollView(
@@ -231,6 +478,10 @@ class _AdminUploadAudiobookScreenState extends ConsumerState<AdminUploadAudioboo
             child: Column(
               crossAxisAlignment: CrossAxisAlignment.stretch,
               children: [
+                // Content Type Toggle (Book vs Music) - First!
+                _buildContentTypeToggle(),
+                const SizedBox(height: 20),
+
                 // Info banner
                 Container(
                   padding: const EdgeInsets.all(12),
@@ -241,12 +492,14 @@ class _AdminUploadAudiobookScreenState extends ConsumerState<AdminUploadAudioboo
                   ),
                   child: Row(
                     children: [
-                      const Icon(Icons.admin_panel_settings, color: AppColors.primary),
+                      Icon(_isMusic ? Icons.music_note : Icons.admin_panel_settings, color: AppColors.primary),
                       const SizedBox(width: 8),
-                      const Expanded(
+                      Expanded(
                         child: Text(
-                          'شما در حال آپلود کتاب به نمایندگی از گوینده هستید',
-                          style: TextStyle(color: AppColors.primary, fontSize: 13),
+                          _isParastoBrand
+                              ? 'این محتوا به نام «پرستو» منتشر می‌شود'
+                              : 'آپلود به نمایندگی از گوینده انتخابی',
+                          style: const TextStyle(color: AppColors.primary, fontSize: 13),
                         ),
                       ),
                     ],
@@ -254,13 +507,19 @@ class _AdminUploadAudiobookScreenState extends ConsumerState<AdminUploadAudioboo
                 ),
                 const SizedBox(height: 20),
 
-                // Narrator selector
-                narratorsAsync.when(
-                  loading: () => const LinearProgressIndicator(),
-                  error: (e, _) => Text('خطا در بارگذاری گویندگان: $e'),
-                  data: (narrators) => _buildNarratorSelector(narrators),
-                ),
-                const SizedBox(height: 20),
+                // Parasto Brand Toggle - Important decision first
+                _buildParastoBrandToggle(),
+                const SizedBox(height: 16),
+
+                // Narrator selector (optional, only show if not Parasto brand)
+                if (!_isParastoBrand) ...[
+                  narratorsAsync.when(
+                    loading: () => const LinearProgressIndicator(),
+                    error: (e, _) => Text('خطا در بارگذاری گویندگان: $e'),
+                    data: _buildNarratorSelector,
+                  ),
+                  const SizedBox(height: 20),
+                ],
 
                 // Cover Image Picker
                 _buildCoverPicker(),
@@ -269,10 +528,10 @@ class _AdminUploadAudiobookScreenState extends ConsumerState<AdminUploadAudioboo
                 // Persian Title (Required)
                 TextFormField(
                   controller: _titleFaController,
-                  decoration: const InputDecoration(
+                  decoration: InputDecoration(
                     labelText: 'عنوان فارسی *',
-                    hintText: 'مثال: شازده کوچولو',
-                    prefixIcon: Icon(Icons.title),
+                    hintText: _isMusic ? 'مثال: آهنگ زیبا' : 'مثال: شازده کوچولو',
+                    prefixIcon: const Icon(Icons.title),
                   ),
                   validator: (value) {
                     if (value == null || value.trim().isEmpty) {
@@ -286,49 +545,59 @@ class _AdminUploadAudiobookScreenState extends ConsumerState<AdminUploadAudioboo
                 // English Title (Optional)
                 TextFormField(
                   controller: _titleEnController,
-                  decoration: const InputDecoration(
+                  decoration: InputDecoration(
                     labelText: 'عنوان انگلیسی (اختیاری)',
-                    hintText: 'Example: The Little Prince',
-                    prefixIcon: Icon(Icons.title),
+                    hintText: _isMusic ? 'Example: Beautiful Song' : 'Example: The Little Prince',
+                    prefixIcon: const Icon(Icons.title),
                   ),
                   textDirection: TextDirection.ltr,
                 ),
+                const SizedBox(height: 24),
+
+                // Author/Artist Section (dynamic based on content type)
+                _buildAuthorArtistSection(),
                 const SizedBox(height: 16),
 
-                // Category Dropdown
-                categoriesAsync.when(
-                  loading: () => const LinearProgressIndicator(),
-                  error: (e, _) => Text('خطا در بارگذاری دسته‌ها: $e'),
-                  data: (categories) => DropdownButtonFormField<int>(
-                    value: _selectedCategoryId,
-                    decoration: const InputDecoration(
-                      labelText: 'دسته‌بندی *',
-                      prefixIcon: Icon(Icons.category),
+                // Category Selection - Different for books vs music
+                if (_isMusic) ...[
+                  // Music Categories (multi-select)
+                  musicCategoriesAsync.when(
+                    loading: () => const LinearProgressIndicator(),
+                    error: (e, _) => Text('خطا در بارگذاری سبک‌ها: $e'),
+                    data: _buildMusicCategoriesSelector,
+                  ),
+                ] else ...[
+                  // Book Category Dropdown (single select)
+                  categoriesAsync.when(
+                    loading: () => const LinearProgressIndicator(),
+                    error: (e, _) => Text('خطا در بارگذاری دسته‌ها: $e'),
+                    data: (categories) => DropdownButtonFormField<int>(
+                      value: _selectedCategoryId,
+                      decoration: const InputDecoration(
+                        labelText: 'دسته‌بندی *',
+                        prefixIcon: Icon(Icons.category),
+                      ),
+                      items: categories.map((cat) {
+                        return DropdownMenuItem<int>(
+                          value: cat['id'] as int,
+                          child: Text((cat['name_fa'] as String?) ?? ''),
+                        );
+                      }).toList(),
+                      onChanged: (value) {
+                        setState(() => _selectedCategoryId = value);
+                      },
                     ),
-                    items: categories.map((cat) {
-                      return DropdownMenuItem<int>(
-                        value: cat['id'] as int,
-                        child: Text((cat['name_fa'] as String?) ?? ''),
-                      );
-                    }).toList(),
-                    onChanged: (value) {
-                      setState(() => _selectedCategoryId = value);
-                    },
-                    validator: (value) {
-                      if (value == null) return 'دسته‌بندی الزامی است';
-                      return null;
-                    },
                   ),
-                ),
+                ],
                 const SizedBox(height: 16),
 
                 // Persian Description
                 TextFormField(
                   controller: _descriptionFaController,
-                  decoration: const InputDecoration(
+                  decoration: InputDecoration(
                     labelText: 'توضیحات فارسی *',
-                    hintText: 'درباره کتاب بنویسید...',
-                    prefixIcon: Icon(Icons.description),
+                    hintText: _isMusic ? 'درباره این موسیقی بنویسید...' : 'درباره کتاب بنویسید...',
+                    prefixIcon: const Icon(Icons.description),
                     alignLabelWithHint: true,
                   ),
                   maxLines: 4,
@@ -344,10 +613,10 @@ class _AdminUploadAudiobookScreenState extends ConsumerState<AdminUploadAudioboo
                 // English Description (Optional)
                 TextFormField(
                   controller: _descriptionEnController,
-                  decoration: const InputDecoration(
+                  decoration: InputDecoration(
                     labelText: 'توضیحات انگلیسی (اختیاری)',
-                    hintText: 'Write about the book...',
-                    prefixIcon: Icon(Icons.description),
+                    hintText: _isMusic ? 'Write about this music...' : 'Write about the book...',
+                    prefixIcon: const Icon(Icons.description),
                     alignLabelWithHint: true,
                   ),
                   maxLines: 4,
@@ -417,7 +686,7 @@ class _AdminUploadAudiobookScreenState extends ConsumerState<AdminUploadAudioboo
       crossAxisAlignment: CrossAxisAlignment.start,
       children: [
         const Text(
-          'انتخاب گوینده *',
+          'انتخاب گوینده (اختیاری)',
           style: TextStyle(
             color: AppColors.textPrimary,
             fontWeight: FontWeight.w600,
@@ -425,7 +694,7 @@ class _AdminUploadAudiobookScreenState extends ConsumerState<AdminUploadAudioboo
           ),
         ),
         const SizedBox(height: 8),
-        Container(
+        DecoratedBox(
           decoration: BoxDecoration(
             color: AppColors.surface,
             borderRadius: BorderRadius.circular(12),
@@ -570,7 +839,7 @@ class _AdminUploadAudiobookScreenState extends ConsumerState<AdminUploadAudioboo
                     ),
                   ),
                   const SizedBox(height: 4),
-                  Text(
+                  const Text(
                     'حداکثر ۱۰ مگابایت',
                     style: TextStyle(
                       color: AppColors.textTertiary,
@@ -583,6 +852,185 @@ class _AdminUploadAudiobookScreenState extends ConsumerState<AdminUploadAudioboo
     );
   }
 
+  Widget _buildContentTypeToggle() {
+    return Container(
+      padding: const EdgeInsets.all(16),
+      decoration: BoxDecoration(
+        color: AppColors.surface,
+        borderRadius: BorderRadius.circular(12),
+        border: Border.all(color: AppColors.border),
+      ),
+      child: Column(
+        crossAxisAlignment: CrossAxisAlignment.start,
+        children: [
+          const Row(
+            children: [
+              Icon(Icons.category, color: AppColors.primary, size: 20),
+              SizedBox(width: 8),
+              Text(
+                'نوع محتوا',
+                style: TextStyle(
+                  fontSize: 14,
+                  fontWeight: FontWeight.bold,
+                  color: AppColors.textPrimary,
+                ),
+              ),
+            ],
+          ),
+          const SizedBox(height: 12),
+          Row(
+            children: [
+              // Audiobook option
+              Expanded(
+                child: GestureDetector(
+                  onTap: () => setState(() => _isMusic = false),
+                  child: Container(
+                    padding: const EdgeInsets.symmetric(vertical: 12),
+                    decoration: BoxDecoration(
+                      color: !_isMusic
+                          ? AppColors.primary.withOpacity(0.1)
+                          : Colors.transparent,
+                      borderRadius: BorderRadius.circular(8),
+                      border: Border.all(
+                        color: !_isMusic
+                            ? AppColors.primary
+                            : AppColors.border,
+                        width: !_isMusic ? 2 : 1,
+                      ),
+                    ),
+                    child: Column(
+                      children: [
+                        Icon(
+                          Icons.headphones,
+                          size: 28,
+                          color: !_isMusic
+                              ? AppColors.primary
+                              : AppColors.textTertiary,
+                        ),
+                        const SizedBox(height: 6),
+                        Text(
+                          'کتاب صوتی',
+                          style: TextStyle(
+                            fontSize: 13,
+                            fontWeight: !_isMusic
+                                ? FontWeight.w600
+                                : FontWeight.normal,
+                            color: !_isMusic
+                                ? AppColors.primary
+                                : AppColors.textSecondary,
+                          ),
+                        ),
+                      ],
+                    ),
+                  ),
+                ),
+              ),
+              const SizedBox(width: 12),
+              // Music option
+              Expanded(
+                child: GestureDetector(
+                  onTap: () => setState(() => _isMusic = true),
+                  child: Container(
+                    padding: const EdgeInsets.symmetric(vertical: 12),
+                    decoration: BoxDecoration(
+                      color: _isMusic
+                          ? AppColors.primary.withOpacity(0.1)
+                          : Colors.transparent,
+                      borderRadius: BorderRadius.circular(8),
+                      border: Border.all(
+                        color: _isMusic
+                            ? AppColors.primary
+                            : AppColors.border,
+                        width: _isMusic ? 2 : 1,
+                      ),
+                    ),
+                    child: Column(
+                      children: [
+                        Icon(
+                          Icons.music_note,
+                          size: 28,
+                          color: _isMusic
+                              ? AppColors.primary
+                              : AppColors.textTertiary,
+                        ),
+                        const SizedBox(height: 6),
+                        Text(
+                          'موسیقی',
+                          style: TextStyle(
+                            fontSize: 13,
+                            fontWeight: _isMusic
+                                ? FontWeight.w600
+                                : FontWeight.normal,
+                            color: _isMusic
+                                ? AppColors.primary
+                                : AppColors.textSecondary,
+                          ),
+                        ),
+                      ],
+                    ),
+                  ),
+                ),
+              ),
+            ],
+          ),
+        ],
+      ),
+    );
+  }
+
+  Widget _buildParastoBrandToggle() {
+    return Container(
+      padding: const EdgeInsets.all(16),
+      decoration: BoxDecoration(
+        color: AppColors.surface,
+        borderRadius: BorderRadius.circular(12),
+        border: _isParastoBrand
+            ? Border.all(color: AppColors.primary.withOpacity(0.5), width: 2)
+            : null,
+      ),
+      child: Row(
+        children: [
+          Icon(
+            _isParastoBrand ? Icons.verified : Icons.verified_outlined,
+            color: _isParastoBrand ? AppColors.primary : AppColors.textTertiary,
+          ),
+          const SizedBox(width: 12),
+          Expanded(
+            child: Column(
+              crossAxisAlignment: CrossAxisAlignment.start,
+              children: [
+                const Text(
+                  'نمایش به نام پرستو',
+                  style: TextStyle(
+                    fontSize: 16,
+                    fontWeight: FontWeight.bold,
+                    color: AppColors.textPrimary,
+                  ),
+                ),
+                Text(
+                  _isParastoBrand
+                      ? 'این کتاب به نام «پرستو» نمایش داده می‌شود'
+                      : 'نام گوینده نمایش داده می‌شود',
+                  style: const TextStyle(
+                    fontSize: 12,
+                    color: AppColors.textSecondary,
+                  ),
+                ),
+              ],
+            ),
+          ),
+          Switch(
+            value: _isParastoBrand,
+            onChanged: (value) {
+              setState(() => _isParastoBrand = value);
+            },
+            activeColor: AppColors.primary,
+          ),
+        ],
+      ),
+    );
+  }
+
   Widget _buildPricingSection() {
     return Container(
       padding: const EdgeInsets.all(16),
@@ -646,4 +1094,467 @@ class _AdminUploadAudiobookScreenState extends ConsumerState<AdminUploadAudioboo
       ),
     );
   }
+
+  /// Metadata section - different for books vs music
+  Widget _buildAuthorArtistSection() {
+    return _isMusic ? _buildMusicMetadataSection() : _buildBookMetadataSection();
+  }
+
+  /// Book metadata section (نویسنده، مترجم، گوینده، ناشر، سال نشر)
+  Widget _buildBookMetadataSection() {
+    return Container(
+      padding: const EdgeInsets.all(16),
+      decoration: BoxDecoration(
+        color: AppColors.surface,
+        borderRadius: BorderRadius.circular(12),
+        border: Border.all(color: AppColors.border),
+      ),
+      child: Column(
+        crossAxisAlignment: CrossAxisAlignment.start,
+        children: [
+          const Row(
+            children: [
+              Icon(Icons.menu_book, color: AppColors.primary, size: 20),
+              SizedBox(width: 8),
+              Text(
+                'اطلاعات کتاب',
+                style: TextStyle(
+                  fontSize: 14,
+                  fontWeight: FontWeight.bold,
+                  color: AppColors.textPrimary,
+                ),
+              ),
+            ],
+          ),
+          const SizedBox(height: 16),
+
+          // نویسنده - Author
+          TextFormField(
+            controller: _authorNameController,
+            decoration: const InputDecoration(
+              labelText: 'نویسنده (فارسی)',
+              hintText: 'مثال: آنتوان دو سنت‌اگزوپری',
+              prefixIcon: Icon(Icons.edit),
+            ),
+          ),
+          const SizedBox(height: 12),
+          TextFormField(
+            controller: _authorNameEnController,
+            decoration: const InputDecoration(
+              labelText: 'نویسنده (انگلیسی - اختیاری)',
+              hintText: 'Example: Antoine de Saint-Exupéry',
+              prefixIcon: Icon(Icons.edit),
+            ),
+            textDirection: TextDirection.ltr,
+          ),
+          const SizedBox(height: 12),
+          TextFormField(
+            controller: _coAuthorsController,
+            decoration: const InputDecoration(
+              labelText: 'نویسندگان همکار (اختیاری)',
+              hintText: 'نام‌ها را با کاما جدا کنید',
+              prefixIcon: Icon(Icons.group),
+            ),
+          ),
+          const SizedBox(height: 16),
+
+          // مترجم - Translator
+          TextFormField(
+            controller: _translatorController,
+            decoration: const InputDecoration(
+              labelText: 'مترجم (فارسی - اختیاری)',
+              hintText: 'مثال: احمد شاملو',
+              prefixIcon: Icon(Icons.translate),
+            ),
+          ),
+          const SizedBox(height: 12),
+          TextFormField(
+            controller: _translatorEnController,
+            decoration: const InputDecoration(
+              labelText: 'مترجم (انگلیسی - اختیاری)',
+              hintText: 'Example: Ahmad Shamlou',
+              prefixIcon: Icon(Icons.translate),
+            ),
+            textDirection: TextDirection.ltr,
+          ),
+          const SizedBox(height: 16),
+
+          // گوینده - Narrator (separate from profile's narrator_id)
+          TextFormField(
+            controller: _narratorNameController,
+            decoration: const InputDecoration(
+              labelText: 'گوینده (فارسی - اختیاری)',
+              hintText: 'نام گوینده کتاب صوتی',
+              prefixIcon: Icon(Icons.mic),
+            ),
+          ),
+          const SizedBox(height: 12),
+          TextFormField(
+            controller: _narratorNameEnController,
+            decoration: const InputDecoration(
+              labelText: 'گوینده (انگلیسی - اختیاری)',
+              hintText: 'Narrator name in English',
+              prefixIcon: Icon(Icons.mic),
+            ),
+            textDirection: TextDirection.ltr,
+          ),
+          const SizedBox(height: 16),
+
+          // ناشر - Publisher
+          TextFormField(
+            controller: _publisherController,
+            decoration: const InputDecoration(
+              labelText: 'ناشر (فارسی - اختیاری)',
+              hintText: 'مثال: نشر چشمه',
+              prefixIcon: Icon(Icons.business),
+            ),
+          ),
+          const SizedBox(height: 12),
+          TextFormField(
+            controller: _publisherEnController,
+            decoration: const InputDecoration(
+              labelText: 'ناشر (انگلیسی - اختیاری)',
+              hintText: 'Example: Cheshmeh Publications',
+              prefixIcon: Icon(Icons.business),
+            ),
+            textDirection: TextDirection.ltr,
+          ),
+          const SizedBox(height: 16),
+
+          // سال نشر و ISBN
+          Row(
+            children: [
+              Expanded(
+                child: TextFormField(
+                  controller: _publicationYearController,
+                  decoration: const InputDecoration(
+                    labelText: 'سال نشر',
+                    hintText: '۱۴۰۲',
+                    prefixIcon: Icon(Icons.calendar_today),
+                  ),
+                  keyboardType: TextInputType.number,
+                ),
+              ),
+              const SizedBox(width: 12),
+              Expanded(
+                child: TextFormField(
+                  controller: _isbnController,
+                  decoration: const InputDecoration(
+                    labelText: 'ISBN (اختیاری)',
+                    hintText: '978-...',
+                    prefixIcon: Icon(Icons.qr_code),
+                  ),
+                  textDirection: TextDirection.ltr,
+                ),
+              ),
+            ],
+          ),
+        ],
+      ),
+    );
+  }
+
+  /// Music metadata section (هنرمند، آهنگساز، شاعر، آلبوم، سبک، سال انتشار)
+  Widget _buildMusicMetadataSection() {
+    return Container(
+      padding: const EdgeInsets.all(16),
+      decoration: BoxDecoration(
+        color: AppColors.surface,
+        borderRadius: BorderRadius.circular(12),
+        border: Border.all(color: AppColors.border),
+      ),
+      child: Column(
+        crossAxisAlignment: CrossAxisAlignment.start,
+        children: [
+          const Row(
+            children: [
+              Icon(Icons.music_note, color: AppColors.primary, size: 20),
+              SizedBox(width: 8),
+              Text(
+                'اطلاعات موسیقی',
+                style: TextStyle(
+                  fontSize: 14,
+                  fontWeight: FontWeight.bold,
+                  color: AppColors.textPrimary,
+                ),
+              ),
+            ],
+          ),
+          const SizedBox(height: 16),
+
+          // هنرمند / خواننده - Artist
+          TextFormField(
+            controller: _artistNameController,
+            decoration: const InputDecoration(
+              labelText: 'هنرمند / خواننده (فارسی)',
+              hintText: 'مثال: محسن چاوشی',
+              prefixIcon: Icon(Icons.person),
+            ),
+          ),
+          const SizedBox(height: 12),
+          TextFormField(
+            controller: _artistNameEnController,
+            decoration: const InputDecoration(
+              labelText: 'هنرمند (انگلیسی - اختیاری)',
+              hintText: 'Example: Mohsen Chavoshi',
+              prefixIcon: Icon(Icons.person),
+            ),
+            textDirection: TextDirection.ltr,
+          ),
+          const SizedBox(height: 12),
+          TextFormField(
+            controller: _featuredArtistsController,
+            decoration: const InputDecoration(
+              labelText: 'هنرمندان مهمان (اختیاری)',
+              hintText: 'نام‌ها را با کاما جدا کنید',
+              prefixIcon: Icon(Icons.group),
+            ),
+          ),
+          const SizedBox(height: 16),
+
+          // آهنگساز - Composer
+          TextFormField(
+            controller: _composerController,
+            decoration: const InputDecoration(
+              labelText: 'آهنگساز (فارسی - اختیاری)',
+              hintText: 'مثال: محمدرضا شجریان',
+              prefixIcon: Icon(Icons.piano),
+            ),
+          ),
+          const SizedBox(height: 12),
+          TextFormField(
+            controller: _composerEnController,
+            decoration: const InputDecoration(
+              labelText: 'آهنگساز (انگلیسی - اختیاری)',
+              hintText: 'Example: Mohammad-Reza Shajarian',
+              prefixIcon: Icon(Icons.piano),
+            ),
+            textDirection: TextDirection.ltr,
+          ),
+          const SizedBox(height: 16),
+
+          // شاعر / ترانه‌سرا - Lyricist
+          TextFormField(
+            controller: _lyricistController,
+            decoration: const InputDecoration(
+              labelText: 'شاعر / ترانه‌سرا (فارسی - اختیاری)',
+              hintText: 'مثال: حافظ شیرازی',
+              prefixIcon: Icon(Icons.text_fields),
+            ),
+          ),
+          const SizedBox(height: 12),
+          TextFormField(
+            controller: _lyricistEnController,
+            decoration: const InputDecoration(
+              labelText: 'شاعر / ترانه‌سرا (انگلیسی - اختیاری)',
+              hintText: 'Example: Hafez Shirazi',
+              prefixIcon: Icon(Icons.text_fields),
+            ),
+            textDirection: TextDirection.ltr,
+          ),
+          const SizedBox(height: 16),
+
+          // آلبوم / مجموعه - Album
+          TextFormField(
+            controller: _albumTitleController,
+            decoration: const InputDecoration(
+              labelText: 'آلبوم / مجموعه (فارسی - اختیاری)',
+              hintText: 'مثال: آلبوم امشب',
+              prefixIcon: Icon(Icons.album),
+            ),
+          ),
+          const SizedBox(height: 12),
+          TextFormField(
+            controller: _albumTitleEnController,
+            decoration: const InputDecoration(
+              labelText: 'آلبوم (انگلیسی - اختیاری)',
+              hintText: 'Example: Tonight Album',
+              prefixIcon: Icon(Icons.album),
+            ),
+            textDirection: TextDirection.ltr,
+          ),
+          const SizedBox(height: 16),
+
+          // ناشر / استودیو - Label
+          TextFormField(
+            controller: _labelController,
+            decoration: const InputDecoration(
+              labelText: 'ناشر / استودیو (فارسی - اختیاری)',
+              hintText: 'مثال: استودیو آوا',
+              prefixIcon: Icon(Icons.business),
+            ),
+          ),
+          const SizedBox(height: 12),
+          TextFormField(
+            controller: _labelEnController,
+            decoration: const InputDecoration(
+              labelText: 'ناشر / استودیو (انگلیسی - اختیاری)',
+              hintText: 'Example: Ava Music Studio',
+              prefixIcon: Icon(Icons.business),
+            ),
+            textDirection: TextDirection.ltr,
+          ),
+          const SizedBox(height: 16),
+
+          // سبک - Genre (text, supplementary to music_categories)
+          TextFormField(
+            controller: _genreController,
+            decoration: const InputDecoration(
+              labelText: 'سبک اصلی (فارسی - اختیاری)',
+              hintText: 'مثال: پاپ فارسی',
+              prefixIcon: Icon(Icons.style),
+            ),
+          ),
+          const SizedBox(height: 12),
+          TextFormField(
+            controller: _genreEnController,
+            decoration: const InputDecoration(
+              labelText: 'سبک (انگلیسی - اختیاری)',
+              hintText: 'Example: Persian Pop',
+              prefixIcon: Icon(Icons.style),
+            ),
+            textDirection: TextDirection.ltr,
+          ),
+          const SizedBox(height: 16),
+
+          // سال انتشار - Release Year
+          TextFormField(
+            controller: _releaseYearController,
+            decoration: const InputDecoration(
+              labelText: 'سال انتشار (اختیاری)',
+              hintText: '۱۴۰۲',
+              prefixIcon: Icon(Icons.calendar_today),
+            ),
+            keyboardType: TextInputType.number,
+          ),
+        ],
+      ),
+    );
+  }
+
+  /// Multi-select music categories (سبک‌های موسیقی)
+  Widget _buildMusicCategoriesSelector(List<Map<String, dynamic>> categories) {
+    return Container(
+      padding: const EdgeInsets.all(16),
+      decoration: BoxDecoration(
+        color: AppColors.surface,
+        borderRadius: BorderRadius.circular(12),
+        border: Border.all(
+          color: _selectedMusicCategoryIds.isNotEmpty
+              ? AppColors.primary
+              : AppColors.border,
+        ),
+      ),
+      child: Column(
+        crossAxisAlignment: CrossAxisAlignment.start,
+        children: [
+          Row(
+            children: [
+              const Icon(Icons.music_note, color: AppColors.primary, size: 20),
+              const SizedBox(width: 8),
+              const Text(
+                'سبک‌های موسیقی *',
+                style: TextStyle(
+                  fontSize: 14,
+                  fontWeight: FontWeight.bold,
+                  color: AppColors.textPrimary,
+                ),
+              ),
+              const Spacer(),
+              if (_selectedMusicCategoryIds.isNotEmpty)
+                Container(
+                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
+                  decoration: BoxDecoration(
+                    color: AppColors.primary.withOpacity(0.1),
+                    borderRadius: BorderRadius.circular(12),
+                  ),
+                  child: Text(
+                    '${_selectedMusicCategoryIds.length} انتخاب شده',
+                    style: const TextStyle(
+                      color: AppColors.primary,
+                      fontSize: 12,
+                      fontWeight: FontWeight.w500,
+                    ),
+                  ),
+                ),
+            ],
+          ),
+          const SizedBox(height: 12),
+          if (categories.isEmpty)
+            const Padding(
+              padding: EdgeInsets.all(12),
+              child: Text(
+                'سبک موسیقی یافت نشد. ابتدا از تنظیمات، سبک‌ها را اضافه کنید.',
+                style: TextStyle(color: AppColors.textSecondary),
+                textAlign: TextAlign.center,
+              ),
+            )
+          else
+            Wrap(
+              spacing: 8,
+              runSpacing: 8,
+              children: categories.map((cat) {
+                final catId = cat['id'] as int;
+                final isSelected = _selectedMusicCategoryIds.contains(catId);
+                final nameFa = (cat['name_fa'] as String?) ?? '';
+                final icon = cat['icon'] as String?;
+
+                return GestureDetector(
+                  onTap: () {
+                    setState(() {
+                      if (isSelected) {
+                        _selectedMusicCategoryIds.remove(catId);
+                      } else {
+                        _selectedMusicCategoryIds.add(catId);
+                      }
+                    });
+                  },
+                  child: AnimatedContainer(
+                    duration: const Duration(milliseconds: 200),
+                    padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
+                    decoration: BoxDecoration(
+                      color: isSelected
+                          ? AppColors.primary.withOpacity(0.1)
+                          : Colors.transparent,
+                      borderRadius: BorderRadius.circular(20),
+                      border: Border.all(
+                        color: isSelected ? AppColors.primary : AppColors.border,
+                        width: isSelected ? 2 : 1,
+                      ),
+                    ),
+                    child: Row(
+                      mainAxisSize: MainAxisSize.min,
+                      children: [
+                        if (icon != null && icon.isNotEmpty) ...[
+                          Text(icon, style: const TextStyle(fontSize: 16)),
+                          const SizedBox(width: 6),
+                        ],
+                        Text(
+                          nameFa,
+                          style: TextStyle(
+                            color: isSelected
+                                ? AppColors.primary
+                                : AppColors.textPrimary,
+                            fontWeight:
+                                isSelected ? FontWeight.w600 : FontWeight.normal,
+                          ),
+                        ),
+                        if (isSelected) ...[
+                          const SizedBox(width: 4),
+                          const Icon(
+                            Icons.check_circle,
+                            color: AppColors.primary,
+                            size: 16,
+                          ),
+                        ],
+                      ],
+                    ),
+                  ),
+                );
+              }).toList(),
+            ),
+        ],
+      ),
+    );
+  }
 }
diff --git a/lib/screens/admin/admin_user_detail_screen.dart b/lib/screens/admin/admin_user_detail_screen.dart
index cc8be90..5e3e09b 100644
--- a/lib/screens/admin/admin_user_detail_screen.dart
+++ b/lib/screens/admin/admin_user_detail_screen.dart
@@ -2,6 +2,7 @@ import 'package:flutter/material.dart';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
 import 'package:supabase_flutter/supabase_flutter.dart';
 import 'package:myna/theme/app_theme.dart';
+import 'package:myna/utils/app_logger.dart';
 
 class AdminUserDetailScreen extends ConsumerStatefulWidget {
   final Map<String, dynamic> user;
@@ -33,14 +34,79 @@ class _AdminUserDetailScreenState extends ConsumerState<AdminUserDetailScreen> {
   }
 
   Future<void> _changeRole(String newRole) async {
+    final userId = _user['id'] as String;
+    final oldRole = _user['role'] as String? ?? 'listener';
+
+    // Don't do anything if role is the same
+    if (newRole == oldRole) return;
+
+    AppLogger.i('Admin changing user role: userId=$userId, oldRole=$oldRole, newRole=$newRole');
+
     setState(() => _isLoading = true);
     try {
-      await Supabase.instance.client.from('profiles').update({'role': newRole}).eq('id', _user['id'] as Object);
+      // Perform the update and fetch the updated row to verify
+      final response = await Supabase.instance.client
+          .from('profiles')
+          .update({'role': newRole})
+          .eq('id', userId)
+          .select('role')
+          .maybeSingle();
+
+      AppLogger.i('Role update response: $response');
+
+      // Verify the update actually happened
+      if (response == null) {
+        // No row returned - either user doesn't exist or RLS blocked the update
+        AppLogger.e('Role update failed: No response from server (possibly RLS blocked)');
+        if (mounted) {
+          ScaffoldMessenger.of(context).showSnackBar(
+            const SnackBar(
+              content: Text('خطا در تغییر نقش کاربر. دسترسی رد شد.'),
+              backgroundColor: AppColors.error,
+            ),
+          );
+        }
+        return;
+      }
+
+      final updatedRole = response['role'] as String?;
+      if (updatedRole != newRole) {
+        // Server returned a different role than what we set
+        AppLogger.e('Role update failed: Server returned role=$updatedRole, expected=$newRole');
+        if (mounted) {
+          ScaffoldMessenger.of(context).showSnackBar(
+            const SnackBar(
+              content: Text('خطا در تغییر نقش کاربر. لطفاً دوباره تلاش کنید.'),
+              backgroundColor: AppColors.error,
+            ),
+          );
+        }
+        return;
+      }
+
+      // Success - update local state
+      AppLogger.i('Role update successful: $oldRole -> $newRole');
       setState(() => _user['role'] = newRole);
       widget.onUpdate();
-      if (mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('نقش تغییر کرد'), backgroundColor: AppColors.success));
+
+      if (mounted) {
+        ScaffoldMessenger.of(context).showSnackBar(
+          const SnackBar(
+            content: Text('نقش کاربر با موفقیت تغییر کرد.'),
+            backgroundColor: AppColors.success,
+          ),
+        );
+      }
     } catch (e) {
-      if (mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('خطا: $e'), backgroundColor: AppColors.error));
+      AppLogger.e('Role update exception', error: e);
+      if (mounted) {
+        ScaffoldMessenger.of(context).showSnackBar(
+          SnackBar(
+            content: Text('خطا در تغییر نقش کاربر: $e'),
+            backgroundColor: AppColors.error,
+          ),
+        );
+      }
     } finally {
       setState(() => _isLoading = false);
     }
@@ -125,11 +191,11 @@ class _AdminUserDetailScreenState extends ConsumerState<AdminUserDetailScreen> {
                     Text(email, style: const TextStyle(color: AppColors.textSecondary)),
                     if (bio != null && bio.isNotEmpty) ...[
                       const SizedBox(height: 8),
-                      Text(bio, style: TextStyle(color: AppColors.textTertiary), textAlign: TextAlign.center),
+                      Text(bio, style: const TextStyle(color: AppColors.textTertiary), textAlign: TextAlign.center),
                     ],
                     const SizedBox(height: 8),
                     if (createdAt != null)
-                      Text('عضویت: ${createdAt.year}/${createdAt.month}/${createdAt.day}', style: TextStyle(color: AppColors.textTertiary, fontSize: 12)),
+                      Text('عضویت: ${createdAt.year}/${createdAt.month}/${createdAt.day}', style: const TextStyle(color: AppColors.textTertiary, fontSize: 12)),
                     const SizedBox(height: 24),
 
                     // Status
@@ -168,7 +234,7 @@ class _AdminUserDetailScreenState extends ConsumerState<AdminUserDetailScreen> {
                       color: AppColors.surface,
                       child: SwitchListTile(
                         title: Text(isDisabled ? 'فعال کردن کاربر' : 'غیرفعال کردن کاربر', style: const TextStyle(color: AppColors.textPrimary)),
-                        subtitle: Text(isDisabled ? 'کاربر نمی‌تواند وارد شود' : 'کاربر می‌تواند وارد شود', style: TextStyle(color: AppColors.textSecondary, fontSize: 12)),
+                        subtitle: Text(isDisabled ? 'کاربر نمی‌تواند وارد شود' : 'کاربر می‌تواند وارد شود', style: const TextStyle(color: AppColors.textSecondary, fontSize: 12)),
                         value: isDisabled,
                         onChanged: (_) => _toggleDisabled(),
                         activeColor: AppColors.error,
@@ -198,7 +264,7 @@ class _AdminUserDetailScreenState extends ConsumerState<AdminUserDetailScreen> {
                               style: const TextStyle(color: AppColors.textPrimary),
                               decoration: InputDecoration(
                                 hintText: 'یادداشت درباره این کاربر...',
-                                hintStyle: TextStyle(color: AppColors.textTertiary),
+                                hintStyle: const TextStyle(color: AppColors.textTertiary),
                                 filled: true,
                                 fillColor: AppColors.surfaceLight,
                                 border: OutlineInputBorder(
diff --git a/lib/screens/audiobook_detail_screen.dart b/lib/screens/audiobook_detail_screen.dart
index 6ffdd04..fad3d59 100644
--- a/lib/screens/audiobook_detail_screen.dart
+++ b/lib/screens/audiobook_detail_screen.dart
@@ -1,6 +1,8 @@
 import 'package:flutter/material.dart';
-import 'package:flutter/foundation.dart' show kIsWeb;
+import 'package:flutter/foundation.dart' show kIsWeb, kDebugMode, kReleaseMode;
+import 'package:flutter/services.dart';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
+import 'package:cached_network_image/cached_network_image.dart';
 import 'package:supabase_flutter/supabase_flutter.dart';
 import 'package:myna/theme/app_theme.dart';
 import 'package:myna/config/env.dart';
@@ -11,6 +13,7 @@ import 'package:myna/services/payment_service.dart';
 import 'package:myna/services/download_service.dart';
 import 'package:myna/services/wishlist_service.dart';
 import 'package:myna/services/book_summary_service.dart';
+import 'package:myna/services/creator_service.dart';
 import 'package:myna/providers/audio_provider.dart';
 import 'package:myna/providers/download_provider.dart';
 import 'package:myna/screens/player/player_screen.dart';
@@ -20,9 +23,13 @@ import 'package:myna/screens/support/create_ticket_screen.dart';
 import 'package:myna/widgets/review/rating_stars.dart';
 import 'package:myna/widgets/review/review_card.dart';
 import 'package:myna/widgets/error_view.dart';
+import 'package:myna/widgets/mini_player.dart';
 import 'package:myna/screens/payment/payment_success_screen.dart';
 import 'package:myna/screens/payment/payment_failure_screen.dart';
-import 'package:myna/screens/listener/library_screen.dart' show ownedBooksWithProgressProvider;
+import 'package:myna/screens/listener/library_screen.dart' show ownedBooksWithProgressProvider, ownedItemsWithProgressProvider;
+import 'package:myna/screens/debug/payment_test_screen.dart';
+import 'package:myna/screens/creator/creator_profile_screen.dart';
+import 'package:myna/services/playlist_service.dart';
 
 class AudiobookDetailScreen extends ConsumerStatefulWidget {
   final int audiobookId;
@@ -38,6 +45,8 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
   List<Map<String, dynamic>> _chapters = [];
   Map<String, dynamic>? _progress;
   List<Map<String, dynamic>> _reviews = [];
+  Map<String, dynamic>? _metadata; // book_metadata or music_metadata
+  List<Map<String, dynamic>> _creators = []; // Creator profiles linked to this audiobook
   bool _isLoading = true;
   bool _isOwned = false;
   bool _isPurchasing = false;
@@ -54,6 +63,7 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
   bool _isLoadingSummary = false;
   bool _summaryError = false;
   bool _summaryRateLimited = false;
+  String? _summaryErrorDetails;
 
   @override
   void initState() {
@@ -69,57 +79,103 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
 
     try {
       final user = Supabase.instance.client.auth.currentUser;
-
-      // Fetch audiobook details
-      final audiobook = await Supabase.instance.client
-          .from('audiobooks')
-          .select('*, categories(name_fa), profiles!audiobooks_narrator_id_fkey(display_name, full_name)')
-          .eq('id', widget.audiobookId)
-          .single();
-
-      // Fetch chapters
-      final chapters = await Supabase.instance.client
-          .from('chapters')
-          .select('*')
-          .eq('audiobook_id', widget.audiobookId)
-          .order('chapter_index', ascending: true);
-
-      bool owned = audiobook['is_free'] == true;
-      Map<String, dynamic>? progress;
-
-      if (user != null && !owned) {
-        final entitlement = await Supabase.instance.client
-            .from('entitlements')
-            .select('id')
-            .eq('user_id', user.id)
+      final supabase = Supabase.instance.client;
+
+      // PERFORMANCE: Run audiobook + chapters + reviews queries in parallel
+      final basicDataFutures = await Future.wait([
+        supabase
+            .from('audiobooks')
+            .select('*, categories(name_fa), profiles!audiobooks_narrator_id_fkey(display_name, full_name)')
+            .eq('id', widget.audiobookId)
+            .single(),
+        supabase
+            .from('chapters')
+            .select('*')
             .eq('audiobook_id', widget.audiobookId)
-            .maybeSingle();
-        owned = entitlement != null;
-      }
+            .order('chapter_index', ascending: true),
+        supabase
+            .from('reviews')
+            .select('*, profiles(display_name, avatar_url)')
+            .eq('audiobook_id', widget.audiobookId)
+            .eq('is_approved', true)
+            .order('created_at', ascending: false)
+            .limit(3),
+      ]);
+
+      final audiobook = basicDataFutures[0] as Map<String, dynamic>;
+      final chapters = basicDataFutures[1] as List;
+      final reviews = basicDataFutures[2] as List;
+
+      // FIX: Free books still need an entitlement to appear in library.
+      // User must explicitly "claim" free books by tapping the button.
+      // This creates a proper entitlement row which the library query uses.
+      // We always check for entitlement, regardless of is_free status.
+      bool owned = false;
+      Map<String, dynamic>? progress;
+      bool inWishlist = false;
 
-      if (user != null && owned) {
-        progress = await Supabase.instance.client
+      // PERFORMANCE: Run user-specific queries in parallel if user is logged in
+      if (user != null) {
+        // Start all futures simultaneously
+        // Always check for entitlement (free or paid - both need entitlements for library)
+        final entitlementFuture = supabase
+                .from('entitlements')
+                .select('id')
+                .eq('user_id', user.id)
+                .eq('audiobook_id', widget.audiobookId)
+                .maybeSingle();
+
+        final progressFuture = supabase
             .from('listening_progress')
             .select('*')
             .eq('user_id', user.id)
             .eq('audiobook_id', widget.audiobookId)
             .maybeSingle();
+
+        final wishlistFuture = ref.read(wishlistServiceProvider).isInWishlist(widget.audiobookId.toString());
+
+        // Wait for all results (they run in parallel)
+        final results = await (entitlementFuture, progressFuture, wishlistFuture).wait;
+
+        // User owns if they have an entitlement (from purchase or free claim)
+        if (results.$1 != null) {
+          owned = true;
+        }
+        progress = results.$2;
+        inWishlist = results.$3;
       }
 
-      // Fetch reviews
-      final reviews = await Supabase.instance.client
-          .from('reviews')
-          .select('*, profiles(display_name, avatar_url)')
-          .eq('audiobook_id', widget.audiobookId)
-          .eq('is_approved', true)
-          .order('created_at', ascending: false)
-          .limit(3);
+      // Fetch metadata from appropriate table based on is_music flag
+      Map<String, dynamic>? metadata;
+      final isMusic = audiobook['is_music'] == true;
+      try {
+        if (isMusic) {
+          final metadataResult = await supabase
+              .from('music_metadata')
+              .select('*')
+              .eq('audiobook_id', widget.audiobookId)
+              .maybeSingle();
+          metadata = metadataResult;
+        } else {
+          final metadataResult = await supabase
+              .from('book_metadata')
+              .select('*')
+              .eq('audiobook_id', widget.audiobookId)
+              .maybeSingle();
+          metadata = metadataResult;
+        }
+      } catch (e) {
+        // If metadata fetch fails, continue without it (fallback to legacy columns)
+        AppLogger.e('Failed to fetch metadata', error: e);
+      }
 
-      // Check wishlist
-      bool inWishlist = false;
-      if (user != null) {
-        final wishlistService = ref.read(wishlistServiceProvider);
-        inWishlist = await wishlistService.isInWishlist(widget.audiobookId.toString());
+      // Fetch linked creators (from creators table via audiobook_creators)
+      // This is optional - if no creators are linked, we fall back to legacy fields
+      List<Map<String, dynamic>> creators = [];
+      try {
+        creators = await CreatorService().getCreatorsForAudiobook(widget.audiobookId);
+      } catch (e) {
+        AppLogger.e('Failed to fetch creators', error: e);
       }
 
       if (mounted) {
@@ -129,6 +185,8 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
           _isOwned = owned;
           _progress = progress;
           _reviews = List<Map<String, dynamic>>.from(reviews);
+          _metadata = metadata;
+          _creators = creators;
           _isInWishlist = inWishlist;
           _isLoading = false;
         });
@@ -221,27 +279,47 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
           isFree: isFree,
         );
 
-        if (result == PurchaseResult.success) {
-          setState(() => _isOwned = true);
-          // Invalidate library cache so the new book appears
-          ref.invalidate(ownedBooksWithProgressProvider);
-          if (mounted) {
-            ScaffoldMessenger.of(context).showSnackBar(
-              const SnackBar(
-                content: Text('کتاب به کتابخانه شما اضافه شد'),
-                backgroundColor: AppColors.success,
-              ),
-            );
-          }
-        } else if (result == PurchaseResult.error) {
-          if (mounted) {
-            ScaffoldMessenger.of(context).showSnackBar(
-              const SnackBar(
-                content: Text('خطا در افزودن کتاب'),
-                backgroundColor: AppColors.error,
-              ),
-            );
-          }
+        switch (result) {
+          case PurchaseResult.success:
+            setState(() => _isOwned = true);
+            // Invalidate library cache so the new book appears
+            // Must invalidate BOTH the family provider and legacy provider
+            ref.invalidate(ownedItemsWithProgressProvider(false));  // Books
+            ref.invalidate(ownedItemsWithProgressProvider(true));   // Music
+            ref.invalidate(ownedBooksWithProgressProvider);         // Legacy
+            if (mounted) {
+              ScaffoldMessenger.of(context).showSnackBar(
+                const SnackBar(
+                  content: Text('کتاب به کتابخانه شما اضافه شد'),
+                  backgroundColor: AppColors.success,
+                ),
+              );
+            }
+            break;
+          case PurchaseResult.paymentRequired:
+            // This shouldn't happen for free books, but handle it gracefully
+            if (mounted) {
+              ScaffoldMessenger.of(context).showSnackBar(
+                const SnackBar(
+                  content: Text('این کتاب رایگان نیست'),
+                  backgroundColor: AppColors.warning,
+                ),
+              );
+            }
+            break;
+          case PurchaseResult.cancelled:
+            // User cancelled - no message needed
+            break;
+          case PurchaseResult.error:
+            if (mounted) {
+              ScaffoldMessenger.of(context).showSnackBar(
+                const SnackBar(
+                  content: Text('خطا در افزودن کتاب. لطفاً دوباره تلاش کنید.'),
+                  backgroundColor: AppColors.error,
+                ),
+              );
+            }
+            break;
         }
       } else {
         // Paid books - use full payment flow with screens
@@ -256,12 +334,16 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
           context: context,
           audiobookId: widget.audiobookId,
           audiobookTitle: title,
+          ref: ref,  // Pass ref to suspend audio updates during payment
         );
 
         switch (result) {
           case PaymentResult.success:
             setState(() => _isOwned = true);
-            ref.invalidate(ownedBooksWithProgressProvider);
+            // Invalidate BOTH the family provider (used by LibraryScreen) and legacy provider
+            ref.invalidate(ownedItemsWithProgressProvider(false));  // Books
+            ref.invalidate(ownedItemsWithProgressProvider(true));   // Music
+            ref.invalidate(ownedBooksWithProgressProvider);         // Legacy
             if (mounted) {
               // Navigate to success screen
               await Navigator.push<void>(
@@ -273,10 +355,16 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
                     priceToman: priceToman,
                     onGoToLibrary: () {
                       // Invalidate library cache so the new book appears
+                      ref.invalidate(ownedItemsWithProgressProvider(false));
+                      ref.invalidate(ownedItemsWithProgressProvider(true));
                       ref.invalidate(ownedBooksWithProgressProvider);
-                      // Pop back to detail screen, then pop to previous (likely home)
-                      Navigator.pop(context); // Pop success screen
-                      Navigator.pop(context); // Pop detail screen
+                      // FIX: Use popUntil to safely pop multiple screens at once
+                      // This avoids _debugLocked error from calling pop() twice synchronously
+                      int popCount = 0;
+                      Navigator.popUntil(context, (route) {
+                        popCount++;
+                        return popCount > 2; // Pop success screen + detail screen
+                      });
                     },
                     onStartListening: () {
                       Navigator.pop(context); // Pop success screen
@@ -341,7 +429,10 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
                 Navigator.pop(context); // Close processing dialog
                 if (hasEntitlement) {
                   setState(() => _isOwned = true);
-                  ref.invalidate(ownedBooksWithProgressProvider);
+                  // FIX: Invalidate ALL library providers (family + legacy)
+                  ref.invalidate(ownedItemsWithProgressProvider(false));  // Books
+                  ref.invalidate(ownedItemsWithProgressProvider(true));   // Music
+                  ref.invalidate(ownedBooksWithProgressProvider);         // Legacy
                   ScaffoldMessenger.of(context).showSnackBar(
                     const SnackBar(
                       content: Text('خرید با موفقیت انجام شد!'),
@@ -349,11 +440,12 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
                     ),
                   );
                 } else {
-                  // Still no entitlement after polling - show message
+                  // Still no entitlement after polling - show clear error
                   ScaffoldMessenger.of(context).showSnackBar(
                     const SnackBar(
-                      content: Text('پرداخت در حال پردازش است. لطفاً چند دقیقه دیگر بررسی کنید.'),
+                      content: Text('پرداخت شما ثبت شد اما کتاب هنوز به کتابخانه اضافه نشده. لطفاً چند دقیقه دیگر بررسی کنید یا با پشتیبانی تماس بگیرید.'),
                       backgroundColor: AppColors.warning,
+                      duration: Duration(seconds: 6),
                     ),
                   );
                 }
@@ -376,17 +468,41 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
     }
   }
 
-  void _playAudiobook({int chapterIndex = 0, int? seekTo}) {
+  void _playAudiobook({int chapterIndex = 0, int? seekTo}) async {
     if (_audiobook == null) return;
 
+    final isFree = _audiobook!['is_free'] == true;
+
+    // Auto-claim free books when user starts playing (if not already owned)
+    // This ensures free books appear in Library after first play
+    if (isFree && !_isOwned) {
+      AppLogger.i('Auto-claiming free audiobook ${widget.audiobookId} on play');
+      final purchaseService = PurchaseService(Supabase.instance.client);
+      final result = await purchaseService.purchaseAudiobook(
+        context: context,
+        audiobookId: widget.audiobookId,
+        priceToman: 0,
+        isFree: true,
+      );
+      if (result == PurchaseResult.success) {
+        setState(() => _isOwned = true);
+        // Invalidate library cache so the book appears
+        ref.invalidate(ownedItemsWithProgressProvider(false));
+        ref.invalidate(ownedItemsWithProgressProvider(true));
+        ref.invalidate(ownedBooksWithProgressProvider);
+        AppLogger.i('Free audiobook claimed successfully');
+      }
+    }
+
     ref.read(audioProvider.notifier).play(
       audiobook: _audiobook!,
       chapters: _chapters,
       chapterIndex: chapterIndex,
       seekTo: seekTo,
-      isOwned: _isOwned,
+      isOwned: _isOwned || isFree, // Free books are always playable
     );
 
+    if (!mounted) return;
     Navigator.push(
       context,
       MaterialPageRoute<void>(
@@ -421,6 +537,51 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
     );
   }
 
+  /// DEBUG ONLY: Opens payment test screen to isolate Stripe lag issue
+  void _openPaymentTest() {
+    if (_audiobook == null) return;
+    Navigator.push(
+      context,
+      MaterialPageRoute<void>(
+        builder: (_) => PaymentTestScreen(
+          audiobookId: widget.audiobookId,
+          title: (_audiobook!['title_fa'] as String?) ?? 'Test',
+        ),
+      ),
+    );
+  }
+
+  void _showAddToPlaylistSheet() {
+    if (_audiobook == null) return;
+
+    final user = Supabase.instance.client.auth.currentUser;
+    if (user == null) {
+      ScaffoldMessenger.of(context).showSnackBar(
+        const SnackBar(content: Text('برای افزودن به لیست پخش وارد شوید')),
+      );
+      return;
+    }
+
+    final isMusic = _audiobook!['is_music'] == true;
+    final audiobookId = widget.audiobookId;
+    final title = (_audiobook!['title_fa'] as String?) ?? '';
+
+    showModalBottomSheet<void>(
+      context: context,
+      backgroundColor: AppColors.surface,
+      isScrollControlled: true,
+      shape: const RoundedRectangleBorder(
+        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
+      ),
+      builder: (context) => _AddToPlaylistSheet(
+        audiobookId: audiobookId,
+        audiobookTitle: title,
+        isMusic: isMusic,
+        chapters: _chapters,
+      ),
+    );
+  }
+
   int _calculateTotalDuration() {
     // First try audiobook's total_duration_seconds (most accurate if set)
     if (_audiobook != null) {
@@ -453,6 +614,7 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
           _aiSummary = cached;
           _summaryError = false;
           _summaryRateLimited = false;
+          _summaryErrorDetails = null;
         });
         return;
       }
@@ -462,6 +624,7 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
       _isLoadingSummary = true;
       _summaryError = false;
       _summaryRateLimited = false;
+      _summaryErrorDetails = null;
     });
 
     try {
@@ -478,41 +641,62 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
           _isLoadingSummary = false;
           _summaryError = false;
           _summaryRateLimited = false;
+          _summaryErrorDetails = null;
         });
       } else if (result.rateLimitExceeded) {
         setState(() {
           _isLoadingSummary = false;
           _summaryError = false;
           _summaryRateLimited = true;
+          _summaryErrorDetails = null;
         });
       } else {
         setState(() {
           _isLoadingSummary = false;
           _summaryError = true;
           _summaryRateLimited = false;
+          _summaryErrorDetails = _formatSummaryErrorDetails(result);
         });
       }
     } catch (e) {
-      AppLogger.e('Error fetching AI summary', error: e);
+      AppLogger.e('Summary fetch failed', error: e);
       if (!mounted) return;
       setState(() {
         _isLoadingSummary = false;
         _summaryError = true;
         _summaryRateLimited = false;
+        _summaryErrorDetails = 'AI error: unexpected_exception';
       });
     }
   }
 
   @override
   Widget build(BuildContext context) {
-    final audio = ref.watch(audioProvider);
-    final bottomPadding = audio.hasAudio ? 90.0 : 0.0;
+    // Watch audio state to determine if mini player should be shown
+    final audioState = ref.watch(audioProvider.select((s) => (
+      hasAudio: s.hasAudio,
+      playingAudiobookId: s.audiobook?['id'] as int?,
+    )));
+
+    // Show mini player only if audio is playing AND it's a DIFFERENT audiobook
+    // (Don't show mini player when viewing the same audiobook that's playing)
+    final showMiniPlayer = audioState.hasAudio &&
+        audioState.playingAudiobookId != null &&
+        audioState.playingAudiobookId != widget.audiobookId;
+
+    final bottomPadding = showMiniPlayer ? 90.0 : 0.0;
 
     return Directionality(
       textDirection: TextDirection.rtl,
       child: Scaffold(
         backgroundColor: AppColors.background,
-        body: _buildBody(bottomPadding),
+        body: Column(
+          children: [
+            Expanded(child: _buildBody(bottomPadding)),
+            // Mini player at bottom when playing different audiobook
+            if (showMiniPlayer) const MiniPlayer(),
+          ],
+        ),
       ),
     );
   }
@@ -613,14 +797,10 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
             onPressed: () => Navigator.pop(context),
             icon: const Icon(Icons.arrow_back_ios),
           ),
-          const Expanded(
+          Expanded(
             child: Text(
               'جزئیات کتاب',
-              style: TextStyle(
-                fontSize: 18,
-                fontWeight: FontWeight.w600,
-                color: AppColors.textPrimary,
-              ),
+              style: AppTypography.appBarTitle,
               textAlign: TextAlign.center,
             ),
           ),
@@ -682,9 +862,23 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
         onSelected: (value) {
           if (value == 'report') {
             _reportIssue();
+          } else if (value == 'test_payment') {
+            _openPaymentTest();
+          } else if (value == 'add_to_playlist') {
+            _showAddToPlaylistSheet();
           }
         },
         itemBuilder: (context) => [
+          const PopupMenuItem<String>(
+            value: 'add_to_playlist',
+            child: Row(
+              children: [
+                Icon(Icons.playlist_add, color: AppColors.primary, size: 20),
+                SizedBox(width: 12),
+                Text('افزودن به لیست پخش', style: TextStyle(color: AppColors.textPrimary)),
+              ],
+            ),
+          ),
           const PopupMenuItem<String>(
             value: 'report',
             child: Row(
@@ -695,6 +889,18 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
               ],
             ),
           ),
+          // Debug option - only visible in debug builds
+          if (kDebugMode)
+            const PopupMenuItem<String>(
+              value: 'test_payment',
+              child: Row(
+                children: [
+                  Icon(Icons.bug_report, color: AppColors.warning, size: 20),
+                  SizedBox(width: 12),
+                  Text('Test Payment (Debug)', style: TextStyle(color: AppColors.warning)),
+                ],
+              ),
+            ),
         ],
       ),
     );
@@ -737,10 +943,11 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
               child: ClipRRect(
                 borderRadius: BorderRadius.circular(16),
                 child: coverUrl != null
-                    ? Image.network(
-                        coverUrl,
+                    ? CachedNetworkImage(
+                        imageUrl: coverUrl,
                         fit: BoxFit.cover,
-                        errorBuilder: (_, __, ___) => _buildCoverPlaceholder(),
+                        placeholder: (_, __) => _buildCoverPlaceholder(),
+                        errorWidget: (_, __, ___) => _buildCoverPlaceholder(),
                       )
                     : _buildCoverPlaceholder(),
               ),
@@ -752,9 +959,9 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
   }
 
   Widget _buildCoverPlaceholder() {
-    return Container(
+    return const ColoredBox(
       color: AppColors.surface,
-      child: const Center(
+      child: Center(
         child: Icon(Icons.headphones, color: AppColors.textTertiary, size: 60),
       ),
     );
@@ -762,11 +969,68 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
 
   Widget _buildInfoSection() {
     final title = (_audiobook!['title_fa'] as String?) ?? '';
-    final narrator = (_audiobook!['profiles']?['display_name'] as String?) ??
+    final isMusic = _audiobook!['is_music'] == true;
+    // Check if this book is branded as "پرستو"
+    final isParastoBrand = (_audiobook!['is_parasto_brand'] as bool?) ?? false;
+    final narratorRaw = (_audiobook!['profiles']?['display_name'] as String?) ??
         (_audiobook!['profiles']?['full_name'] as String?) ??
         '';
-    final authorFa = (_audiobook!['author_fa'] as String?) ?? '';
-    final translatorFa = (_audiobook!['translator_fa'] as String?) ?? '';
+    final narrator = isParastoBrand ? 'پرستو' : narratorRaw;
+
+    // Get metadata from new tables if available, fallback to legacy columns
+    String authorFa;
+    String translatorFa;
+    String artistName;
+    String composer;
+    String lyricist;
+    String album;
+    String genre;
+    int? releaseYear;
+
+    if (isMusic && _metadata != null) {
+      // Music metadata from music_metadata table
+      artistName = (_metadata!['artist_name'] as String?) ?? '';
+      composer = (_metadata!['composer'] as String?) ?? '';
+      lyricist = (_metadata!['lyricist'] as String?) ?? '';
+      album = (_metadata!['album_title'] as String?) ?? '';
+      genre = (_metadata!['genre'] as String?) ?? '';
+      releaseYear = _metadata!['release_year'] as int?;
+      // Fallback to legacy author_fa if no artist_name
+      if (artistName.isEmpty) {
+        artistName = (_audiobook!['author_fa'] as String?) ?? '';
+      }
+      authorFa = '';
+      translatorFa = '';
+    } else if (!isMusic && _metadata != null) {
+      // Book metadata from book_metadata table
+      authorFa = (_metadata!['author_name'] as String?) ?? '';
+      translatorFa = (_metadata!['translator'] as String?) ?? '';
+      // Fallback to legacy columns if metadata is empty
+      if (authorFa.isEmpty) {
+        authorFa = (_audiobook!['author_fa'] as String?) ?? '';
+      }
+      if (translatorFa.isEmpty) {
+        translatorFa = (_audiobook!['translator_fa'] as String?) ?? '';
+      }
+      artistName = '';
+      composer = '';
+      lyricist = '';
+      album = '';
+      genre = '';
+      releaseYear = null;
+    } else {
+      // No metadata table data - use legacy columns
+      authorFa = (_audiobook!['author_fa'] as String?) ?? '';
+      translatorFa = (_audiobook!['translator_fa'] as String?) ?? '';
+      artistName = isMusic ? authorFa : ''; // For music, author_fa is artist
+      composer = '';
+      lyricist = '';
+      album = '';
+      genre = '';
+      releaseYear = null;
+      if (isMusic) authorFa = ''; // Clear for music display
+    }
+
     final category = (_audiobook!['categories']?['name_fa'] as String?) ?? '';
     final avgRating = (_audiobook!['avg_rating'] as num?)?.toDouble() ?? 0.0;
     // Use database review_count, or count from loaded reviews as fallback
@@ -784,73 +1048,196 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
           // Title
           Text(
             title,
-            style: const TextStyle(
-              fontSize: 26,
-              fontWeight: FontWeight.bold,
-              color: AppColors.textPrimary,
-              height: 1.3,
-            ),
+            style: AppTypography.heroTitle,
             textAlign: TextAlign.center,
           ),
           const SizedBox(height: 8),
 
-          // Author
-          if (authorFa.isNotEmpty)
-            Row(
-              mainAxisAlignment: MainAxisAlignment.center,
-              children: [
-                const Icon(Icons.edit, size: 16, color: AppColors.textSecondary),
-                const SizedBox(width: 6),
-                Text(
-                  authorFa,
-                  style: const TextStyle(
-                    fontSize: 15,
-                    color: AppColors.textPrimary,
-                    fontWeight: FontWeight.w500,
+          // MUSIC: Artist/Composer/Lyricist/Album
+          if (isMusic) ...[
+            // Artist - show if legacy field has data OR if linked creator exists
+            () {
+              final artistCreator = _getCreatorByRole('singer') ?? _getCreatorByRole('artist');
+              final hasArtist = artistName.isNotEmpty || artistCreator != null;
+              if (!hasArtist) return const SizedBox.shrink();
+              return Row(
+                mainAxisAlignment: MainAxisAlignment.center,
+                children: [
+                  const Icon(Icons.person, size: 16, color: AppColors.textSecondary),
+                  const SizedBox(width: 6),
+                  _buildTappableCreatorName(
+                    name: artistCreator?['display_name'] as String? ?? artistName,
+                    creatorId: artistCreator?['id'] as String?,
+                    style: AppTypography.bodyLarge.copyWith(fontWeight: FontWeight.w500),
                   ),
-                  textAlign: TextAlign.center,
+                ],
+              );
+            }(),
+
+            // Composer - show if legacy field has data OR if linked creator exists
+            () {
+              final composerCreator = _getCreatorByRole('composer');
+              final hasComposer = composer.isNotEmpty || composerCreator != null;
+              if (!hasComposer) return const SizedBox.shrink();
+              return Padding(
+                padding: const EdgeInsets.only(top: 4),
+                child: Row(
+                  mainAxisAlignment: MainAxisAlignment.center,
+                  children: [
+                    const Icon(Icons.piano, size: 14, color: AppColors.textTertiary),
+                    const SizedBox(width: 6),
+                    _buildTappableCreatorName(
+                      name: composerCreator?['display_name'] as String? ?? composer,
+                      creatorId: composerCreator?['id'] as String?,
+                      style: AppTypography.bodySmall,
+                      prefix: 'آهنگساز: ',
+                    ),
+                  ],
                 ),
-              ],
-            ),
+              );
+            }(),
 
-          // Translator (only show if exists)
-          if (translatorFa.isNotEmpty) ...[
-            const SizedBox(height: 4),
-            Row(
-              mainAxisAlignment: MainAxisAlignment.center,
-              children: [
-                const Icon(Icons.translate, size: 14, color: AppColors.textTertiary),
-                const SizedBox(width: 6),
-                Text(
-                  'ترجمه: $translatorFa',
-                  style: TextStyle(
-                    fontSize: 13,
-                    color: AppColors.textSecondary,
-                  ),
-                  textAlign: TextAlign.center,
+            // Lyricist - show if legacy field has data OR if linked creator exists
+            () {
+              final lyricistCreator = _getCreatorByRole('lyricist');
+              final hasLyricist = lyricist.isNotEmpty || lyricistCreator != null;
+              if (!hasLyricist) return const SizedBox.shrink();
+              return Padding(
+                padding: const EdgeInsets.only(top: 4),
+                child: Row(
+                  mainAxisAlignment: MainAxisAlignment.center,
+                  children: [
+                    const Icon(Icons.text_fields, size: 14, color: AppColors.textTertiary),
+                    const SizedBox(width: 6),
+                    _buildTappableCreatorName(
+                      name: lyricistCreator?['display_name'] as String? ?? lyricist,
+                      creatorId: lyricistCreator?['id'] as String?,
+                      style: AppTypography.bodySmall,
+                      prefix: 'شاعر: ',
+                    ),
+                  ],
                 ),
-              ],
-            ),
+              );
+            }(),
+
+            // Album
+            if (album.isNotEmpty) ...[
+              const SizedBox(height: 4),
+              Row(
+                mainAxisAlignment: MainAxisAlignment.center,
+                children: [
+                  const Icon(Icons.album, size: 14, color: AppColors.textTertiary),
+                  const SizedBox(width: 6),
+                  Text(
+                    'آلبوم: $album',
+                    style: AppTypography.bodySmall,
+                    textAlign: TextAlign.center,
+                  ),
+                ],
+              ),
+            ],
+
+            // Genre
+            if (genre.isNotEmpty) ...[
+              const SizedBox(height: 4),
+              Row(
+                mainAxisAlignment: MainAxisAlignment.center,
+                children: [
+                  const Icon(Icons.music_note, size: 14, color: AppColors.textTertiary),
+                  const SizedBox(width: 6),
+                  Text(
+                    'سبک: $genre',
+                    style: AppTypography.bodySmall,
+                    textAlign: TextAlign.center,
+                  ),
+                ],
+              ),
+            ],
+
+            // Release Year
+            if (releaseYear != null) ...[
+              const SizedBox(height: 4),
+              Row(
+                mainAxisAlignment: MainAxisAlignment.center,
+                children: [
+                  const Icon(Icons.calendar_today, size: 14, color: AppColors.textTertiary),
+                  const SizedBox(width: 6),
+                  Text(
+                    'سال انتشار: $releaseYear',
+                    style: AppTypography.bodySmall,
+                    textAlign: TextAlign.center,
+                  ),
+                ],
+              ),
+            ],
           ],
 
-          // Narrator
-          if (narrator.isNotEmpty) ...[
-            const SizedBox(height: 4),
-            Row(
-              mainAxisAlignment: MainAxisAlignment.center,
-              children: [
-                const Icon(Icons.mic, size: 14, color: AppColors.textTertiary),
-                const SizedBox(width: 6),
-                Text(
-                  'گوینده: $narrator',
-                  style: TextStyle(
-                    fontSize: 13,
-                    color: AppColors.textSecondary,
+          // BOOK: Author/Translator/Narrator
+          if (!isMusic) ...[
+            // Author - show if legacy field has data OR if linked creator exists
+            () {
+              final authorCreator = _getCreatorByRole('author');
+              final hasAuthor = authorFa.isNotEmpty || authorCreator != null;
+              if (!hasAuthor) return const SizedBox.shrink();
+              return Row(
+                mainAxisAlignment: MainAxisAlignment.center,
+                children: [
+                  const Icon(Icons.edit, size: 16, color: AppColors.textSecondary),
+                  const SizedBox(width: 6),
+                  _buildTappableCreatorName(
+                    name: authorCreator?['display_name'] as String? ?? authorFa,
+                    creatorId: authorCreator?['id'] as String?,
+                    style: AppTypography.bodyLarge.copyWith(fontWeight: FontWeight.w500),
                   ),
-                  textAlign: TextAlign.center,
+                ],
+              );
+            }(),
+
+            // Translator - show if legacy field has data OR if linked creator exists
+            () {
+              final translatorCreator = _getCreatorByRole('translator');
+              final hasTranslator = translatorFa.isNotEmpty || translatorCreator != null;
+              if (!hasTranslator) return const SizedBox.shrink();
+              return Padding(
+                padding: const EdgeInsets.only(top: 4),
+                child: Row(
+                  mainAxisAlignment: MainAxisAlignment.center,
+                  children: [
+                    const Icon(Icons.translate, size: 14, color: AppColors.textTertiary),
+                    const SizedBox(width: 6),
+                    _buildTappableCreatorName(
+                      name: translatorCreator?['display_name'] as String? ?? translatorFa,
+                      creatorId: translatorCreator?['id'] as String?,
+                      style: AppTypography.bodySmall,
+                      prefix: 'ترجمه: ',
+                    ),
+                  ],
                 ),
-              ],
-            ),
+              );
+            }(),
+
+            // Narrator - show if legacy field has data OR if linked creator exists
+            () {
+              final narratorCreator = _getCreatorByRole('narrator');
+              final hasNarrator = narrator.isNotEmpty || narratorCreator != null;
+              if (!hasNarrator) return const SizedBox.shrink();
+              return Padding(
+                padding: const EdgeInsets.only(top: 4),
+                child: Row(
+                  mainAxisAlignment: MainAxisAlignment.center,
+                  children: [
+                    const Icon(Icons.mic, size: 14, color: AppColors.textTertiary),
+                    const SizedBox(width: 6),
+                    _buildTappableCreatorName(
+                      name: narratorCreator?['display_name'] as String? ?? narrator,
+                      creatorId: narratorCreator?['id'] as String?,
+                      style: AppTypography.bodySmall,
+                      prefix: 'گوینده: ',
+                    ),
+                  ],
+                ),
+              );
+            }(),
           ],
           const SizedBox(height: 16),
 
@@ -902,13 +1289,13 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
               ),
               child: Text(
                 category,
-                style: TextStyle(
-                  color: AppColors.primary,
-                  fontSize: 13,
-                  fontWeight: FontWeight.w500,
-                ),
+                style: AppTypography.chip.copyWith(color: AppColors.primary),
               ),
             ),
+          const SizedBox(height: 16),
+
+          // Share & Gift Actions
+          _buildShareGiftActions(title, narrator),
           const SizedBox(height: 20),
 
           // Progress Card (if owned and has progress)
@@ -930,19 +1317,12 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
         const SizedBox(height: 6),
         Text(
           value,
-          style: const TextStyle(
-            color: AppColors.textPrimary,
-            fontWeight: FontWeight.bold,
-            fontSize: 16,
-          ),
+          style: AppTypography.titleLarge.copyWith(fontWeight: FontWeight.bold),
         ),
         const SizedBox(height: 2),
         Text(
           label,
-          style: TextStyle(
-            color: AppColors.textTertiary,
-            fontSize: 11,
-          ),
+          style: AppTypography.labelSmall,
         ),
       ],
     );
@@ -956,6 +1336,105 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
     );
   }
 
+  Widget _buildShareGiftActions(String title, String narrator) {
+    return Row(
+      mainAxisAlignment: MainAxisAlignment.center,
+      children: [
+        // Share Button
+        _buildActionButton(
+          icon: Icons.share_outlined,
+          label: 'اشتراک‌گذاری',
+          onTap: () => _shareBook(title, narrator),
+        ),
+        const SizedBox(width: 16),
+        // Gift Button (Coming Soon)
+        _buildActionButton(
+          icon: Icons.card_giftcard_outlined,
+          label: 'هدیه دادن',
+          onTap: () => _showGiftComingSoon(title, narrator),
+        ),
+      ],
+    );
+  }
+
+  Widget _buildActionButton({
+    required IconData icon,
+    required String label,
+    required VoidCallback onTap,
+  }) {
+    return InkWell(
+      onTap: onTap,
+      borderRadius: BorderRadius.circular(12),
+      child: Container(
+        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
+        decoration: BoxDecoration(
+          color: AppColors.surface,
+          borderRadius: BorderRadius.circular(12),
+          border: Border.all(color: AppColors.border),
+        ),
+        child: Row(
+          mainAxisSize: MainAxisSize.min,
+          children: [
+            Icon(icon, size: 18, color: AppColors.textSecondary),
+            const SizedBox(width: 8),
+            Text(
+              label,
+              style: AppTypography.bodySmall.copyWith(
+                color: AppColors.textSecondary,
+              ),
+            ),
+          ],
+        ),
+      ),
+    );
+  }
+
+  String _getShareText(String title, String narrator) {
+    final buffer = StringBuffer();
+    buffer.write('🎧 $title');
+    if (narrator.isNotEmpty) {
+      buffer.write(' - $narrator');
+    }
+    buffer.write('\n\nدر اپلیکیشن پرستو گوش کنید.');
+    return buffer.toString();
+  }
+
+  void _shareBook(String title, String narrator) {
+    final shareText = _getShareText(title, narrator);
+    Clipboard.setData(ClipboardData(text: shareText));
+    ScaffoldMessenger.of(context).showSnackBar(
+      const SnackBar(
+        content: Text('متن اشتراک‌گذاری کپی شد'),
+        backgroundColor: AppColors.success,
+        duration: Duration(seconds: 2),
+      ),
+    );
+  }
+
+  void _showGiftComingSoon(String title, String narrator) {
+    showModalBottomSheet<void>(
+      context: context,
+      isScrollControlled: true,
+      backgroundColor: AppColors.surface,
+      shape: const RoundedRectangleBorder(
+        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
+      ),
+      builder: (context) => _GiftBottomSheet(
+        bookTitle: title,
+        onContinue: (email, message) {
+          Navigator.pop(context);
+          ScaffoldMessenger.of(context).showSnackBar(
+            const SnackBar(
+              content: Text('پرداخت هدیه به‌زودی فعال می‌شود.'),
+              backgroundColor: AppColors.primary,
+              duration: Duration(seconds: 3),
+            ),
+          );
+        },
+      ),
+    );
+  }
+
   Widget _buildProgressCard() {
     final percentage = (_progress!['completion_percentage'] as num?)?.toInt() ?? 0;
     final currentChapter = ((_progress!['current_chapter_index'] as int?) ?? 0) + 1;
@@ -991,11 +1470,7 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
               ),
               Text(
                 '$percentage%',
-                style: const TextStyle(
-                  color: AppColors.textPrimary,
-                  fontSize: 13,
-                  fontWeight: FontWeight.bold,
-                ),
+                style: AppTypography.labelLarge,
               ),
             ],
           ),
@@ -1004,18 +1479,14 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
             child: Column(
               crossAxisAlignment: CrossAxisAlignment.start,
               children: [
-                const Text(
+                Text(
                   'ادامه گوش دادن',
-                  style: TextStyle(
-                    color: AppColors.textPrimary,
-                    fontWeight: FontWeight.bold,
-                    fontSize: 15,
-                  ),
+                  style: AppTypography.titleMedium.copyWith(fontWeight: FontWeight.bold),
                 ),
                 const SizedBox(height: 4),
                 Text(
                   'فصل $currentChapter از ${_chapters.length}',
-                  style: TextStyle(color: AppColors.textSecondary, fontSize: 13),
+                  style: AppTypography.bodySmall,
                 ),
               ],
             ),
@@ -1023,7 +1494,7 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
           ElevatedButton.icon(
             onPressed: () => _playAudiobook(
               chapterIndex: (_progress!['current_chapter_index'] as int?) ?? 0,
-              seekTo: (_progress!['position_seconds'] as int?),
+              seekTo: _progress!['position_seconds'] as int?,
             ),
             style: ElevatedButton.styleFrom(
               backgroundColor: AppColors.primary,
@@ -1042,6 +1513,28 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
     final isFree = _audiobook!['is_free'] == true;
     final price = (_audiobook!['price_toman'] as int?) ?? 0;
 
+    // Determine if user has incomplete progress (for continue vs start logic)
+    final hasIncompleteProgress = _isOwned &&
+        _progress != null &&
+        (_progress!['is_completed'] != true) &&
+        ((_progress!['completion_percentage'] as num?)?.toInt() ?? 0) < 100;
+
+    // Button text and action for owned books
+    String ownedButtonLabel;
+    VoidCallback ownedButtonAction;
+    if (hasIncompleteProgress) {
+      // Has incomplete progress - show "ادامه" and continue from saved position
+      ownedButtonLabel = 'ادامه';
+      ownedButtonAction = () => _playAudiobook(
+        chapterIndex: (_progress!['current_chapter_index'] as int?) ?? 0,
+        seekTo: _progress!['position_seconds'] as int?,
+      );
+    } else {
+      // No progress or completed - show "شروع" and start from beginning
+      ownedButtonLabel = 'شروع';
+      ownedButtonAction = () => _playAudiobook(chapterIndex: 0);
+    }
+
     return Positioned(
       left: 0,
       right: 0,
@@ -1081,7 +1574,7 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
                       ),
                     ),
                     if (!isFree)
-                      Text(
+                      const Text(
                         'یک‌بار خرید، برای همیشه',
                         style: TextStyle(
                           fontSize: 11,
@@ -1101,7 +1594,7 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
                 height: 52,
                 child: ElevatedButton.icon(
                   onPressed: _isOwned
-                      ? () => _playAudiobook()
+                      ? ownedButtonAction
                       : _isPurchasing
                           ? null
                           : _purchase,
@@ -1124,7 +1617,7 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
                         ),
                   label: Text(
                     _isOwned
-                        ? 'گوش دادن'
+                        ? ownedButtonLabel
                         : isFree
                             ? 'افزودن به کتابخانه'
                             : 'خرید',
@@ -1177,13 +1670,16 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
     final description = (_audiobook!['description_fa'] as String?) ?? '';
     if (description.isEmpty) return const SizedBox.shrink();
 
+    // FIX: Use appropriate label based on content type (book vs music)
+    final isMusic = _audiobook!['is_music'] == true;
+    final sectionTitle = isMusic ? 'درباره‌ی این اثر' : 'درباره‌ی این کتاب';
+
     return _buildSection(
-      title: 'درباره‌ی این کتاب',
+      title: sectionTitle,
       child: Text(
         description,
-        style: TextStyle(
+        style: AppTypography.bodyLarge.copyWith(
           color: AppColors.textSecondary,
-          fontSize: 15,
           height: 1.8,
         ),
       ),
@@ -1342,9 +1838,20 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
                     ),
                     textAlign: TextAlign.center,
                   ),
-                  const SizedBox(height: 8),
-                  TextButton.icon(
-                    onPressed: _fetchAiSummary,
+                  if (!kReleaseMode && _summaryErrorDetails != null) ...[
+                    const SizedBox(height: 6),
+                    Text(
+                      _summaryErrorDetails!,
+                      style: const TextStyle(
+                        color: AppColors.textTertiary,
+                        fontSize: 11,
+                      ),
+                      textAlign: TextAlign.center,
+                    ),
+                  ],
+                  const SizedBox(height: 8),
+                  TextButton.icon(
+                    onPressed: _fetchAiSummary,
                     icon: const Icon(Icons.refresh, size: 16),
                     label: const Text('تلاش مجدد'),
                     style: TextButton.styleFrom(
@@ -1376,6 +1883,14 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
     );
   }
 
+  String _formatSummaryErrorDetails(BookSummaryResult result) {
+    final code = result.errorCode ?? result.errorType ?? 'unknown';
+    if (result.errorStatus != null) {
+      return 'AI error: $code (${result.errorStatus})';
+    }
+    return 'AI error: $code';
+  }
+
   Widget _buildChaptersSection() {
     if (_chapters.isEmpty) return const SizedBox.shrink();
 
@@ -1388,12 +1903,12 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
       title: 'فهرست فصل‌ها',
       trailing: Text(
         '${_chapters.length} فصل',
-        style: TextStyle(
+        style: const TextStyle(
           color: AppColors.textTertiary,
           fontSize: 13,
         ),
       ),
-      child: Container(
+      child: DecoratedBox(
         decoration: BoxDecoration(
           color: AppColors.surface,
           borderRadius: BorderRadius.circular(16),
@@ -1407,7 +1922,7 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
                 children: [
                   _buildChapterTile(index),
                   if (!isLast)
-                    Divider(
+                    const Divider(
                       height: 1,
                       indent: 56,
                       endIndent: 16,
@@ -1418,7 +1933,7 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
             }),
             // Show more/less button
             if (hasMore) ...[
-              Divider(
+              const Divider(
                 height: 1,
                 indent: 16,
                 endIndent: 16,
@@ -1443,7 +1958,7 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
                         _chaptersExpanded
                             ? 'نمایش کمتر'
                             : 'نمایش همه ${_chapters.length} فصل',
-                        style: TextStyle(
+                        style: const TextStyle(
                           color: AppColors.primary,
                           fontWeight: FontWeight.w600,
                           fontSize: 14,
@@ -1471,12 +1986,35 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
   Widget _buildChapterTile(int i) {
     final ch = _chapters[i];
     final chapterId = ch['id'] as int;
-    final isCurrent = _progress != null && (_progress!['current_chapter_index'] as int?) == i;
+    final currentChapterIndex = (_progress?['current_chapter_index'] as int?) ?? -1;
+    final albumIsCompleted = _progress?['is_completed'] == true;
+    final completionPercentage = (_progress?['completion_percentage'] as num?)?.toInt() ?? 0;
+
+    // Chapter is "current" only if album is NOT fully completed
+    final isCurrent = _progress != null && !albumIsCompleted && currentChapterIndex == i;
+
+    // Chapter is completed if:
+    // 1) Album is fully completed (is_completed=true OR completion_percentage >= 100), OR
+    // 2) Album is in progress and this chapter is before the current chapter
+    final isCompleted = _progress != null &&
+        (albumIsCompleted || completionPercentage >= 100 || i < currentChapterIndex);
+
     final isPreview = ch['is_preview'] == true;
-    final canPlay = _isOwned || isPreview;
+    final isFree = _audiobook!['is_free'] == true;
+    // Allow playing if: owned, OR preview chapter, OR it's a free audiobook
+    final canPlay = _isOwned || isPreview || isFree;
     final title = (ch['title_fa'] as String?) ?? 'فصل ${i + 1}';
     final duration = (ch['duration_seconds'] as int?) ?? 0;
 
+    // Calculate chapter-level progress for current chapter
+    double chapterProgress = 0.0;
+    if (isCompleted) {
+      chapterProgress = 1.0; // Fully completed chapters
+    } else if (isCurrent && duration > 0) {
+      final positionSeconds = (_progress!['position_seconds'] as int?) ?? 0;
+      chapterProgress = (positionSeconds / duration).clamp(0.0, 1.0);
+    }
+
     ref.watch(downloadProvider);
     final downloadNotifier = ref.read(downloadProvider.notifier);
     final downloadStatus = downloadNotifier.getStatus(widget.audiobookId, chapterId);
@@ -1489,25 +2027,31 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
         padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 14),
         child: Row(
           children: [
-            // Chapter Number
+            // Chapter Number / Status Icon
             Container(
               width: 36,
               height: 36,
               decoration: BoxDecoration(
-                color: isCurrent ? AppColors.primary : AppColors.surfaceLight,
+                color: isCurrent
+                    ? AppColors.primary
+                    : isCompleted
+                        ? AppColors.success.withOpacity(0.15)
+                        : AppColors.surfaceLight,
                 borderRadius: BorderRadius.circular(10),
               ),
               child: Center(
                 child: isCurrent
                     ? const Icon(Icons.play_arrow, color: Colors.white, size: 18)
-                    : Text(
-                        '${i + 1}',
-                        style: TextStyle(
-                          color: canPlay ? AppColors.textPrimary : AppColors.textTertiary,
-                          fontWeight: FontWeight.w600,
-                          fontSize: 14,
-                        ),
-                      ),
+                    : isCompleted
+                        ? const Icon(Icons.check, color: AppColors.success, size: 18)
+                        : Text(
+                            '${i + 1}',
+                            style: TextStyle(
+                              color: canPlay ? AppColors.textPrimary : AppColors.textTertiary,
+                              fontWeight: FontWeight.w600,
+                              fontSize: 14,
+                            ),
+                          ),
               ),
             ),
             const SizedBox(width: 12),
@@ -1554,12 +2098,24 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
                         const Icon(Icons.lock_outline, size: 16, color: AppColors.textTertiary),
                     ],
                   ),
+                  // Chapter listening progress bar (for current chapter)
+                  if (isCurrent && chapterProgress > 0 && downloadStatus != DownloadStatus.downloading) ...[
+                    const SizedBox(height: 6),
+                    LinearProgressIndicator(
+                      value: chapterProgress,
+                      backgroundColor: AppColors.surfaceLight,
+                      color: AppColors.primary,
+                      minHeight: 3,
+                      borderRadius: BorderRadius.circular(2),
+                    ),
+                  ],
+                  // Download progress bar (while downloading)
                   if (downloadStatus == DownloadStatus.downloading) ...[
                     const SizedBox(height: 6),
                     LinearProgressIndicator(
                       value: downloadProgress,
                       backgroundColor: AppColors.surfaceLight,
-                      color: AppColors.primary,
+                      color: AppColors.secondary,
                       minHeight: 3,
                       borderRadius: BorderRadius.circular(2),
                     ),
@@ -1579,7 +2135,7 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
                   ),
                 Text(
                   Formatters.formatDuration(duration),
-                  style: TextStyle(
+                  style: const TextStyle(
                     color: AppColors.textTertiary,
                     fontSize: 12,
                   ),
@@ -1694,7 +2250,7 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
                     const SizedBox(height: 4),
                     Text(
                       '$reviewCount نظر',
-                      style: TextStyle(
+                      style: const TextStyle(
                         color: AppColors.textTertiary,
                         fontSize: 12,
                       ),
@@ -1728,7 +2284,7 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
                           icon: const Icon(Icons.rate_review_outlined, size: 20),
                           label: const Text('نوشتن نظر'),
                         )
-                      : Text(
+                      : const Text(
                           'برای ثبت نظر، ابتدا کتاب را تهیه کنید',
                           style: TextStyle(
                             color: AppColors.textTertiary,
@@ -1750,11 +2306,11 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
                 color: AppColors.surface,
                 borderRadius: BorderRadius.circular(16),
               ),
-              child: Center(
+              child: const Center(
                 child: Column(
                   children: [
                     Icon(Icons.chat_bubble_outline, size: 40, color: AppColors.textTertiary),
-                    const SizedBox(height: 12),
+                    SizedBox(height: 12),
                     Text(
                       'هنوز نظری ثبت نشده',
                       style: TextStyle(color: AppColors.textTertiary),
@@ -1790,11 +2346,7 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
             children: [
               Text(
                 title,
-                style: const TextStyle(
-                  fontSize: 20,
-                  fontWeight: FontWeight.bold,
-                  color: AppColors.textPrimary,
-                ),
+                style: AppTypography.sectionTitle,
               ),
               if (trailing != null) trailing,
             ],
@@ -1913,4 +2465,804 @@ class _AudiobookDetailScreenState extends ConsumerState<AudiobookDetailScreen> {
       ),
     );
   }
+
+  /// Build a tappable creator name widget.
+  /// If creator is linked (has id), tapping navigates to their profile.
+  /// Otherwise, displays as static text (fallback for legacy data).
+  Widget _buildTappableCreatorName({
+    required String name,
+    String? creatorId,
+    required TextStyle style,
+    String? prefix, // e.g., "گوینده: " or "ترجمه: "
+  }) {
+    final displayText = prefix != null ? '$prefix$name' : name;
+
+    if (creatorId != null && creatorId.isNotEmpty) {
+      // Creator is linked - make tappable
+      return GestureDetector(
+        onTap: () {
+          Navigator.push(
+            context,
+            MaterialPageRoute<void>(
+              builder: (_) => CreatorProfileScreen(creatorId: creatorId),
+            ),
+          );
+        },
+        child: Text(
+          displayText,
+          style: style.copyWith(
+            decoration: TextDecoration.underline,
+            decorationColor: AppColors.primary.withOpacity(0.5),
+          ),
+          textAlign: TextAlign.center,
+        ),
+      );
+    } else {
+      // No linked creator - static text
+      return Text(
+        displayText,
+        style: style,
+        textAlign: TextAlign.center,
+      );
+    }
+  }
+
+  /// Get creator by role from _creators list.
+  /// Returns null if no creator with that role is linked.
+  Map<String, dynamic>? _getCreatorByRole(String role) {
+    for (final creator in _creators) {
+      if (creator['role'] == role) {
+        return creator;
+      }
+    }
+    return null;
+  }
+}
+
+// =============================================================================
+// ADD TO PLAYLIST BOTTOM SHEET
+// =============================================================================
+
+class _AddToPlaylistSheet extends ConsumerStatefulWidget {
+  final int audiobookId;
+  final String audiobookTitle;
+  final bool isMusic;
+  final List<Map<String, dynamic>> chapters;
+
+  const _AddToPlaylistSheet({
+    required this.audiobookId,
+    required this.audiobookTitle,
+    required this.isMusic,
+    required this.chapters,
+  });
+
+  @override
+  ConsumerState<_AddToPlaylistSheet> createState() => _AddToPlaylistSheetState();
+}
+
+class _AddToPlaylistSheetState extends ConsumerState<_AddToPlaylistSheet> {
+  List<Playlist> _playlists = [];
+  bool _isLoading = true;
+  bool _isAdding = false;
+  String? _addingToPlaylistId;
+
+  // Chapter selection state
+  // null = whole book/album, integer = specific chapter index
+  int? _selectedChapterIndex;
+
+  Widget _buildChapterOption({
+    required String title,
+    required String subtitle,
+    required IconData icon,
+    required bool isSelected,
+    required VoidCallback onTap,
+  }) {
+    return GestureDetector(
+      onTap: onTap,
+      child: Container(
+        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
+        decoration: BoxDecoration(
+          color: isSelected ? AppColors.primary.withOpacity(0.1) : AppColors.surfaceLight,
+          borderRadius: BorderRadius.circular(12),
+          border: isSelected ? Border.all(color: AppColors.primary.withOpacity(0.5)) : null,
+        ),
+        child: Row(
+          children: [
+            Icon(icon, color: isSelected ? AppColors.primary : AppColors.textSecondary, size: 20),
+            const SizedBox(width: 12),
+            Expanded(
+              child: Column(
+                crossAxisAlignment: CrossAxisAlignment.start,
+                children: [
+                  Text(
+                    title,
+                    style: TextStyle(
+                      color: isSelected ? AppColors.primary : AppColors.textPrimary,
+                      fontWeight: FontWeight.w500,
+                      fontSize: 14,
+                    ),
+                  ),
+                  Text(
+                    subtitle,
+                    style: const TextStyle(
+                      color: AppColors.textTertiary,
+                      fontSize: 12,
+                    ),
+                  ),
+                ],
+              ),
+            ),
+            if (isSelected)
+              const Icon(Icons.check_circle, color: AppColors.primary, size: 20),
+          ],
+        ),
+      ),
+    );
+  }
+
+  @override
+  void initState() {
+    super.initState();
+    _loadPlaylists();
+  }
+
+  Future<void> _loadPlaylists() async {
+    setState(() => _isLoading = true);
+
+    final service = ref.read(playlistServiceProvider);
+    final playlists = await service.getUserPlaylists(isMusic: widget.isMusic);
+
+    if (mounted) {
+      setState(() {
+        _playlists = playlists;
+        _isLoading = false;
+      });
+    }
+  }
+
+  Future<void> _addToPlaylist(Playlist playlist) async {
+    setState(() {
+      _isAdding = true;
+      _addingToPlaylistId = playlist.id;
+    });
+
+    final service = ref.read(playlistServiceProvider);
+    final result = await service.addItemToPlaylist(
+      playlistId: playlist.id,
+      audiobookId: widget.audiobookId,
+      chapterIndex: _selectedChapterIndex,
+    );
+
+    if (mounted) {
+      setState(() {
+        _isAdding = false;
+        _addingToPlaylistId = null;
+      });
+
+      if (result.isSuccess) {
+        Navigator.pop(context);
+        ScaffoldMessenger.of(context).showSnackBar(
+          SnackBar(
+            content: Text('به "${playlist.title}" اضافه شد'),
+            backgroundColor: AppColors.success,
+          ),
+        );
+        // Invalidate playlists cache
+        if (widget.isMusic) {
+          ref.invalidate(musicPlaylistsProvider);
+        } else {
+          ref.invalidate(bookPlaylistsProvider);
+        }
+      } else if (result.isDuplicate) {
+        // Duplicate: exact same item already exists in this playlist
+        // (same audiobook AND same chapter_index including null for whole book)
+        ScaffoldMessenger.of(context).showSnackBar(
+          const SnackBar(
+            content: Text('این مورد قبلاً به این لیست پخش اضافه شده است'),
+            backgroundColor: AppColors.warning,
+          ),
+        );
+      } else {
+        // Generic error - technical details are already logged by PlaylistService
+        // Show user-friendly message without exposing internal errors
+        ScaffoldMessenger.of(context).showSnackBar(
+          const SnackBar(
+            content: Text('خطا در افزودن به لیست پخش. لطفاً دوباره تلاش کنید.'),
+            backgroundColor: AppColors.error,
+          ),
+        );
+      }
+    }
+  }
+
+  Future<void> _showCreatePlaylistDialog() async {
+    final titleController = TextEditingController();
+
+    final newTitle = await showDialog<String>(
+      context: context,
+      builder: (context) => Directionality(
+        textDirection: TextDirection.rtl,
+        child: AlertDialog(
+          backgroundColor: AppColors.surface,
+          title: const Text(
+            'لیست پخش جدید',
+            style: TextStyle(color: AppColors.textPrimary),
+          ),
+          content: TextField(
+            controller: titleController,
+            decoration: const InputDecoration(
+              labelText: 'نام لیست پخش',
+              hintText: 'مثال: مورد علاقه‌های من',
+            ),
+            autofocus: true,
+          ),
+          actions: [
+            TextButton(
+              onPressed: () => Navigator.pop(context),
+              child: const Text('انصراف'),
+            ),
+            ElevatedButton(
+              onPressed: () {
+                final title = titleController.text.trim();
+                if (title.isNotEmpty) {
+                  Navigator.pop(context, title);
+                }
+              },
+              child: const Text('ایجاد'),
+            ),
+          ],
+        ),
+      ),
+    );
+
+    if (newTitle != null && newTitle.isNotEmpty && mounted) {
+      final service = ref.read(playlistServiceProvider);
+      final playlist = await service.createPlaylist(
+        title: newTitle,
+        isMusic: widget.isMusic,
+      );
+
+      if (playlist != null && mounted) {
+        // Add the audiobook to the new playlist immediately
+        final result = await service.addItemToPlaylist(
+          playlistId: playlist.id,
+          audiobookId: widget.audiobookId,
+          chapterIndex: _selectedChapterIndex,
+        );
+
+        if (result.isSuccess && mounted) {
+          Navigator.pop(context);
+          ScaffoldMessenger.of(context).showSnackBar(
+            SnackBar(
+              content: Text('به "${playlist.title}" اضافه شد'),
+              backgroundColor: AppColors.success,
+            ),
+          );
+          // Invalidate playlists cache
+          if (widget.isMusic) {
+            ref.invalidate(musicPlaylistsProvider);
+          } else {
+            ref.invalidate(bookPlaylistsProvider);
+          }
+        } else if (mounted) {
+          // Playlist was created but adding item failed
+          // Close sheet and show appropriate message
+          Navigator.pop(context);
+          if (result.isDuplicate) {
+            // This shouldn't happen for a new playlist, but handle it anyway
+            ScaffoldMessenger.of(context).showSnackBar(
+              const SnackBar(
+                content: Text('لیست پخش ایجاد شد ولی مورد قبلاً وجود داشت'),
+                backgroundColor: AppColors.warning,
+              ),
+            );
+          } else {
+            // Generic error - technical details are logged by PlaylistService
+            ScaffoldMessenger.of(context).showSnackBar(
+              const SnackBar(
+                content: Text('لیست پخش ایجاد شد ولی خطا در افزودن مورد'),
+                backgroundColor: AppColors.warning,
+              ),
+            );
+          }
+          // Still invalidate cache since playlist was created
+          if (widget.isMusic) {
+            ref.invalidate(musicPlaylistsProvider);
+          } else {
+            ref.invalidate(bookPlaylistsProvider);
+          }
+        }
+      }
+    }
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    // Calculate maximum height for the bottom sheet (70% of screen)
+    final maxSheetHeight = MediaQuery.of(context).size.height * 0.7;
+
+    return Directionality(
+      textDirection: TextDirection.rtl,
+      child: SafeArea(
+        child: ConstrainedBox(
+          constraints: BoxConstraints(maxHeight: maxSheetHeight),
+          child: Padding(
+            padding: const EdgeInsets.all(16),
+            child: Column(
+              mainAxisSize: MainAxisSize.min,
+              crossAxisAlignment: CrossAxisAlignment.start,
+              children: [
+                // Handle
+                Center(
+                  child: Container(
+                    width: 40,
+                    height: 4,
+                    decoration: BoxDecoration(
+                      color: AppColors.textTertiary.withOpacity(0.3),
+                      borderRadius: BorderRadius.circular(2),
+                    ),
+                  ),
+                ),
+                const SizedBox(height: 16),
+                // Title
+                Row(
+                  children: [
+                    const Icon(Icons.playlist_add, color: AppColors.primary),
+                    const SizedBox(width: 12),
+                    Expanded(
+                      child: Text(
+                        'افزودن به لیست پخش',
+                        style: AppTypography.titleMedium.copyWith(
+                          color: AppColors.textPrimary,
+                          fontWeight: FontWeight.bold,
+                        ),
+                      ),
+                    ),
+                  ],
+                ),
+                const SizedBox(height: 8),
+                Text(
+                  widget.audiobookTitle,
+                  style: const TextStyle(
+                    color: AppColors.textSecondary,
+                    fontSize: 14,
+                  ),
+                  maxLines: 1,
+                  overflow: TextOverflow.ellipsis,
+                ),
+                const SizedBox(height: 16),
+                // Scrollable content area
+                Flexible(
+                  child: SingleChildScrollView(
+                    child: Column(
+                      mainAxisSize: MainAxisSize.min,
+                      crossAxisAlignment: CrossAxisAlignment.start,
+                      children: [
+                        // Chapter selection section (only if there are chapters)
+                        if (widget.chapters.isNotEmpty) ...[
+                          Text(
+                            'چه چیزی اضافه شود؟',
+                            style: const TextStyle(
+                              color: AppColors.textPrimary,
+                              fontWeight: FontWeight.w600,
+                              fontSize: 14,
+                            ),
+                          ),
+                          const SizedBox(height: 8),
+                          // Whole book/album option
+                          _buildChapterOption(
+                            title: widget.isMusic ? 'کل آلبوم' : 'کل کتاب',
+                            subtitle: '${widget.chapters.length} ${widget.isMusic ? 'آهنگ' : 'فصل'}',
+                            icon: widget.isMusic ? Icons.album : Icons.book,
+                            isSelected: _selectedChapterIndex == null,
+                            onTap: () => setState(() => _selectedChapterIndex = null),
+                          ),
+                          const SizedBox(height: 8),
+                          // Single chapter/track dropdown
+                          Container(
+                            decoration: BoxDecoration(
+                              color: _selectedChapterIndex != null
+                                  ? AppColors.primary.withOpacity(0.1)
+                                  : AppColors.surfaceLight,
+                              borderRadius: BorderRadius.circular(12),
+                              border: _selectedChapterIndex != null
+                                  ? Border.all(color: AppColors.primary.withOpacity(0.5))
+                                  : null,
+                            ),
+                            child: Theme(
+                              data: Theme.of(context).copyWith(
+                                dividerColor: Colors.transparent,
+                              ),
+                              child: ExpansionTile(
+                                tilePadding: const EdgeInsets.symmetric(horizontal: 12),
+                                childrenPadding: EdgeInsets.zero,
+                                leading: Icon(
+                                  widget.isMusic ? Icons.music_note : Icons.bookmark_outline,
+                                  color: _selectedChapterIndex != null
+                                      ? AppColors.primary
+                                      : AppColors.textSecondary,
+                                  size: 20,
+                                ),
+                                title: Text(
+                                  _selectedChapterIndex != null
+                                      ? (widget.chapters[_selectedChapterIndex!]['title_fa'] as String?) ??
+                                          '${widget.isMusic ? 'آهنگ' : 'فصل'} ${_selectedChapterIndex! + 1}'
+                                      : widget.isMusic ? 'انتخاب آهنگ' : 'انتخاب فصل',
+                                  style: TextStyle(
+                                    color: _selectedChapterIndex != null
+                                        ? AppColors.primary
+                                        : AppColors.textPrimary,
+                                    fontWeight: FontWeight.w500,
+                                    fontSize: 14,
+                                  ),
+                                ),
+                                trailing: _selectedChapterIndex != null
+                                    ? const Icon(Icons.check_circle, color: AppColors.primary, size: 20)
+                                    : const Icon(Icons.expand_more, color: AppColors.textTertiary),
+                                children: [
+                                  ConstrainedBox(
+                                    constraints: const BoxConstraints(maxHeight: 200),
+                                    child: ListView.builder(
+                                      shrinkWrap: true,
+                                      padding: EdgeInsets.zero,
+                                      itemCount: widget.chapters.length,
+                                      itemBuilder: (context, index) {
+                                        final chapter = widget.chapters[index];
+                                        final chapterTitle = (chapter['title_fa'] as String?) ??
+                                            '${widget.isMusic ? 'آهنگ' : 'فصل'} ${index + 1}';
+                                        final isSelected = _selectedChapterIndex == index;
+                                        return ListTile(
+                                          dense: true,
+                                          selected: isSelected,
+                                          selectedTileColor: AppColors.primary.withOpacity(0.1),
+                                          leading: Text(
+                                            '${index + 1}',
+                                            style: TextStyle(
+                                              color: isSelected ? AppColors.primary : AppColors.textTertiary,
+                                              fontWeight: FontWeight.w500,
+                                            ),
+                                          ),
+                                          title: Text(
+                                            chapterTitle,
+                                            style: TextStyle(
+                                              color: isSelected ? AppColors.primary : AppColors.textPrimary,
+                                              fontSize: 13,
+                                            ),
+                                            maxLines: 1,
+                                            overflow: TextOverflow.ellipsis,
+                                          ),
+                                          trailing: isSelected
+                                              ? const Icon(Icons.check, color: AppColors.primary, size: 18)
+                                              : null,
+                                          onTap: () => setState(() => _selectedChapterIndex = index),
+                                        );
+                                      },
+                                    ),
+                                  ),
+                                ],
+                              ),
+                            ),
+                          ),
+                          const SizedBox(height: 16),
+                        ],
+                        // Create new playlist button
+                        OutlinedButton.icon(
+                          onPressed: _showCreatePlaylistDialog,
+                          icon: const Icon(Icons.add),
+                          label: Text(
+                            widget.isMusic ? 'لیست پخش موسیقی جدید' : 'لیست پخش کتاب جدید',
+                          ),
+                          style: OutlinedButton.styleFrom(
+                            foregroundColor: AppColors.primary,
+                            side: const BorderSide(color: AppColors.primary),
+                            minimumSize: const Size.fromHeight(48),
+                          ),
+                        ),
+                        const SizedBox(height: 16),
+                        // Divider
+                        const Divider(height: 1, color: AppColors.surfaceLight),
+                        const SizedBox(height: 8),
+                        // Playlist list
+                        _isLoading
+                            ? const Center(
+                                child: Padding(
+                                  padding: EdgeInsets.all(24),
+                                  child: CircularProgressIndicator(color: AppColors.primary),
+                                ),
+                              )
+                            : _playlists.isEmpty
+                                ? Padding(
+                                    padding: const EdgeInsets.symmetric(vertical: 24),
+                                    child: Center(
+                                      child: Text(
+                                        widget.isMusic
+                                            ? 'هنوز لیست پخش موسیقی ندارید'
+                                            : 'هنوز لیست پخش کتاب ندارید',
+                                        style: const TextStyle(
+                                          color: AppColors.textTertiary,
+                                          fontSize: 14,
+                                        ),
+                                      ),
+                                    ),
+                                  )
+                                : ListView.builder(
+                                    shrinkWrap: true,
+                                    physics: const NeverScrollableScrollPhysics(),
+                                    itemCount: _playlists.length,
+                                    itemBuilder: (context, index) {
+                                      final playlist = _playlists[index];
+                                      final isAddingToThis = _addingToPlaylistId == playlist.id;
+                                      return ListTile(
+                                        onTap: _isAdding ? null : () => _addToPlaylist(playlist),
+                                        leading: Container(
+                                          width: 40,
+                                          height: 40,
+                                          decoration: BoxDecoration(
+                                            color: AppColors.primary.withOpacity(0.1),
+                                            borderRadius: BorderRadius.circular(8),
+                                          ),
+                                          child: Icon(
+                                            widget.isMusic ? Icons.music_note : Icons.book,
+                                            color: AppColors.primary,
+                                            size: 20,
+                                          ),
+                                        ),
+                                        title: Text(
+                                          playlist.title,
+                                          style: const TextStyle(
+                                            color: AppColors.textPrimary,
+                                            fontWeight: FontWeight.w500,
+                                          ),
+                                        ),
+                                        subtitle: Text(
+                                          '${playlist.itemCount} مورد',
+                                          style: const TextStyle(
+                                            color: AppColors.textTertiary,
+                                            fontSize: 12,
+                                          ),
+                                        ),
+                                        trailing: isAddingToThis
+                                            ? const SizedBox(
+                                                width: 24,
+                                                height: 24,
+                                                child: CircularProgressIndicator(
+                                                  strokeWidth: 2,
+                                                  color: AppColors.primary,
+                                                ),
+                                              )
+                                            : const Icon(
+                                                Icons.add_circle_outline,
+                                                color: AppColors.primary,
+                                              ),
+                                      );
+                                    },
+                                  ),
+                      ],
+                    ),
+                  ),
+                ),
+              ],
+            ),
+          ),
+        ),
+      ),
+    );
+  }
+}
+
+/// Bottom sheet for gift functionality with email and message input
+class _GiftBottomSheet extends StatefulWidget {
+  final String bookTitle;
+  final void Function(String email, String? message) onContinue;
+
+  const _GiftBottomSheet({
+    required this.bookTitle,
+    required this.onContinue,
+  });
+
+  @override
+  State<_GiftBottomSheet> createState() => _GiftBottomSheetState();
+}
+
+class _GiftBottomSheetState extends State<_GiftBottomSheet> {
+  final _emailController = TextEditingController();
+  final _messageController = TextEditingController();
+  bool _isEmailValid = false;
+  bool _showEmailError = false;
+
+  @override
+  void initState() {
+    super.initState();
+    _emailController.addListener(_validateEmail);
+  }
+
+  @override
+  void dispose() {
+    _emailController.dispose();
+    _messageController.dispose();
+    super.dispose();
+  }
+
+  void _validateEmail() {
+    final email = _emailController.text.trim();
+    // Simple email regex for validation
+    final emailRegex = RegExp(r'^[\w\.-]+@[\w\.-]+\.\w{2,}$');
+    final isValid = emailRegex.hasMatch(email);
+    setState(() {
+      _isEmailValid = isValid;
+      // Only show error after user has typed something
+      if (email.isNotEmpty && !isValid) {
+        _showEmailError = true;
+      } else if (isValid) {
+        _showEmailError = false;
+      }
+    });
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    return Directionality(
+      textDirection: TextDirection.rtl,
+      child: Padding(
+        padding: EdgeInsets.only(
+          left: 24,
+          right: 24,
+          top: 24,
+          bottom: MediaQuery.of(context).viewInsets.bottom + 24,
+        ),
+        child: Column(
+          mainAxisSize: MainAxisSize.min,
+          children: [
+            // Handle
+            Container(
+              width: 40,
+              height: 4,
+              decoration: BoxDecoration(
+                color: AppColors.textTertiary,
+                borderRadius: BorderRadius.circular(2),
+              ),
+            ),
+            const SizedBox(height: 24),
+            // Icon
+            const Icon(
+              Icons.card_giftcard,
+              size: 48,
+              color: AppColors.primary,
+            ),
+            const SizedBox(height: 16),
+            // Title
+            Text(
+              'هدیه دادن',
+              style: AppTypography.titleLarge.copyWith(
+                fontWeight: FontWeight.bold,
+              ),
+            ),
+            const SizedBox(height: 8),
+            // Book title
+            Text(
+              widget.bookTitle,
+              style: AppTypography.bodyMedium.copyWith(
+                color: AppColors.textSecondary,
+              ),
+              textAlign: TextAlign.center,
+            ),
+            const SizedBox(height: 24),
+            // Email field
+            TextField(
+              controller: _emailController,
+              keyboardType: TextInputType.emailAddress,
+              textDirection: TextDirection.ltr,
+              textAlign: TextAlign.left,
+              decoration: InputDecoration(
+                labelText: 'ایمیل گیرنده',
+                hintText: 'example@email.com',
+                hintStyle: const TextStyle(color: AppColors.textTertiary),
+                prefixIcon: const Icon(Icons.email_outlined, color: AppColors.textSecondary),
+                errorText: _showEmailError ? 'لطفاً ایمیل معتبر وارد کنید' : null,
+                filled: true,
+                fillColor: AppColors.background,
+                border: OutlineInputBorder(
+                  borderRadius: BorderRadius.circular(12),
+                  borderSide: BorderSide.none,
+                ),
+                enabledBorder: OutlineInputBorder(
+                  borderRadius: BorderRadius.circular(12),
+                  borderSide: BorderSide(color: AppColors.border),
+                ),
+                focusedBorder: OutlineInputBorder(
+                  borderRadius: BorderRadius.circular(12),
+                  borderSide: const BorderSide(color: AppColors.primary, width: 2),
+                ),
+                errorBorder: OutlineInputBorder(
+                  borderRadius: BorderRadius.circular(12),
+                  borderSide: const BorderSide(color: AppColors.error),
+                ),
+                focusedErrorBorder: OutlineInputBorder(
+                  borderRadius: BorderRadius.circular(12),
+                  borderSide: const BorderSide(color: AppColors.error, width: 2),
+                ),
+              ),
+            ),
+            const SizedBox(height: 16),
+            // Message field (optional)
+            TextField(
+              controller: _messageController,
+              maxLines: 3,
+              maxLength: 200,
+              decoration: InputDecoration(
+                labelText: 'پیام (اختیاری)',
+                hintText: 'پیامی برای گیرنده بنویسید...',
+                hintStyle: const TextStyle(color: AppColors.textTertiary),
+                prefixIcon: const Padding(
+                  padding: EdgeInsets.only(bottom: 48),
+                  child: Icon(Icons.message_outlined, color: AppColors.textSecondary),
+                ),
+                filled: true,
+                fillColor: AppColors.background,
+                border: OutlineInputBorder(
+                  borderRadius: BorderRadius.circular(12),
+                  borderSide: BorderSide.none,
+                ),
+                enabledBorder: OutlineInputBorder(
+                  borderRadius: BorderRadius.circular(12),
+                  borderSide: BorderSide(color: AppColors.border),
+                ),
+                focusedBorder: OutlineInputBorder(
+                  borderRadius: BorderRadius.circular(12),
+                  borderSide: const BorderSide(color: AppColors.primary, width: 2),
+                ),
+              ),
+            ),
+            const SizedBox(height: 24),
+            // Buttons
+            Row(
+              children: [
+                Expanded(
+                  child: OutlinedButton(
+                    onPressed: () => Navigator.pop(context),
+                    style: OutlinedButton.styleFrom(
+                      foregroundColor: AppColors.textSecondary,
+                      side: BorderSide(color: AppColors.border),
+                      padding: const EdgeInsets.symmetric(vertical: 14),
+                      shape: RoundedRectangleBorder(
+                        borderRadius: BorderRadius.circular(12),
+                      ),
+                    ),
+                    child: const Text('انصراف'),
+                  ),
+                ),
+                const SizedBox(width: 12),
+                Expanded(
+                  child: ElevatedButton(
+                    onPressed: _isEmailValid
+                        ? () {
+                            widget.onContinue(
+                              _emailController.text.trim(),
+                              _messageController.text.trim().isEmpty
+                                  ? null
+                                  : _messageController.text.trim(),
+                            );
+                          }
+                        : null,
+                    style: ElevatedButton.styleFrom(
+                      backgroundColor: AppColors.primary,
+                      foregroundColor: Colors.white,
+                      disabledBackgroundColor: AppColors.primary.withOpacity(0.3),
+                      disabledForegroundColor: Colors.white.withOpacity(0.5),
+                      padding: const EdgeInsets.symmetric(vertical: 14),
+                      shape: RoundedRectangleBorder(
+                        borderRadius: BorderRadius.circular(12),
+                      ),
+                      elevation: 0,
+                    ),
+                    child: const Text('ادامه'),
+                  ),
+                ),
+              ],
+            ),
+          ],
+        ),
+      ),
+    );
+  }
 }
diff --git a/lib/screens/auth/login_screen.dart b/lib/screens/auth/login_screen.dart
index 4af572f..34a16d5 100644
--- a/lib/screens/auth/login_screen.dart
+++ b/lib/screens/auth/login_screen.dart
@@ -4,6 +4,7 @@ import 'package:supabase_flutter/supabase_flutter.dart';
 import 'package:myna/theme/app_theme.dart';
 import 'package:myna/utils/validators.dart';
 import 'package:myna/screens/auth/signup_screen.dart';
+import 'package:myna/screens/auth/reset_password_screen.dart';
 
 class LoginScreen extends ConsumerStatefulWidget {
   const LoginScreen({super.key});
@@ -75,7 +76,7 @@ class _LoginScreenState extends ConsumerState<LoginScreen> {
                   ),
                   const SizedBox(height: 16),
                   const Text(
-                    'مینا',
+                    'پرستو',
                     textAlign: TextAlign.center,
                     style: TextStyle(
                       fontSize: 32,
@@ -129,7 +130,27 @@ class _LoginScreenState extends ConsumerState<LoginScreen> {
                     ),
                     validator: (value) => Validators.required(value, fieldName: 'رمز عبور'),
                   ),
-                  const SizedBox(height: 24),
+                  const SizedBox(height: 8),
+
+                  // Forgot password link
+                  Align(
+                    alignment: Alignment.centerLeft,
+                    child: TextButton(
+                      onPressed: () {
+                        Navigator.push(
+                          context,
+                          MaterialPageRoute<void>(
+                            builder: (context) => const ResetPasswordScreen(),
+                          ),
+                        );
+                      },
+                      child: const Text(
+                        'فراموشی رمز عبور؟',
+                        style: TextStyle(fontSize: 13),
+                      ),
+                    ),
+                  ),
+                  const SizedBox(height: 16),
 
                   // Error message
                   if (_error != null) ...[
diff --git a/lib/screens/listener/categories_list_screen.dart b/lib/screens/listener/categories_list_screen.dart
index 1937ff1..c7c80c1 100644
--- a/lib/screens/listener/categories_list_screen.dart
+++ b/lib/screens/listener/categories_list_screen.dart
@@ -5,6 +5,23 @@ import 'package:myna/theme/app_theme.dart';
 import 'package:myna/screens/listener/category_screen.dart';
 import 'package:myna/utils/app_logger.dart';
 
+/// =============================================================================
+/// CATEGORY SYSTEM DESIGN (Book Categories)
+/// =============================================================================
+///
+/// This screen displays BOOK categories (دسته‌بندی‌ها) for audiobooks (is_music=false).
+/// Music categories (سبک‌های موسیقی) are handled separately via music_categories table.
+///
+/// COUNT CALCULATION:
+/// - Counts ONLY approved books (status='approved', is_music=false) in each category
+/// - Uses a separate aggregation query for accurate counts
+/// - Does NOT depend on ownership/entitlements - shows total available books
+///
+/// BEHAVIOR:
+/// - Categories with 0 books are still shown (admin may have created them for future)
+/// - Tapping a category shows only approved books in that category
+/// =============================================================================
+
 class CategoriesListScreen extends ConsumerStatefulWidget {
   const CategoriesListScreen({super.key});
 
@@ -24,15 +41,41 @@ class _CategoriesListScreenState extends ConsumerState<CategoriesListScreen> {
 
   Future<void> _loadCategories() async {
     try {
-      final response = await Supabase.instance.client
+      // Step 1: Get all active categories
+      final categoriesResponse = await Supabase.instance.client
           .from('categories')
-          .select('*, audiobooks(count)')
-          .eq('is_active', true as Object)
+          .select('id, name_fa, name_en, icon, sort_order')
+          .eq('is_active', true)
           .order('sort_order');
 
+      final categories = List<Map<String, dynamic>>.from(categoriesResponse);
+
+      // Step 2: Get accurate counts per category
+      // Only count APPROVED BOOKS (status='approved', is_music=false)
+      final countsResponse = await Supabase.instance.client
+          .from('audiobooks')
+          .select('category_id')
+          .eq('status', 'approved')
+          .eq('is_music', false);
+
+      // Aggregate counts by category_id
+      final countMap = <int, int>{};
+      for (final row in countsResponse as List) {
+        final categoryId = row['category_id'] as int?;
+        if (categoryId != null) {
+          countMap[categoryId] = (countMap[categoryId] ?? 0) + 1;
+        }
+      }
+
+      // Step 3: Merge counts into categories
+      for (final category in categories) {
+        final categoryId = category['id'] as int;
+        category['book_count'] = countMap[categoryId] ?? 0;
+      }
+
       if (mounted) {
         setState(() {
-          _categories = List<Map<String, dynamic>>.from(response);
+          _categories = categories;
           _isLoading = false;
         });
       }
@@ -68,9 +111,9 @@ class _CategoriesListScreenState extends ConsumerState<CategoriesListScreen> {
   }
 
   Widget _buildCategoryTile(Map<String, dynamic> category) {
-    final bookCount = category['audiobooks'] is List 
-        ? (category['audiobooks'] as List).length 
-        : 0;
+    // book_count is pre-calculated in _loadCategories() as accurate count
+    // of approved books (status='approved', is_music=false) in this category
+    final bookCount = (category['book_count'] as int?) ?? 0;
 
     return Container(
       margin: const EdgeInsets.only(bottom: 12),
diff --git a/lib/screens/listener/category_screen.dart b/lib/screens/listener/category_screen.dart
index 7370e5b..af351c9 100644
--- a/lib/screens/listener/category_screen.dart
+++ b/lib/screens/listener/category_screen.dart
@@ -7,6 +7,20 @@ import 'package:myna/widgets/error_view.dart';
 import 'package:myna/widgets/skeleton_loaders.dart';
 import 'package:myna/utils/app_logger.dart';
 
+/// =============================================================================
+/// CATEGORY DETAIL SCREEN (Books only)
+/// =============================================================================
+///
+/// Shows audiobooks in a specific BOOK category.
+/// FILTERS:
+/// - status = 'approved' (only approved content)
+/// - is_music = false (only books, not music)
+/// - category_id = widget.categoryId
+///
+/// NOTE: This screen is for book categories. Music categories use a different
+/// system via music_categories table and audiobook_music_categories junction.
+/// =============================================================================
+
 class CategoryScreen extends ConsumerStatefulWidget {
   final int categoryId;
   final String categoryName;
@@ -62,11 +76,14 @@ class _CategoryScreenState extends ConsumerState<CategoryScreen> {
           break;
       }
 
+      // Query audiobooks in this category
+      // Filters: approved status, books only (not music), matching category
       final response = await Supabase.instance.client
           .from('audiobooks')
           .select('*, profiles!audiobooks_narrator_id_fkey(display_name, full_name)')
           .eq('category_id', widget.categoryId as Object)
           .eq('status', 'approved' as Object)
+          .eq('is_music', false) // Only books, not music
           .order(orderColumn, ascending: ascending)
           .limit(50);
 
@@ -174,12 +191,12 @@ class _CategoryScreenState extends ConsumerState<CategoryScreen> {
                     onRetry: _loadAudiobooks,
                   )
                 : _audiobooks.isEmpty
-                    ? Center(
+                    ? const Center(
                         child: Column(
                           mainAxisAlignment: MainAxisAlignment.center,
                           children: [
                             Icon(Icons.library_books_outlined, size: 64, color: AppColors.textTertiary),
-                            const SizedBox(height: 16),
+                            SizedBox(height: 16),
                             Text(
                               'کتابی در این دسته‌بندی یافت نشد',
                               style: TextStyle(color: AppColors.textSecondary, fontSize: 16),
@@ -214,7 +231,7 @@ class _CategoryScreenState extends ConsumerState<CategoryScreen> {
           builder: (_) => AudiobookDetailScreen(audiobookId: book['id'] as int),
         ),
       ),
-      child: Container(
+      child: DecoratedBox(
         decoration: BoxDecoration(
           color: AppColors.surface,
           borderRadius: BorderRadius.circular(12),
@@ -265,11 +282,14 @@ class _CategoryScreenState extends ConsumerState<CategoryScreen> {
                         final author = (book['author_fa'] as String?) ??
                             (book['author_en'] as String?) ??
                             '';
-                        final narrator = book['profiles'] != null
+                        // Check if this book is branded as "پرستو"
+                        final isParastoBrand = (book['is_parasto_brand'] as bool?) ?? false;
+                        final narratorRaw = book['profiles'] != null
                             ? ((book['profiles']['display_name'] as String?) ??
                                 (book['profiles']['full_name'] as String?) ??
                                 '')
                             : '';
+                        final narrator = isParastoBrand ? 'پرستو' : narratorRaw;
                         final displayText = author.isNotEmpty ? author : narrator;
                         if (displayText.isEmpty) return const SizedBox.shrink();
                         return Text(
diff --git a/lib/screens/listener/downloads_screen.dart b/lib/screens/listener/downloads_screen.dart
index 05404d7..5930f55 100644
--- a/lib/screens/listener/downloads_screen.dart
+++ b/lib/screens/listener/downloads_screen.dart
@@ -103,7 +103,7 @@ class _DownloadsScreenState extends ConsumerState<DownloadsScreen> {
             ),
           ),
           const SizedBox(height: 8),
-          Text(
+          const Text(
             'فصل‌های دانلود شده اینجا نمایش داده می‌شوند',
             style: TextStyle(
               color: AppColors.textTertiary,
@@ -184,7 +184,7 @@ class _DownloadsScreenState extends ConsumerState<DownloadsScreen> {
               ),
               Text(
                 '${ref.watch(downloadProvider).totalDownloads} فصل',
-                style: TextStyle(
+                style: const TextStyle(
                   color: AppColors.textTertiary,
                   fontSize: 13,
                 ),
@@ -463,7 +463,7 @@ class _AudiobookDownloadCard extends ConsumerWidget {
                         const SizedBox(height: 6),
                         Row(
                           children: [
-                            Icon(
+                            const Icon(
                               Icons.download_done,
                               size: 14,
                               color: AppColors.success,
@@ -471,13 +471,13 @@ class _AudiobookDownloadCard extends ConsumerWidget {
                             const SizedBox(width: 4),
                             Text(
                               '${chapters.length} فصل',
-                              style: TextStyle(
+                              style: const TextStyle(
                                 color: AppColors.textTertiary,
                                 fontSize: 12,
                               ),
                             ),
                             const SizedBox(width: 12),
-                            Icon(
+                            const Icon(
                               Icons.storage_outlined,
                               size: 14,
                               color: AppColors.textTertiary,
@@ -485,7 +485,7 @@ class _AudiobookDownloadCard extends ConsumerWidget {
                             const SizedBox(width: 4),
                             Text(
                               Formatters.formatFileSize(totalSize),
-                              style: TextStyle(
+                              style: const TextStyle(
                                 color: AppColors.textTertiary,
                                 fontSize: 12,
                               ),
@@ -519,7 +519,7 @@ class _AudiobookDownloadCard extends ConsumerWidget {
 
           // Expanded chapter list
           if (isExpanded) ...[
-            Divider(
+            const Divider(
               height: 1,
               color: AppColors.surfaceLight,
               indent: 12,
@@ -623,7 +623,7 @@ class _ChapterDownloadTile extends ConsumerWidget {
                 const SizedBox(height: 2),
                 Text(
                   Formatters.formatFileSize(chapter.fileSizeBytes),
-                  style: TextStyle(
+                  style: const TextStyle(
                     color: AppColors.textTertiary,
                     fontSize: 11,
                   ),
diff --git a/lib/screens/listener/edit_profile_screen.dart b/lib/screens/listener/edit_profile_screen.dart
index d0e8b7f..2c1ef44 100644
--- a/lib/screens/listener/edit_profile_screen.dart
+++ b/lib/screens/listener/edit_profile_screen.dart
@@ -127,8 +127,14 @@ class _EditProfileScreenState extends ConsumerState<EditProfileScreen> {
 
     try {
       String? finalAvatarUrl = _avatarUrl;
+      String? newAvatarPath; // Track new avatar for cleanup if DB fails
+
       if (_newAvatarBytes != null) {
         finalAvatarUrl = await _uploadAvatar();
+        // Track the path for potential cleanup
+        if (finalAvatarUrl != null) {
+          newAvatarPath = '${user.id}/avatar_${DateTime.now().millisecondsSinceEpoch}.jpg';
+        }
       }
 
       final updateData = <String, dynamic>{
@@ -136,15 +142,26 @@ class _EditProfileScreenState extends ConsumerState<EditProfileScreen> {
         'bio': _bioController.text.trim(),
         'updated_at': DateTime.now().toIso8601String(),
       };
-      
+
       if (finalAvatarUrl != null) {
         updateData['avatar_url'] = finalAvatarUrl;
       }
 
-      await Supabase.instance.client
-          .from('profiles')
-          .update(updateData)
-          .eq('id', user.id as Object);
+      // Update profile - with orphan avatar cleanup on failure
+      try {
+        await Supabase.instance.client
+            .from('profiles')
+            .update(updateData)
+            .eq('id', user.id as Object);
+      } catch (dbError) {
+        // DB update failed - clean up newly uploaded avatar if any
+        if (newAvatarPath != null) {
+          try {
+            await Supabase.instance.client.storage.from('avatars').remove([newAvatarPath]);
+          } catch (_) {}
+        }
+        rethrow;
+      }
 
       if (mounted) {
         ScaffoldMessenger.of(context).showSnackBar(
@@ -243,7 +260,7 @@ class _EditProfileScreenState extends ConsumerState<EditProfileScreen> {
                         ),
                       ),
                       const SizedBox(height: 8),
-                      Text(
+                      const Text(
                         'برای تغییر تصویر ضربه بزنید',
                         style: TextStyle(color: AppColors.textTertiary, fontSize: 12),
                       ),
@@ -309,10 +326,10 @@ class _EditProfileScreenState extends ConsumerState<EditProfileScreen> {
                           prefixIcon: const Icon(Icons.email_outlined),
                           suffixIcon: const Icon(Icons.lock_outline, size: 18),
                         ),
-                        style: TextStyle(color: AppColors.textTertiary),
+                        style: const TextStyle(color: AppColors.textTertiary),
                       ),
                       const SizedBox(height: 8),
-                      Text(
+                      const Text(
                         'ایمیل قابل تغییر نیست',
                         style: TextStyle(color: AppColors.textTertiary, fontSize: 12),
                       ),
diff --git a/lib/screens/listener/home_screen.dart b/lib/screens/listener/home_screen.dart
index f9f627e..fe2b11e 100644
--- a/lib/screens/listener/home_screen.dart
+++ b/lib/screens/listener/home_screen.dart
@@ -1,5 +1,6 @@
 import 'package:flutter/material.dart';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
+import 'package:cached_network_image/cached_network_image.dart';
 import 'package:myna/theme/app_theme.dart';
 import 'package:myna/screens/audiobook_detail_screen.dart';
 import 'package:myna/screens/listener/category_screen.dart';
@@ -11,18 +12,45 @@ import 'package:myna/providers/home_providers.dart';
 import 'package:myna/providers/promotion_providers.dart';
 import 'package:myna/providers/audio_provider.dart';
 
+// ============================================
+// HOME SCREEN UX PLAN (Dec 2024)
+// ============================================
+//
+// CURRENT STRUCTURE (in order):
+// 1. Promo Banners Carousel
+// 2. ادامه گوش دادن (Continue Listening) - most recent incomplete (books ONLY now)
+// 3. اخیراً شنیده شده (Recently Played) - recent items (books ONLY now)
+// 4. پیشنهاد کتاب‌ها (Featured Books) - is_music=false ✓
+// 5. دسته‌بندی‌ها (Categories) - book categories
+// 6. جدیدترین کتاب‌ها (New Books) - is_music=false ✓
+// 7. Promo Shelves (curated collections)
+// 8. پرشنونده‌ترین کتاب‌ها (Popular Books) - is_music=false ✓
+//
+// CHANGES MADE:
+// - Section titles now include "کتاب" for clarity (پیشنهاد کتاب‌ها, جدیدترین کتاب‌ها, etc.)
+// - Continue Listening and Recently Played already filter books via existing providers
+// - Promo Shelves remain mixed (admin curated - can contain books or music)
+//
+// MUSIC UX is handled separately in music_screen.dart
+// ============================================
+
 class HomeScreen extends ConsumerWidget {
   const HomeScreen({super.key});
 
   @override
   Widget build(BuildContext context, WidgetRef ref) {
+    // PERFORMANCE: Priority 1 - Above the fold content (visible immediately)
     final bannersAsync = ref.watch(homeBannersProvider);
-    final shelvesAsync = ref.watch(homeShelvesProvider);
+    final continueListeningAsync = ref.watch(continueListeningProvider);
     final featuredAsync = ref.watch(homeFeaturedProvider);
+
+    // PERFORMANCE: Priority 2 - Visible after slight scroll
+    final categoriesAsync = ref.watch(homeCategoriesProvider);
     final newReleasesAsync = ref.watch(homeNewReleasesProvider);
+
+    // PERFORMANCE: Priority 3 - Below fold content
+    final shelvesAsync = ref.watch(homeShelvesProvider);
     final popularAsync = ref.watch(homePopularProvider);
-    final categoriesAsync = ref.watch(homeCategoriesProvider);
-    final continueListeningAsync = ref.watch(continueListeningProvider);
     final recentlyPlayedAsync = ref.watch(homeRecentlyPlayedProvider);
     final listeningStatsAsync = ref.watch(listeningStatsProvider);
 
@@ -51,13 +79,9 @@ class HomeScreen extends ConsumerWidget {
                 floating: true,
                 backgroundColor: AppColors.background,
                 elevation: 0,
-                title: const Text(
-                  'مینا',
-                  style: TextStyle(
-                    fontSize: 28,
-                    fontWeight: FontWeight.bold,
-                    color: AppColors.textPrimary,
-                  ),
+                title: Text(
+                  'پرستو',
+                  style: AppTypography.heroTitle.copyWith(fontSize: 28),
                 ),
                 centerTitle: false,
                 actions: [
@@ -115,7 +139,22 @@ class HomeScreen extends ConsumerWidget {
                           : _RecentlyPlayedSection(books: books),
                     ),
 
-                    // Featured Section
+                    // New Book Releases (is_music=false) - shown first
+                    newReleasesAsync.when(
+                      loading: () => const _SectionSkeleton(),
+                      error: (e, _) => _SectionError(
+                        message: 'خطا در بارگذاری تازه‌ها',
+                        onRetry: () => ref.invalidate(homeNewReleasesProvider),
+                      ),
+                      data: (books) => books.isEmpty
+                          ? const SizedBox.shrink()
+                          : _AudiobookSection(
+                              title: 'جدیدترین کتاب‌ها',
+                              books: books,
+                            ),
+                    ),
+
+                    // Featured Books Section (is_music=false)
                     featuredAsync.when(
                       loading: () => const _SectionSkeleton(),
                       error: (e, _) => _SectionError(
@@ -125,7 +164,7 @@ class HomeScreen extends ConsumerWidget {
                       data: (books) => books.isEmpty
                           ? const SizedBox.shrink()
                           : _AudiobookSection(
-                              title: 'پیشنهاد شده',
+                              title: 'پیشنهاد کتاب‌ها',
                               books: books,
                             ),
                     ),
@@ -139,21 +178,6 @@ class HomeScreen extends ConsumerWidget {
                           : _CategoriesSection(categories: categories),
                     ),
 
-                    // New Releases
-                    newReleasesAsync.when(
-                      loading: () => const _SectionSkeleton(),
-                      error: (e, _) => _SectionError(
-                        message: 'خطا در بارگذاری تازه‌ها',
-                        onRetry: () => ref.invalidate(homeNewReleasesProvider),
-                      ),
-                      data: (books) => books.isEmpty
-                          ? const SizedBox.shrink()
-                          : _AudiobookSection(
-                              title: 'جدیدترین‌ها',
-                              books: books,
-                            ),
-                    ),
-
                     // Promo Shelves (curated collections)
                     shelvesAsync.when(
                       loading: () => const SizedBox.shrink(),
@@ -165,7 +189,7 @@ class HomeScreen extends ConsumerWidget {
                       ),
                     ),
 
-                    // Popular
+                    // Popular Books (is_music=false)
                     popularAsync.when(
                       loading: () => const _SectionSkeleton(),
                       error: (_, __) => _SectionError(
@@ -175,7 +199,7 @@ class HomeScreen extends ConsumerWidget {
                       data: (books) => books.isEmpty
                           ? const SizedBox.shrink()
                           : _AudiobookSection(
-                              title: 'پرشنونده‌ترین‌ها',
+                              title: 'پرشنونده‌ترین کتاب‌ها',
                               books: books,
                             ),
                     ),
@@ -223,12 +247,7 @@ class _SectionHeader extends StatelessWidget {
               ],
               Text(
                 title,
-                style: const TextStyle(
-                  fontSize: 22,
-                  fontWeight: FontWeight.bold,
-                  color: AppColors.textPrimary,
-                  letterSpacing: -0.5,
-                ),
+                style: AppTypography.sectionTitle,
               ),
             ],
           ),
@@ -239,12 +258,12 @@ class _SectionHeader extends StatelessWidget {
                 foregroundColor: AppColors.primary,
                 padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
               ),
-              child: const Row(
+              child: Row(
                 mainAxisSize: MainAxisSize.min,
                 children: [
-                  Text('مشاهده همه', style: TextStyle(fontSize: 14)),
-                  SizedBox(width: 4),
-                  Icon(Icons.chevron_left, size: 18),
+                  Text('مشاهده همه', style: AppTypography.labelMedium.copyWith(color: AppColors.primary)),
+                  const SizedBox(width: 4),
+                  const Icon(Icons.chevron_left, size: 18),
                 ],
               ),
             ),
@@ -260,23 +279,26 @@ class _SectionHeader extends StatelessWidget {
 
 class _AudiobookCard extends StatelessWidget {
   final Map<String, dynamic> book;
-  final double width;
-  final double coverHeight;
 
   const _AudiobookCard({
+    super.key,
     required this.book,
-    this.width = 140,
-    this.coverHeight = 190,
   });
 
   @override
   Widget build(BuildContext context) {
+    const double cardWidth = 140;
+    const double cardCoverHeight = 190;
     final title = (book['title_fa'] as String?) ?? '';
-    final narrator = book['profiles'] != null
+    // Check if this book is branded as "پرستو"
+    final isParastoBrand = (book['is_parasto_brand'] as bool?) ?? false;
+    final narratorRaw = book['profiles'] != null
         ? ((book['profiles']['display_name'] as String?) ??
             (book['profiles']['full_name'] as String?) ??
             '')
         : '';
+    // Display "پرستو" if is_parasto_brand is true, otherwise show real narrator
+    final narrator = isParastoBrand ? 'پرستو' : narratorRaw;
     // Author: prefer author_fa, fallback to author_en
     final author = (book['author_fa'] as String?) ??
         (book['author_en'] as String?) ??
@@ -295,15 +317,16 @@ class _AudiobookCard extends StatelessWidget {
         );
       },
       child: Container(
-        width: width,
+        width: cardWidth,
         margin: const EdgeInsets.only(left: 12),
         child: Column(
           crossAxisAlignment: CrossAxisAlignment.start,
+          mainAxisSize: MainAxisSize.min,
           children: [
-            // Cover with shadow
+            // Cover with shadow (fixed height)
             Container(
-              height: coverHeight,
-              width: width,
+              height: cardCoverHeight,
+              width: cardWidth,
               decoration: BoxDecoration(
                 borderRadius: BorderRadius.circular(12),
                 boxShadow: [
@@ -317,54 +340,42 @@ class _AudiobookCard extends StatelessWidget {
               child: ClipRRect(
                 borderRadius: BorderRadius.circular(12),
                 child: coverUrl != null
-                    ? Image.network(
-                        coverUrl,
+                    ? CachedNetworkImage(
+                        imageUrl: coverUrl,
                         fit: BoxFit.cover,
-                        errorBuilder: (_, __, ___) => _buildPlaceholder(),
+                        placeholder: (_, __) => _buildPlaceholder(),
+                        errorWidget: (_, __, ___) => _buildPlaceholder(),
                       )
                     : _buildPlaceholder(),
               ),
             ),
-            const SizedBox(height: 12),
+            const SizedBox(height: 10),
 
-            // Title
-            Text(
-              title,
-              style: const TextStyle(
-                color: AppColors.textPrimary,
-                fontWeight: FontWeight.w600,
-                fontSize: 14,
-                height: 1.2,
+            // Title (fixed height container to prevent overflow)
+            SizedBox(
+              height: 36,
+              child: Text(
+                title,
+                style: AppTypography.cardTitle.copyWith(fontSize: 13),
+                maxLines: 2,
+                overflow: TextOverflow.ellipsis,
               ),
-              maxLines: 2,
-              overflow: TextOverflow.ellipsis,
             ),
-            const SizedBox(height: 4),
+            const SizedBox(height: 2),
 
-            // Author (show if exists, otherwise show narrator)
-            if (author.isNotEmpty)
-              Text(
-                author,
-                style: TextStyle(
-                  color: AppColors.textSecondary,
-                  fontSize: 12,
-                ),
-                maxLines: 1,
-                overflow: TextOverflow.ellipsis,
-              )
-            else if (narrator.isNotEmpty)
-              Text(
-                narrator,
-                style: TextStyle(
-                  color: AppColors.textSecondary,
-                  fontSize: 12,
-                ),
+            // Author/Narrator (fixed height, single line)
+            SizedBox(
+              height: 18,
+              child: Text(
+                author.isNotEmpty ? author : narrator,
+                style: AppTypography.cardSubtitle,
                 maxLines: 1,
                 overflow: TextOverflow.ellipsis,
               ),
-            const SizedBox(height: 4),
+            ),
+            const SizedBox(height: 6),
 
-            // Price
+            // Price badge
             Container(
               padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
               decoration: BoxDecoration(
@@ -375,10 +386,8 @@ class _AudiobookCard extends StatelessWidget {
               ),
               child: Text(
                 isFree ? 'رایگان' : _formatPrice(price),
-                style: TextStyle(
+                style: AppTypography.badge.copyWith(
                   color: isFree ? AppColors.success : AppColors.primary,
-                  fontSize: 11,
-                  fontWeight: FontWeight.w600,
                 ),
               ),
             ),
@@ -389,9 +398,9 @@ class _AudiobookCard extends StatelessWidget {
   }
 
   Widget _buildPlaceholder() {
-    return Container(
+    return const ColoredBox(
       color: AppColors.surface,
-      child: const Center(
+      child: Center(
         child: Icon(Icons.headphones, color: AppColors.textTertiary, size: 40),
       ),
     );
@@ -413,14 +422,10 @@ class _AudiobookCard extends StatelessWidget {
 class _AudiobookSection extends StatelessWidget {
   final String title;
   final List<Map<String, dynamic>> books;
-  final VoidCallback? onSeeAll;
-  final IconData? icon;
 
   const _AudiobookSection({
     required this.title,
     required this.books,
-    this.onSeeAll,
-    this.icon,
   });
 
   @override
@@ -428,15 +433,19 @@ class _AudiobookSection extends StatelessWidget {
     return Column(
       crossAxisAlignment: CrossAxisAlignment.start,
       children: [
-        _SectionHeader(title: title, onSeeAll: onSeeAll, icon: icon),
+        _SectionHeader(title: title),
         SizedBox(
-          height: 290,
+          height: 295, // Cover(190) + spacing(10) + title(36) + spacing(2) + author(18) + spacing(6) + badge(~28) + buffer
           child: ListView.builder(
             scrollDirection: Axis.horizontal,
             padding: const EdgeInsets.only(right: 20, left: 8),
             itemCount: books.length,
             itemBuilder: (context, index) {
-              return _AudiobookCard(book: books[index]);
+              final book = books[index];
+              return _AudiobookCard(
+                key: ValueKey(book['id']),
+                book: book,
+              );
             },
           ),
         ),
@@ -481,14 +490,17 @@ class _PromoShelfSection extends StatelessWidget {
           },
         ),
         SizedBox(
-          height: 290,
+          height: 295, // Same as _AudiobookSection
           child: ListView.builder(
             scrollDirection: Axis.horizontal,
             padding: const EdgeInsets.only(right: 20, left: 8),
             itemCount: audiobooks.length,
             itemBuilder: (context, index) {
               final book = audiobooks[index] as Map<String, dynamic>;
-              return _AudiobookCard(book: book);
+              return _AudiobookCard(
+                key: ValueKey(book['id']),
+                book: book,
+              );
             },
           ),
         ),
@@ -528,7 +540,10 @@ class _CategoriesSection extends StatelessWidget {
             itemCount: categories.length,
             itemBuilder: (context, index) {
               final cat = categories[index];
-              return _CategoryChip(category: cat);
+              return _CategoryChip(
+                key: ValueKey(cat['id']),
+                category: cat,
+              );
             },
           ),
         ),
@@ -540,7 +555,7 @@ class _CategoriesSection extends StatelessWidget {
 class _CategoryChip extends StatelessWidget {
   final Map<String, dynamic> category;
 
-  const _CategoryChip({required this.category});
+  const _CategoryChip({super.key, required this.category});
 
   @override
   Widget build(BuildContext context) {
@@ -566,11 +581,7 @@ class _CategoryChip extends StatelessWidget {
             padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
             child: Text(
               (category['name_fa'] as String?) ?? '',
-              style: const TextStyle(
-                color: AppColors.textPrimary,
-                fontSize: 14,
-                fontWeight: FontWeight.w500,
-              ),
+              style: AppTypography.chip,
             ),
           ),
         ),
@@ -680,12 +691,20 @@ class _PromoBannerCarouselState extends State<_PromoBannerCarousel> {
                       fit: StackFit.expand,
                       children: [
                         // Background Image
-                        Image.network(
-                          banner['image_url'] as String,
+                        CachedNetworkImage(
+                          imageUrl: banner['image_url'] as String,
                           fit: BoxFit.cover,
-                          errorBuilder: (_, __, ___) => Container(
+                          width: double.infinity,
+                          height: double.infinity,
+                          placeholder: (_, __) => const ColoredBox(
+                            color: AppColors.surface,
+                            child: Center(
+                              child: CircularProgressIndicator(strokeWidth: 2),
+                            ),
+                          ),
+                          errorWidget: (_, __, ___) => const ColoredBox(
                             color: AppColors.primary,
-                            child: const Center(
+                            child: Center(
                               child: Icon(Icons.campaign, size: 48, color: Colors.white),
                             ),
                           ),
@@ -714,17 +733,7 @@ class _PromoBannerCarouselState extends State<_PromoBannerCarousel> {
                             children: [
                               Text(
                                 (banner['title_fa'] as String?) ?? '',
-                                style: const TextStyle(
-                                  color: Colors.white,
-                                  fontWeight: FontWeight.bold,
-                                  fontSize: 20,
-                                  shadows: [
-                                    Shadow(
-                                      color: Colors.black54,
-                                      blurRadius: 8,
-                                    ),
-                                  ],
-                                ),
+                                style: AppTypography.bannerTitle,
                                 maxLines: 1,
                                 overflow: TextOverflow.ellipsis,
                               ),
@@ -733,9 +742,8 @@ class _PromoBannerCarouselState extends State<_PromoBannerCarousel> {
                                 const SizedBox(height: 4),
                                 Text(
                                   banner['subtitle_fa'] as String,
-                                  style: TextStyle(
+                                  style: AppTypography.bannerSubtitle.copyWith(
                                     color: Colors.white.withOpacity(0.9),
-                                    fontSize: 14,
                                   ),
                                   maxLines: 1,
                                   overflow: TextOverflow.ellipsis,
@@ -934,7 +942,7 @@ class _SectionError extends StatelessWidget {
             Expanded(
               child: Text(
                 message,
-                style: TextStyle(color: AppColors.textSecondary),
+                style: AppTypography.bodyMedium,
               ),
             ),
             TextButton(
@@ -974,7 +982,10 @@ class _RecentlyPlayedSection extends StatelessWidget {
             itemCount: books.length,
             itemBuilder: (context, index) {
               final book = books[index];
-              return _RecentlyPlayedCard(book: book);
+              return _RecentlyPlayedCard(
+                key: ValueKey(book['id']),
+                book: book,
+              );
             },
           ),
         ),
@@ -986,7 +997,7 @@ class _RecentlyPlayedSection extends StatelessWidget {
 class _RecentlyPlayedCard extends StatelessWidget {
   final Map<String, dynamic> book;
 
-  const _RecentlyPlayedCard({required this.book});
+  const _RecentlyPlayedCard({super.key, required this.book});
 
   @override
   Widget build(BuildContext context) {
@@ -994,9 +1005,12 @@ class _RecentlyPlayedCard extends StatelessWidget {
     final coverUrl = book['cover_url'] as String?;
     final progress = book['progress'] as Map<String, dynamic>?;
     final completionPercentage = (progress?['completion_percentage'] as num?)?.toInt() ?? 0;
-    final narrator = (book['profiles']?['display_name'] as String?) ??
+    // Check if this book is branded as "پرستو"
+    final isParastoBrand = (book['is_parasto_brand'] as bool?) ?? false;
+    final narratorRaw = (book['profiles']?['display_name'] as String?) ??
         (book['profiles']?['full_name'] as String?) ??
         '';
+    final narrator = isParastoBrand ? 'پرستو' : narratorRaw;
 
     return GestureDetector(
       onTap: () {
@@ -1026,17 +1040,21 @@ class _RecentlyPlayedCard extends StatelessWidget {
                 width: 90,
                 height: 120,
                 child: coverUrl != null
-                    ? Image.network(
-                        coverUrl,
+                    ? CachedNetworkImage(
+                        imageUrl: coverUrl,
                         fit: BoxFit.cover,
-                        errorBuilder: (_, __, ___) => Container(
+                        placeholder: (_, __) => const ColoredBox(
                           color: AppColors.surfaceLight,
-                          child: const Icon(Icons.headphones, size: 32, color: AppColors.textTertiary),
+                          child: Icon(Icons.headphones, size: 32, color: AppColors.textTertiary),
+                        ),
+                        errorWidget: (_, __, ___) => const ColoredBox(
+                          color: AppColors.surfaceLight,
+                          child: Icon(Icons.headphones, size: 32, color: AppColors.textTertiary),
                         ),
                       )
-                    : Container(
+                    : const ColoredBox(
                         color: AppColors.surfaceLight,
-                        child: const Icon(Icons.headphones, size: 32, color: AppColors.textTertiary),
+                        child: Icon(Icons.headphones, size: 32, color: AppColors.textTertiary),
                       ),
               ),
             ),
@@ -1050,11 +1068,7 @@ class _RecentlyPlayedCard extends StatelessWidget {
                   children: [
                     Text(
                       title,
-                      style: const TextStyle(
-                        fontSize: 14,
-                        fontWeight: FontWeight.bold,
-                        color: AppColors.textPrimary,
-                      ),
+                      style: AppTypography.cardTitle,
                       maxLines: 2,
                       overflow: TextOverflow.ellipsis,
                     ),
@@ -1062,10 +1076,7 @@ class _RecentlyPlayedCard extends StatelessWidget {
                       const SizedBox(height: 4),
                       Text(
                         narrator,
-                        style: TextStyle(
-                          fontSize: 12,
-                          color: AppColors.textSecondary,
-                        ),
+                        style: AppTypography.cardSubtitle,
                         maxLines: 1,
                         overflow: TextOverflow.ellipsis,
                       ),
@@ -1088,11 +1099,7 @@ class _RecentlyPlayedCard extends StatelessWidget {
                         const SizedBox(width: 8),
                         Text(
                           '$completionPercentage%',
-                          style: TextStyle(
-                            fontSize: 11,
-                            fontWeight: FontWeight.w600,
-                            color: AppColors.primary,
-                          ),
+                          style: AppTypography.progressText,
                         ),
                       ],
                     ),
@@ -1143,19 +1150,31 @@ class _ContinueListeningCard extends ConsumerWidget {
             ?.map((c) => Map<String, dynamic>.from(c as Map))
             .toList() ??
         [];
-    final completionPercentage = (progress?['completion_percentage'] as num?)?.toInt() ?? 0;
+    final chapterCompletionPercentage = (progress?['completion_percentage'] as num?)?.toInt() ?? 0;
     final currentChapterIndex = (progress?['current_chapter_index'] as num?)?.toInt() ?? 0;
     final positionSeconds = (progress?['position_seconds'] as num?)?.toInt() ?? 0;
-    final narrator = (book['profiles']?['display_name'] as String?) ??
+
+    // Calculate overall book percentage if chapters have durations, else fallback to chapter percentage
+    final completionPercentage = _calculateOverallBookPercentage(
+      chapters,
+      currentChapterIndex,
+      positionSeconds,
+      chapterCompletionPercentage,
+    );
+
+    // Check if this book is branded as "پرستو"
+    final isParastoBrand = (book['is_parasto_brand'] as bool?) ?? false;
+    final narratorRaw = (book['profiles']?['display_name'] as String?) ??
         (book['profiles']?['full_name'] as String?) ??
         '';
+    final narrator = isParastoBrand ? 'پرستو' : narratorRaw;
 
     // Calculate time remaining
     final timeRemaining = _calculateTimeRemaining(chapters, currentChapterIndex, positionSeconds);
 
     return Padding(
       padding: const EdgeInsets.fromLTRB(20, 24, 20, 8),
-      child: Container(
+      child: DecoratedBox(
         decoration: BoxDecoration(
           gradient: LinearGradient(
             begin: Alignment.topRight,
@@ -1185,163 +1204,152 @@ class _ContinueListeningCard extends ConsumerWidget {
             borderRadius: BorderRadius.circular(20),
             child: Padding(
               padding: const EdgeInsets.all(16),
-              child: Row(
-                crossAxisAlignment: CrossAxisAlignment.start,
-                children: [
-                  // Cover image (larger, prominent)
-                  Container(
-                    width: 100,
-                    height: 140,
-                    decoration: BoxDecoration(
-                      borderRadius: BorderRadius.circular(12),
-                      boxShadow: [
-                        BoxShadow(
-                          color: Colors.black.withOpacity(0.3),
-                          blurRadius: 12,
-                          offset: const Offset(0, 6),
+              child: IntrinsicHeight(
+                child: Row(
+                  crossAxisAlignment: CrossAxisAlignment.stretch,
+                  children: [
+                    // Cover image - uses AspectRatio to maintain 5:7 ratio and stretch to row height
+                    AspectRatio(
+                      aspectRatio: 5 / 7,
+                      child: Container(
+                        constraints: const BoxConstraints(maxWidth: 100),
+                        decoration: BoxDecoration(
+                          borderRadius: BorderRadius.circular(12),
+                          boxShadow: [
+                            BoxShadow(
+                              color: Colors.black.withOpacity(0.3),
+                              blurRadius: 12,
+                              offset: const Offset(0, 6),
+                            ),
+                          ],
                         ),
-                      ],
-                    ),
-                    child: ClipRRect(
-                      borderRadius: BorderRadius.circular(12),
-                      child: coverUrl != null
-                          ? Image.network(
-                              coverUrl,
-                              fit: BoxFit.cover,
-                              errorBuilder: (_, __, ___) => _buildCoverPlaceholder(),
-                            )
-                          : _buildCoverPlaceholder(),
+                        child: ClipRRect(
+                          borderRadius: BorderRadius.circular(12),
+                          child: coverUrl != null
+                              ? CachedNetworkImage(
+                                  imageUrl: coverUrl,
+                                  fit: BoxFit.cover,
+                                  placeholder: (_, __) => _buildCoverPlaceholder(),
+                                  errorWidget: (_, __, ___) => _buildCoverPlaceholder(),
+                                )
+                              : _buildCoverPlaceholder(),
+                        ),
+                      ),
                     ),
-                  ),
-                  const SizedBox(width: 16),
-
-                  // Book info and controls
-                  Expanded(
-                    child: Column(
-                      crossAxisAlignment: CrossAxisAlignment.start,
-                      children: [
-                        // Section label
-                        Row(
-                          children: [
-                            Icon(
-                              Icons.play_circle_outline,
-                              size: 16,
-                              color: AppColors.primary,
-                            ),
-                            const SizedBox(width: 4),
-                            Text(
-                              'ادامه گوش دادن',
-                              style: TextStyle(
-                                fontSize: 12,
-                                fontWeight: FontWeight.w600,
+                    const SizedBox(width: 16),
+
+                    // Book info and controls
+                    Expanded(
+                      child: Column(
+                        crossAxisAlignment: CrossAxisAlignment.start,
+                        mainAxisSize: MainAxisSize.min,
+                        children: [
+                          // Section label
+                          Row(
+                            children: [
+                              const Icon(
+                                Icons.play_circle_outline,
+                                size: 16,
                                 color: AppColors.primary,
                               ),
-                            ),
-                          ],
-                        ),
-                        const SizedBox(height: 8),
-
-                        // Title
-                        Text(
-                          title,
-                          style: const TextStyle(
-                            fontSize: 18,
-                            fontWeight: FontWeight.bold,
-                            color: AppColors.textPrimary,
-                            height: 1.2,
+                              const SizedBox(width: 4),
+                              Text(
+                                'ادامه گوش دادن',
+                                style: AppTypography.labelMedium.copyWith(
+                                  color: AppColors.primary,
+                                  fontWeight: FontWeight.w600,
+                                ),
+                              ),
+                            ],
                           ),
-                          maxLines: 2,
-                          overflow: TextOverflow.ellipsis,
-                        ),
-                        const SizedBox(height: 4),
+                          const SizedBox(height: 8),
 
-                        // Narrator
-                        if (narrator.isNotEmpty)
+                          // Title
                           Text(
-                            narrator,
-                            style: TextStyle(
-                              fontSize: 13,
-                              color: AppColors.textSecondary,
-                            ),
-                            maxLines: 1,
+                            title,
+                            style: AppTypography.headlineSmall,
+                            maxLines: 2,
                             overflow: TextOverflow.ellipsis,
                           ),
-                        const SizedBox(height: 12),
-
-                        // Progress bar
-                        ClipRRect(
-                          borderRadius: BorderRadius.circular(4),
-                          child: LinearProgressIndicator(
-                            value: completionPercentage / 100,
-                            backgroundColor: AppColors.surfaceLight,
-                            valueColor: const AlwaysStoppedAnimation<Color>(AppColors.primary),
-                            minHeight: 6,
-                          ),
-                        ),
-                        const SizedBox(height: 8),
+                          const SizedBox(height: 4),
 
-                        // Progress info row
-                        Row(
-                          children: [
+                          // Narrator
+                          if (narrator.isNotEmpty)
                             Text(
-                              '$completionPercentage% تکمیل شده',
-                              style: TextStyle(
-                                fontSize: 12,
-                                color: AppColors.textTertiary,
-                                fontWeight: FontWeight.w500,
-                              ),
+                              narrator,
+                              style: AppTypography.bodySmall,
+                              maxLines: 1,
+                              overflow: TextOverflow.ellipsis,
                             ),
-                            if (timeRemaining.isNotEmpty) ...[
-                              Text(
-                                '  •  ',
-                                style: TextStyle(
-                                  fontSize: 12,
-                                  color: AppColors.textTertiary,
+                          const Spacer(),
+
+                          // Progress bar
+                          ClipRRect(
+                            borderRadius: BorderRadius.circular(4),
+                            child: LinearProgressIndicator(
+                              value: completionPercentage / 100,
+                              backgroundColor: AppColors.surfaceLight,
+                              valueColor: const AlwaysStoppedAnimation<Color>(AppColors.primary),
+                              minHeight: 6,
+                            ),
+                          ),
+                          const SizedBox(height: 8),
+
+                          // Progress info row - use Flexible to handle overflow
+                          Row(
+                            children: [
+                              Flexible(
+                                child: Text(
+                                  '$completionPercentage% تکمیل شده',
+                                  style: AppTypography.meta,
+                                  overflow: TextOverflow.ellipsis,
                                 ),
                               ),
-                              Text(
-                                '$timeRemaining باقی‌مانده',
-                                style: TextStyle(
-                                  fontSize: 12,
-                                  color: AppColors.textTertiary,
-                                  fontWeight: FontWeight.w500,
+                              if (timeRemaining.isNotEmpty) ...[
+                                Text(
+                                  '  •  ',
+                                  style: AppTypography.meta,
                                 ),
-                              ),
+                                Flexible(
+                                  child: Text(
+                                    '$timeRemaining باقی‌مانده',
+                                    style: AppTypography.meta,
+                                    overflow: TextOverflow.ellipsis,
+                                  ),
+                                ),
+                              ],
                             ],
-                          ],
-                        ),
-                        const SizedBox(height: 12),
-
-                        // Continue button
-                        SizedBox(
-                          width: double.infinity,
-                          child: ElevatedButton.icon(
-                            onPressed: chapters.isEmpty
-                                ? null
-                                : () => _startPlayback(context, ref, chapters, currentChapterIndex, positionSeconds),
-                            style: ElevatedButton.styleFrom(
-                              backgroundColor: AppColors.primary,
-                              foregroundColor: Colors.white,
-                              padding: const EdgeInsets.symmetric(vertical: 12),
-                              shape: RoundedRectangleBorder(
-                                borderRadius: BorderRadius.circular(12),
+                          ),
+                          const SizedBox(height: 12),
+
+                          // Continue button
+                          SizedBox(
+                            width: double.infinity,
+                            child: ElevatedButton.icon(
+                              onPressed: chapters.isEmpty
+                                  ? null
+                                  : () => _startPlayback(context, ref, chapters, currentChapterIndex, positionSeconds),
+                              style: ElevatedButton.styleFrom(
+                                backgroundColor: AppColors.primary,
+                                foregroundColor: Colors.white,
+                                padding: const EdgeInsets.symmetric(vertical: 12),
+                                shape: RoundedRectangleBorder(
+                                  borderRadius: BorderRadius.circular(12),
+                                ),
+                                elevation: 0,
                               ),
-                              elevation: 0,
-                            ),
-                            icon: const Icon(Icons.play_arrow_rounded, size: 22),
-                            label: const Text(
-                              'ادامه',
-                              style: TextStyle(
-                                fontSize: 15,
-                                fontWeight: FontWeight.w600,
+                              icon: const Icon(Icons.play_arrow_rounded, size: 22),
+                              label: Text(
+                                'ادامه',
+                                style: AppTypography.button,
                               ),
                             ),
                           ),
-                        ),
-                      ],
+                        ],
+                      ),
                     ),
-                  ),
-                ],
+                  ],
+                ),
               ),
             ),
           ),
@@ -1351,9 +1359,9 @@ class _ContinueListeningCard extends ConsumerWidget {
   }
 
   Widget _buildCoverPlaceholder() {
-    return Container(
+    return const ColoredBox(
       color: AppColors.surfaceLight,
-      child: const Center(
+      child: Center(
         child: Icon(Icons.headphones, size: 40, color: AppColors.textTertiary),
       ),
     );
@@ -1389,6 +1397,41 @@ class _ContinueListeningCard extends ConsumerWidget {
     return '$minutes دقیقه';
   }
 
+  /// Calculate overall book progress percentage based on chapter durations.
+  /// Returns [fallbackPercentage] if chapters list is empty or lacks duration data.
+  int _calculateOverallBookPercentage(
+    List<Map<String, dynamic>> chapters,
+    int currentChapterIndex,
+    int positionSeconds,
+    int fallbackPercentage,
+  ) {
+    if (chapters.isEmpty) return fallbackPercentage;
+
+    // Sum all chapter durations and check if we have valid duration data
+    int totalSeconds = 0;
+    bool hasDurations = false;
+
+    for (final chapter in chapters) {
+      final duration = (chapter['duration_seconds'] as num?)?.toInt() ?? 0;
+      if (duration > 0) hasDurations = true;
+      totalSeconds += duration;
+    }
+
+    // If no valid durations or total is 0, fallback to chapter percentage
+    if (!hasDurations || totalSeconds <= 0) return fallbackPercentage;
+
+    // Calculate completed seconds: sum of all chapters before current + position in current
+    int completedSeconds = 0;
+    for (int i = 0; i < currentChapterIndex && i < chapters.length; i++) {
+      completedSeconds += (chapters[i]['duration_seconds'] as num?)?.toInt() ?? 0;
+    }
+    completedSeconds += positionSeconds;
+
+    // Calculate percentage and clamp to 0-100
+    final percentage = (100 * completedSeconds / totalSeconds).round();
+    return percentage.clamp(0, 100);
+  }
+
   void _startPlayback(
     BuildContext context,
     WidgetRef ref,
@@ -1444,7 +1487,7 @@ class _StreakBadge extends StatelessWidget {
         child: Row(
           mainAxisSize: MainAxisSize.min,
           children: [
-            Icon(
+            const Icon(
               Icons.local_fire_department,
               size: 18,
               color: AppColors.warning,
@@ -1452,9 +1495,7 @@ class _StreakBadge extends StatelessWidget {
             const SizedBox(width: 4),
             Text(
               '$streak',
-              style: const TextStyle(
-                fontSize: 14,
-                fontWeight: FontWeight.bold,
+              style: AppTypography.labelLarge.copyWith(
                 color: AppColors.warning,
               ),
             ),
diff --git a/lib/screens/listener/library_screen.dart b/lib/screens/listener/library_screen.dart
index b948037..6e3193d 100644
--- a/lib/screens/listener/library_screen.dart
+++ b/lib/screens/listener/library_screen.dart
@@ -1,150 +1,313 @@
 import 'package:flutter/material.dart';
 import 'package:flutter/foundation.dart' show kIsWeb;
 import 'package:flutter_riverpod/flutter_riverpod.dart';
+import 'package:cached_network_image/cached_network_image.dart';
 import 'package:supabase_flutter/supabase_flutter.dart';
 import 'package:myna/theme/app_theme.dart';
 import 'package:myna/screens/audiobook_detail_screen.dart';
+import 'package:myna/screens/library/playlist_detail_screen.dart';
 import 'package:myna/providers/audio_provider.dart';
 import 'package:myna/providers/download_provider.dart';
 import 'package:myna/screens/player/player_screen.dart';
 import 'package:myna/widgets/skeleton_loaders.dart';
+import 'package:myna/services/playlist_service.dart';
 import 'package:myna/utils/app_logger.dart';
+import 'package:myna/utils/farsi_utils.dart';
 
-/// Owned books with their progress
-final ownedBooksWithProgressProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
+/// Provider family for owned items with progress, filtered by is_music
+final ownedItemsWithProgressProvider = FutureProvider.family<List<Map<String, dynamic>>, bool>((ref, isMusic) async {
   final user = Supabase.instance.client.auth.currentUser;
   if (user == null) {
     AppLogger.d('Library: No user logged in');
     return [];
   }
 
-  AppLogger.d('Library: Fetching owned books for user ${user.id}');
+  try {
+    AppLogger.d('Library: Step 1 - Fetching entitlements for user ${user.id.substring(0, 8)}...');
 
-  // Get owned audiobook IDs first
-  final entitlements = await Supabase.instance.client
-      .from('entitlements')
-      .select('audiobook_id')
-      .eq('user_id', user.id as Object);
+    // Step 1: Get entitlements (includes source for debugging)
+    List<dynamic> entitlements;
+    try {
+      entitlements = await Supabase.instance.client
+          .from('entitlements')
+          .select('audiobook_id, source')
+          .eq('user_id', user.id);
+      // Log entitlement sources for debugging
+      final sources = entitlements.map((e) => '${e['audiobook_id']}(${e['source']})').join(', ');
+      AppLogger.d('Library: Step 1 SUCCESS - Got ${entitlements.length} entitlements: $sources');
+    } on PostgrestException catch (e) {
+      AppLogger.e('Library: Step 1 FAILED (entitlements) - Code: ${e.code}, Message: ${e.message}');
+      rethrow;
+    }
 
-  final audiobookIds = (entitlements as List)
-      .map((e) => e['audiobook_id'] as int)
-      .toList();
+    final audiobookIds = entitlements
+        .map((e) => e['audiobook_id'] as int)
+        .toList();
 
-  AppLogger.d('Library: Found ${audiobookIds.length} entitlements: $audiobookIds');
+    if (audiobookIds.isEmpty) {
+      AppLogger.d('Library: No audiobook IDs found');
+      return [];
+    }
 
-  if (audiobookIds.isEmpty) return [];
+    AppLogger.d('Library: Step 2 - Fetching audiobooks for IDs: $audiobookIds');
 
-  // Get audiobook details with narrator profile
-  final audiobooksResponse = await Supabase.instance.client
-      .from('audiobooks')
-      .select('*, profiles!audiobooks_narrator_id_fkey(display_name, full_name)')
-      .inFilter('id', audiobookIds);
+    // Step 2: Get audiobook details (WITHOUT the profiles join to test)
+    List<dynamic> audiobooksResponse;
+    try {
+      audiobooksResponse = await Supabase.instance.client
+          .from('audiobooks')
+          .select('*')
+          .inFilter('id', audiobookIds)
+          .eq('is_music', isMusic);
+      AppLogger.d('Library: Step 2 SUCCESS - Got ${audiobooksResponse.length} audiobooks');
+    } on PostgrestException catch (e) {
+      AppLogger.e('Library: Step 2 FAILED (audiobooks) - Code: ${e.code}, Message: ${e.message}');
+      rethrow;
+    }
 
-  final books = List<Map<String, dynamic>>.from(audiobooksResponse as List);
-  AppLogger.d('Library: Fetched ${books.length} audiobook details');
+    final items = List<Map<String, dynamic>>.from(audiobooksResponse);
 
-  // Get chapters for all owned books
-  final chaptersResponse = await Supabase.instance.client
-      .from('chapters')
-      .select('id, title_fa, audio_url, audio_storage_path, duration_seconds, chapter_index, is_preview, audiobook_id')
-      .inFilter('audiobook_id', audiobookIds)
-      .order('chapter_index', ascending: true);
+    if (items.isEmpty) return [];
 
-  // Group chapters by audiobook_id
-  final chaptersMap = <int, List<Map<String, dynamic>>>{};
-  for (final chapter in chaptersResponse as List) {
-    final audiobookId = chapter['audiobook_id'] as int;
-    chaptersMap.putIfAbsent(audiobookId, () => []);
-    chaptersMap[audiobookId]!.add(Map<String, dynamic>.from(chapter as Map));
-  }
+    // Get item IDs for further queries
+    final itemIds = items.map((i) => i['id'] as int).toList();
 
-  // Get progress for all owned books
-  final progressResponse = await Supabase.instance.client
-      .from('listening_progress')
-      .select('*')
-      .eq('user_id', user.id as Object);
+    AppLogger.d('Library: Step 3 - Fetching chapters for ${itemIds.length} audiobooks');
 
-  final progressMap = <int, Map<String, dynamic>>{};
-  for (final p in progressResponse as List) {
-    final audiobookId = p['audiobook_id'] as int;
-    progressMap[audiobookId] = p as Map<String, dynamic>;
-  }
+    // Step 3: Get chapters for owned items
+    List<dynamic> chaptersResponse;
+    try {
+      chaptersResponse = await Supabase.instance.client
+          .from('chapters')
+          .select('id, title_fa, audio_storage_path, duration_seconds, chapter_index, is_preview, audiobook_id')
+          .inFilter('audiobook_id', itemIds)
+          .order('chapter_index', ascending: true);
+      AppLogger.d('Library: Step 3 SUCCESS - Got ${chaptersResponse.length} chapters');
+    } on PostgrestException catch (e) {
+      AppLogger.e('Library: Step 3 FAILED (chapters) - Code: ${e.code}, Message: ${e.message}');
+      rethrow;
+    }
 
-  // Merge chapters and progress into books
-  for (final book in books) {
-    final bookId = book['id'] as int;
-    book['chapters'] = chaptersMap[bookId] ?? [];
-    book['progress'] = progressMap[bookId];
-  }
+    // Group chapters by audiobook_id
+    final chaptersMap = <int, List<Map<String, dynamic>>>{};
+    for (final chapter in chaptersResponse) {
+      final audiobookId = chapter['audiobook_id'] as int;
+      chaptersMap.putIfAbsent(audiobookId, () => []);
+      chaptersMap[audiobookId]!.add(Map<String, dynamic>.from(chapter as Map));
+    }
 
-  // Sort: in-progress books first, then recently played
-  books.sort((a, b) {
-    final aProgress = a['progress'] as Map<String, dynamic>?;
-    final bProgress = b['progress'] as Map<String, dynamic>?;
-
-    // Books with progress come first
-    if (aProgress != null && bProgress == null) return -1;
-    if (aProgress == null && bProgress != null) return 1;
-
-    // Among books with progress, sort by last_played_at
-    if (aProgress != null && bProgress != null) {
-      final aLastPlayed = aProgress['last_played_at'] as String?;
-      final bLastPlayed = bProgress['last_played_at'] as String?;
-      if (aLastPlayed != null && bLastPlayed != null) {
-        return bLastPlayed.compareTo(aLastPlayed); // Most recent first
-      }
+    AppLogger.d('Library: Step 4 - Fetching progress');
+
+    // Step 4: Get progress for owned items
+    List<dynamic> progressResponse;
+    try {
+      progressResponse = await Supabase.instance.client
+          .from('listening_progress')
+          .select('*')
+          .eq('user_id', user.id)
+          .inFilter('audiobook_id', itemIds);
+      AppLogger.d('Library: Step 4 SUCCESS - Got ${progressResponse.length} progress records');
+    } on PostgrestException catch (e) {
+      AppLogger.e('Library: Step 4 FAILED (listening_progress) - Code: ${e.code}, Message: ${e.message}');
+      rethrow;
+    }
+
+    final progressMap = <int, Map<String, dynamic>>{};
+    for (final p in progressResponse) {
+      final audiobookId = p['audiobook_id'] as int;
+      progressMap[audiobookId] = p as Map<String, dynamic>;
+    }
+
+    // Merge chapters and progress into items
+    for (final item in items) {
+      final itemId = item['id'] as int;
+      item['chapters'] = chaptersMap[itemId] ?? [];
+      item['progress'] = progressMap[itemId];
     }
 
-    return 0;
-  });
+    // Sort: in-progress items first, then recently played
+    items.sort((a, b) {
+      final aProgress = a['progress'] as Map<String, dynamic>?;
+      final bProgress = b['progress'] as Map<String, dynamic>?;
+
+      // Items with progress come first
+      if (aProgress != null && bProgress == null) return -1;
+      if (aProgress == null && bProgress != null) return 1;
+
+      // Among items with progress, sort by last_played_at
+      if (aProgress != null && bProgress != null) {
+        final aLastPlayed = aProgress['last_played_at'] as String?;
+        final bLastPlayed = bProgress['last_played_at'] as String?;
+        if (aLastPlayed != null && bLastPlayed != null) {
+          return bLastPlayed.compareTo(aLastPlayed); // Most recent first
+        }
+      }
+
+      return 0;
+    });
 
-  return books;
+    AppLogger.d('Library: ALL STEPS SUCCESS - Returning ${items.length} items');
+    return items;
+  } on PostgrestException catch (e) {
+    AppLogger.e('Library: PostgrestException - Code: ${e.code}, Message: ${e.message}, Details: ${e.details}');
+    rethrow;
+  } catch (e, stackTrace) {
+    AppLogger.e('Library: Error fetching library', error: e);
+    AppLogger.e('Library: Stack trace: $stackTrace');
+    rethrow;
+  }
 });
 
-final wishlistBooksProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
+/// Provider family for wishlist items, filtered by is_music
+final wishlistItemsProvider = FutureProvider.family<List<Map<String, dynamic>>, bool>((ref, isMusic) async {
   final user = Supabase.instance.client.auth.currentUser;
   if (user == null) return [];
 
   final response = await Supabase.instance.client
       .from('user_wishlist')
-      .select('audiobook_id, audiobooks(*, profiles!audiobooks_narrator_id_fkey(display_name, full_name))')
-      .eq('user_id', user.id as Object);
+      .select('audiobook_id, audiobooks!inner(*, profiles!audiobooks_narrator_id_fkey(display_name, full_name))')
+      .eq('user_id', user.id)
+      .eq('audiobooks.is_music', isMusic);
 
   return (response as List)
       .map((e) => e['audiobooks'] as Map<String, dynamic>)
       .toList();
 });
 
-class LibraryScreen extends ConsumerWidget {
+/// Legacy providers for backwards compatibility
+final ownedBooksWithProgressProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
+  return ref.watch(ownedItemsWithProgressProvider(false).future);
+});
+
+final wishlistBooksProvider = FutureProvider<List<Map<String, dynamic>>>((ref) async {
+  return ref.watch(wishlistItemsProvider(false).future);
+});
+
+class LibraryScreen extends ConsumerStatefulWidget {
   const LibraryScreen({super.key});
 
   @override
-  Widget build(BuildContext context, WidgetRef ref) {
-    return DefaultTabController(
-      length: 2,
-      child: Directionality(
-        textDirection: TextDirection.rtl,
-        child: Scaffold(
+  ConsumerState<LibraryScreen> createState() => _LibraryScreenState();
+}
+
+class _LibraryScreenState extends ConsumerState<LibraryScreen> with SingleTickerProviderStateMixin {
+  // 0 = Books, 1 = Music
+  int _selectedContentType = 0;
+  late TabController _tabController;
+
+  @override
+  void initState() {
+    super.initState();
+    _tabController = TabController(length: 3, vsync: this);
+  }
+
+  @override
+  void dispose() {
+    _tabController.dispose();
+    super.dispose();
+  }
+
+  bool get _isMusic => _selectedContentType == 1;
+
+  @override
+  Widget build(BuildContext context) {
+    return Directionality(
+      textDirection: TextDirection.rtl,
+      child: Scaffold(
+        backgroundColor: AppColors.background,
+        appBar: AppBar(
           backgroundColor: AppColors.background,
-          appBar: AppBar(
-            backgroundColor: AppColors.background,
-            title: const Text('کتابخانه'),
-            centerTitle: true,
-            bottom: const TabBar(
-              indicatorColor: AppColors.primary,
-              labelColor: AppColors.primary,
-              unselectedLabelColor: AppColors.textTertiary,
-              tabs: [
-                Tab(text: 'کتاب‌های من'),
-                Tab(text: 'علاقه‌مندی'),
+          title: const Text('کتابخانه'),
+          centerTitle: true,
+          bottom: PreferredSize(
+            preferredSize: const Size.fromHeight(100),
+            child: Column(
+              children: [
+                // Content type segmented control (Books / Music)
+                Padding(
+                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
+                  child: Container(
+                    decoration: BoxDecoration(
+                      color: AppColors.surfaceLight,
+                      borderRadius: BorderRadius.circular(12),
+                    ),
+                    padding: const EdgeInsets.all(4),
+                    child: Row(
+                      children: [
+                        Expanded(
+                          child: _buildSegmentButton(
+                            index: 0,
+                            label: '📚 کتاب‌ها',
+                            isSelected: _selectedContentType == 0,
+                          ),
+                        ),
+                        Expanded(
+                          child: _buildSegmentButton(
+                            index: 1,
+                            label: '🎵 موسیقی',
+                            isSelected: _selectedContentType == 1,
+                          ),
+                        ),
+                      ],
+                    ),
+                  ),
+                ),
+                // My Items / Wishlist / Playlists tabs
+                TabBar(
+                  controller: _tabController,
+                  indicatorColor: AppColors.primary,
+                  labelColor: AppColors.primary,
+                  unselectedLabelColor: AppColors.textTertiary,
+                  tabs: [
+                    Tab(text: _isMusic ? 'موسیقی من' : 'کتاب‌های من'),
+                    const Tab(text: 'علاقه‌مندی'),
+                    const Tab(text: 'لیست پخش'),
+                  ],
+                ),
               ],
             ),
           ),
-          body: TabBarView(
-            children: [
-              _OwnedBooksTab(),
-              _WishlistTab(),
-            ],
+        ),
+        body: TabBarView(
+          controller: _tabController,
+          children: [
+            // Key ensures widget rebuilds when switching between Books/Music
+            _OwnedItemsTab(key: ValueKey('owned_$_isMusic'), isMusic: _isMusic),
+            _WishlistTab(key: ValueKey('wishlist_$_isMusic'), isMusic: _isMusic),
+            _PlaylistsTab(key: ValueKey('playlists_$_isMusic'), isMusic: _isMusic),
+          ],
+        ),
+      ),
+    );
+  }
+
+  Widget _buildSegmentButton({
+    required int index,
+    required String label,
+    required bool isSelected,
+  }) {
+    return GestureDetector(
+      onTap: () {
+        if (_selectedContentType != index) {
+          setState(() {
+            _selectedContentType = index;
+          });
+        }
+      },
+      child: AnimatedContainer(
+        duration: const Duration(milliseconds: 200),
+        padding: const EdgeInsets.symmetric(vertical: 10),
+        decoration: BoxDecoration(
+          color: isSelected ? AppColors.primary : Colors.transparent,
+          borderRadius: BorderRadius.circular(10),
+        ),
+        child: Center(
+          child: Text(
+            label,
+            style: AppTypography.labelLarge.copyWith(
+              color: isSelected ? Colors.white : AppColors.textSecondary,
+              fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
+            ),
           ),
         ),
       ),
@@ -152,67 +315,236 @@ class LibraryScreen extends ConsumerWidget {
   }
 }
 
-class _OwnedBooksTab extends ConsumerWidget {
+/// =============================================================================
+/// LIBRARY SEARCH DESIGN
+/// =============================================================================
+///
+/// The library search is CLIENT-SIDE filtering (not server-side) because:
+/// 1. User library lists are typically small (owned items only)
+/// 2. Data is already loaded via ownedItemsWithProgressProvider
+/// 3. Instant response without network round-trip
+///
+/// SEARCH BEHAVIOR:
+/// - Searches ONLY within the user's own library (books they own via entitlements)
+/// - Context-aware: respects کتاب‌ها vs موسیقی tab selection
+/// - Fields searched: title_fa, title_en, author_fa (creator name)
+/// - Uses FarsiUtils.normalizeSearchQuery for Persian text normalization
+/// - Clearing the search returns to the full library list
+/// =============================================================================
+
+class _OwnedItemsTab extends ConsumerStatefulWidget {
+  final bool isMusic;
+
+  const _OwnedItemsTab({super.key, required this.isMusic});
+
   @override
-  Widget build(BuildContext context, WidgetRef ref) {
-    final booksAsync = ref.watch(ownedBooksWithProgressProvider);
+  ConsumerState<_OwnedItemsTab> createState() => _OwnedItemsTabState();
+}
+
+class _OwnedItemsTabState extends ConsumerState<_OwnedItemsTab> {
+  final _searchController = TextEditingController();
+  String _searchQuery = '';
+
+  @override
+  void dispose() {
+    _searchController.dispose();
+    super.dispose();
+  }
+
+  /// Filter items by search query (client-side)
+  List<Map<String, dynamic>> _filterItems(List<Map<String, dynamic>> items) {
+    if (_searchQuery.isEmpty) return items;
+
+    final normalizedQuery = FarsiUtils.normalizeSearchQuery(_searchQuery);
+    if (normalizedQuery.isEmpty) return items;
+
+    return items.where((item) {
+      // Search in title_fa
+      final titleFa = FarsiUtils.normalizeSearchQuery(
+        (item['title_fa'] as String?) ?? '',
+      );
+      if (titleFa.contains(normalizedQuery)) return true;
+
+      // Search in title_en
+      final titleEn = ((item['title_en'] as String?) ?? '').toLowerCase();
+      if (titleEn.contains(normalizedQuery.toLowerCase())) return true;
+
+      // Search in author_fa (for books) or artist name (for music)
+      final authorFa = FarsiUtils.normalizeSearchQuery(
+        (item['author_fa'] as String?) ?? '',
+      );
+      if (authorFa.contains(normalizedQuery)) return true;
 
-    return booksAsync.when(
+      return false;
+    }).toList();
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    final itemsAsync = ref.watch(ownedItemsWithProgressProvider(widget.isMusic));
+
+    return itemsAsync.when(
       loading: () => const LibraryListSkeleton(),
-      error: (e, _) => Center(
-        child: Column(
-          mainAxisAlignment: MainAxisAlignment.center,
-          children: [
-            const Icon(Icons.error_outline, color: AppColors.error, size: 48),
-            const SizedBox(height: 16),
-            const Text(
-              'خطا در بارگذاری کتابخانه',
-              style: TextStyle(color: AppColors.error),
-            ),
-            const SizedBox(height: 8),
-            ElevatedButton(
-              onPressed: () => ref.invalidate(ownedBooksWithProgressProvider),
-              child: const Text('تلاش مجدد'),
-            ),
-          ],
-        ),
-      ),
-      data: (books) {
-        if (books.isEmpty) {
-          return Center(
-            child: Column(
-              mainAxisAlignment: MainAxisAlignment.center,
-              children: [
-                Icon(
-                  Icons.library_books_outlined,
-                  size: 64,
-                  color: AppColors.textTertiary.withOpacity(0.5),
-                ),
-                const SizedBox(height: 16),
-                const Text(
-                  'هنوز کتابی خریداری نکرده‌اید',
-                  style: TextStyle(color: AppColors.textSecondary),
-                ),
-                const SizedBox(height: 8),
-                Text(
-                  'کتاب‌های خریداری شده اینجا نمایش داده می‌شوند',
-                  style: TextStyle(
-                    color: AppColors.textTertiary,
-                    fontSize: 12,
-                  ),
+      error: (e, stackTrace) {
+        // Log detailed error for debugging
+        AppLogger.e('Library tab error: $e', error: e, stackTrace: stackTrace);
+        final errorMsg = e is PostgrestException
+            ? 'Code: ${e.code}\nMessage: ${e.message}\nDetails: ${e.details}'
+            : e.toString();
+        return Center(
+          child: Column(
+            mainAxisAlignment: MainAxisAlignment.center,
+            children: [
+              const Icon(Icons.error_outline, color: AppColors.error, size: 48),
+              const SizedBox(height: 16),
+              Text(
+                widget.isMusic ? 'خطا در بارگذاری موسیقی' : 'خطا در بارگذاری کتابخانه',
+                style: const TextStyle(color: AppColors.error),
+              ),
+              const SizedBox(height: 8),
+              // Show actual error in debug mode
+              Padding(
+                padding: const EdgeInsets.symmetric(horizontal: 16),
+                child: Text(
+                  errorMsg,
+                  style: const TextStyle(color: AppColors.textTertiary, fontSize: 10),
+                  textAlign: TextAlign.center,
                 ),
-              ],
-            ),
-          );
-        }
+              ),
+              const SizedBox(height: 12),
+              ElevatedButton(
+                onPressed: () => ref.invalidate(ownedItemsWithProgressProvider(widget.isMusic)),
+                child: const Text('تلاش مجدد'),
+              ),
+            ],
+          ),
+        );
+      },
+      data: (items) {
+        // Apply client-side search filter
+        final filteredItems = _filterItems(items);
 
         return RefreshIndicator(
-          onRefresh: () async => ref.invalidate(ownedBooksWithProgressProvider),
+          onRefresh: () async {
+            ref.invalidate(ownedItemsWithProgressProvider(widget.isMusic));
+            // Wait for the provider to reload before dismissing the indicator
+            await ref.read(ownedItemsWithProgressProvider(widget.isMusic).future);
+          },
           color: AppColors.primary,
-          child: ListView.builder(
-            padding: const EdgeInsets.all(16),
-            itemCount: books.length,
-            itemBuilder: (context, index) => _OwnedBookCard(book: books[index]),
+          child: Column(
+            children: [
+              // Search bar (only show if user has items)
+              if (items.isNotEmpty)
+                Padding(
+                  padding: const EdgeInsets.fromLTRB(16, 12, 16, 8),
+                  child: TextField(
+                    controller: _searchController,
+                    textDirection: TextDirection.rtl,
+                    decoration: InputDecoration(
+                      hintText: widget.isMusic ? 'جستجو در موسیقی من...' : 'جستجو در کتاب‌های من...',
+                      hintStyle: const TextStyle(color: AppColors.textTertiary),
+                      prefixIcon: const Icon(Icons.search, color: AppColors.textTertiary),
+                      suffixIcon: _searchQuery.isNotEmpty
+                          ? IconButton(
+                              icon: const Icon(Icons.clear, color: AppColors.textTertiary),
+                              onPressed: () {
+                                _searchController.clear();
+                                setState(() => _searchQuery = '');
+                              },
+                            )
+                          : null,
+                      filled: true,
+                      fillColor: AppColors.surfaceLight,
+                      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
+                      border: OutlineInputBorder(
+                        borderRadius: BorderRadius.circular(12),
+                        borderSide: BorderSide.none,
+                      ),
+                    ),
+                    onChanged: (value) => setState(() => _searchQuery = value),
+                  ),
+                ),
+
+              // Results
+              Expanded(
+                child: items.isEmpty
+                    ? ListView(
+                        physics: const AlwaysScrollableScrollPhysics(),
+                        children: [
+                          SizedBox(
+                            height: MediaQuery.of(context).size.height * 0.5,
+                            child: Center(
+                              child: Column(
+                                mainAxisAlignment: MainAxisAlignment.center,
+                                children: [
+                                  Icon(
+                                    widget.isMusic ? Icons.music_note_outlined : Icons.library_books_outlined,
+                                    size: 64,
+                                    color: AppColors.textTertiary.withOpacity(0.5),
+                                  ),
+                                  const SizedBox(height: 16),
+                                  Text(
+                                    widget.isMusic ? 'هنوز موسیقی خریداری نکرده‌اید' : 'هنوز کتابی خریداری نکرده‌اید',
+                                    style: AppTypography.emptyState,
+                                  ),
+                                  const SizedBox(height: 8),
+                                  Text(
+                                    widget.isMusic
+                                        ? 'موسیقی‌های خریداری شده اینجا نمایش داده می‌شوند'
+                                        : 'کتاب‌های خریداری شده اینجا نمایش داده می‌شوند',
+                                    style: AppTypography.bodySmall.copyWith(color: AppColors.textTertiary),
+                                  ),
+                                ],
+                              ),
+                            ),
+                          ),
+                        ],
+                      )
+                    : filteredItems.isEmpty
+                        ? ListView(
+                            physics: const AlwaysScrollableScrollPhysics(),
+                            children: [
+                              SizedBox(
+                                height: MediaQuery.of(context).size.height * 0.4,
+                                child: Center(
+                                  child: Column(
+                                    mainAxisAlignment: MainAxisAlignment.center,
+                                    children: [
+                                      const Icon(
+                                        Icons.search_off,
+                                        size: 48,
+                                        color: AppColors.textTertiary,
+                                      ),
+                                      const SizedBox(height: 16),
+                                      const Text(
+                                        'نتیجه‌ای یافت نشد',
+                                        style: TextStyle(color: AppColors.textSecondary),
+                                      ),
+                                      const SizedBox(height: 8),
+                                      Text(
+                                        'عبارت جستجو: "$_searchQuery"',
+                                        style: const TextStyle(
+                                          color: AppColors.textTertiary,
+                                          fontSize: 12,
+                                        ),
+                                      ),
+                                    ],
+                                  ),
+                                ),
+                              ),
+                            ],
+                          )
+                        : ListView.builder(
+                            physics: const AlwaysScrollableScrollPhysics(),
+                            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
+                            itemCount: filteredItems.length,
+                            itemBuilder: (context, index) => _OwnedItemCard(
+                              item: filteredItems[index],
+                              isMusic: widget.isMusic,
+                            ),
+                          ),
+              ),
+            ],
           ),
         );
       },
@@ -220,15 +552,16 @@ class _OwnedBooksTab extends ConsumerWidget {
   }
 }
 
-class _OwnedBookCard extends ConsumerWidget {
-  final Map<String, dynamic> book;
+class _OwnedItemCard extends ConsumerWidget {
+  final Map<String, dynamic> item;
+  final bool isMusic;
 
-  const _OwnedBookCard({required this.book});
+  const _OwnedItemCard({required this.item, required this.isMusic});
 
   @override
   Widget build(BuildContext context, WidgetRef ref) {
-    final progress = book['progress'] as Map<String, dynamic>?;
-    final chapters = book['chapters'] as List<dynamic>?;
+    final progress = item['progress'] as Map<String, dynamic>?;
+    final chapters = item['chapters'] as List<dynamic>?;
     final sortedChapters = chapters != null
         ? (List<Map<String, dynamic>>.from(chapters)
           ..sort((Map<String, dynamic> a, Map<String, dynamic> b) =>
@@ -243,7 +576,7 @@ class _OwnedBookCard extends ConsumerWidget {
     final hasProgress = progress != null && completionPercentage > 0;
 
     // Check for offline downloads (only on mobile)
-    final audiobookId = book['id'] as int;
+    final audiobookId = item['id'] as int;
     final hasOfflineContent = !kIsWeb && ref.watch(downloadProvider.select(
       (_) => ref.read(downloadProvider.notifier).hasAnyDownloads(audiobookId),
     ));
@@ -260,7 +593,7 @@ class _OwnedBookCard extends ConsumerWidget {
                 audiobookId: audiobookId,
               ),
             ),
-          ).then((_) => ref.invalidate(ownedBooksWithProgressProvider));
+          ).then((_) => ref.invalidate(ownedItemsWithProgressProvider(isMusic)));
         },
         borderRadius: BorderRadius.circular(12),
         child: Padding(
@@ -277,16 +610,20 @@ class _OwnedBookCard extends ConsumerWidget {
                       width: 60,
                       height: 80,
                       color: AppColors.surfaceLight,
-                      child: book['cover_url'] != null
-                          ? Image.network(
-                              book['cover_url'] as String,
+                      child: item['cover_url'] != null
+                          ? CachedNetworkImage(
+                              imageUrl: item['cover_url'] as String,
                               fit: BoxFit.cover,
-                              errorBuilder: (_, __, ___) => const Icon(
-                                Icons.book,
+                              placeholder: (_, __) => Icon(
+                                isMusic ? Icons.music_note : Icons.book,
+                                color: AppColors.textTertiary,
+                              ),
+                              errorWidget: (_, __, ___) => Icon(
+                                isMusic ? Icons.music_note : Icons.book,
                                 color: AppColors.textTertiary,
                               ),
                             )
-                          : const Icon(Icons.book, color: AppColors.textTertiary),
+                          : Icon(isMusic ? Icons.music_note : Icons.book, color: AppColors.textTertiary),
                     ),
                   ),
                   // Completion badge
@@ -328,31 +665,37 @@ class _OwnedBookCard extends ConsumerWidget {
                 ],
               ),
               const SizedBox(width: 12),
-              // Book info
+              // Item info
               Expanded(
                 child: Column(
                   crossAxisAlignment: CrossAxisAlignment.start,
                   children: [
                     Text(
-                      (book['title_fa'] as String?) ?? '',
-                      style: const TextStyle(
-                        color: AppColors.textPrimary,
-                        fontWeight: FontWeight.w600,
-                        fontSize: 15,
-                      ),
+                      (item['title_fa'] as String?) ?? '',
+                      style: AppTypography.titleMedium.copyWith(fontWeight: FontWeight.w600),
                       maxLines: 2,
                       overflow: TextOverflow.ellipsis,
                     ),
                     const SizedBox(height: 4),
-                    Text(
-                      (book['profiles']?['display_name'] as String?) ??
-                      (book['profiles']?['full_name'] as String?) ?? '',
-                      style: TextStyle(
-                        color: AppColors.textSecondary,
-                        fontSize: 12,
-                      ),
-                      maxLines: 1,
-                      overflow: TextOverflow.ellipsis,
+                    Builder(
+                      builder: (context) {
+                        // Check if this item is branded as "پرستو"
+                        final isParastoBrand = (item['is_parasto_brand'] as bool?) ?? false;
+                        // Narrator info from join (if available) or author_fa field
+                        final profiles = item['profiles'] as Map<String, dynamic>?;
+                        final narratorRaw = profiles?['display_name'] as String? ??
+                            profiles?['full_name'] as String? ??
+                            (item['author_fa'] as String?) ?? '';
+                        // For music, show author_fa (artist) if available
+                        final artistName = isMusic ? ((item['author_fa'] as String?) ?? narratorRaw) : narratorRaw;
+                        final displayName = isParastoBrand ? 'پرستو' : artistName;
+                        return Text(
+                          displayName,
+                          style: AppTypography.cardSubtitle,
+                          maxLines: 1,
+                          overflow: TextOverflow.ellipsis,
+                        );
+                      },
                     ),
                     const SizedBox(height: 8),
                     // Progress indicator
@@ -375,12 +718,10 @@ class _OwnedBookCard extends ConsumerWidget {
                           const SizedBox(width: 8),
                           Text(
                             '$completionPercentage%',
-                            style: TextStyle(
+                            style: AppTypography.progressText.copyWith(
                               color: isCompleted
                                   ? AppColors.success
                                   : AppColors.primary,
-                              fontSize: 11,
-                              fontWeight: FontWeight.bold,
                             ),
                           ),
                         ],
@@ -389,19 +730,17 @@ class _OwnedBookCard extends ConsumerWidget {
                       Text(
                         isCompleted
                             ? 'تمام شده'
-                            : 'فصل ${currentChapterIndex + 1} از ${sortedChapters.length}',
-                        style: TextStyle(
-                          color: AppColors.textTertiary,
-                          fontSize: 11,
-                        ),
+                            : isMusic
+                                ? 'قطعه ${currentChapterIndex + 1} از ${sortedChapters.length}'
+                                : 'فصل ${currentChapterIndex + 1} از ${sortedChapters.length}',
+                        style: AppTypography.meta,
                       ),
                     ] else
                       Text(
-                        '${sortedChapters.length} فصل',
-                        style: TextStyle(
-                          color: AppColors.textTertiary,
-                          fontSize: 12,
-                        ),
+                        isMusic
+                            ? '${sortedChapters.length} قطعه'
+                            : '${sortedChapters.length} فصل',
+                        style: AppTypography.meta,
                       ),
                   ],
                 ),
@@ -422,9 +761,9 @@ class _OwnedBookCard extends ConsumerWidget {
                     onPressed: sortedChapters.isEmpty
                         ? null
                         : () {
-                            // Start playing directly (user owns this book via entitlement)
+                            // Start playing directly (user owns this item via entitlement)
                             ref.read(audioProvider.notifier).play(
-                              audiobook: book,
+                              audiobook: item,
                               chapters: sortedChapters,
                               chapterIndex: hasProgress ? currentChapterIndex : 0,
                               seekTo: hasProgress ? positionSeconds : null,
@@ -434,18 +773,18 @@ class _OwnedBookCard extends ConsumerWidget {
                               context,
                               MaterialPageRoute<void>(
                                 builder: (_) => PlayerScreen(
-                                  audiobook: book,
+                                  audiobook: item,
                                   chapters: sortedChapters,
                                   initialChapterIndex:
                                       hasProgress ? currentChapterIndex : 0,
                                 ),
                               ),
                             ).then(
-                                (_) => ref.invalidate(ownedBooksWithProgressProvider));
+                                (_) => ref.invalidate(ownedItemsWithProgressProvider(isMusic)));
                           },
                   ),
                   if (hasProgress && !isCompleted)
-                    Text(
+                    const Text(
                       'ادامه',
                       style: TextStyle(
                         color: AppColors.primary,
@@ -464,11 +803,15 @@ class _OwnedBookCard extends ConsumerWidget {
 }
 
 class _WishlistTab extends ConsumerWidget {
+  final bool isMusic;
+
+  const _WishlistTab({super.key, required this.isMusic});
+
   @override
   Widget build(BuildContext context, WidgetRef ref) {
-    final booksAsync = ref.watch(wishlistBooksProvider);
+    final itemsAsync = ref.watch(wishlistItemsProvider(isMusic));
 
-    return booksAsync.when(
+    return itemsAsync.when(
       loading: () => const LibraryListSkeleton(),
       error: (e, _) => Center(
         child: Column(
@@ -482,57 +825,70 @@ class _WishlistTab extends ConsumerWidget {
             ),
             const SizedBox(height: 8),
             ElevatedButton(
-              onPressed: () => ref.invalidate(wishlistBooksProvider),
+              onPressed: () => ref.invalidate(wishlistItemsProvider(isMusic)),
               child: const Text('تلاش مجدد'),
             ),
           ],
         ),
       ),
-      data: (books) {
-        if (books.isEmpty) {
-          return Center(
-            child: Column(
-              mainAxisAlignment: MainAxisAlignment.center,
-              children: [
-                Icon(
-                  Icons.favorite_border,
-                  size: 64,
-                  color: AppColors.textTertiary.withOpacity(0.5),
-                ),
-                const SizedBox(height: 16),
-                const Text(
-                  'لیست علاقه‌مندی خالی است',
-                  style: TextStyle(color: AppColors.textSecondary),
-                ),
-                const SizedBox(height: 8),
-                Text(
-                  'کتاب‌های مورد علاقه را به این لیست اضافه کنید',
-                  style: TextStyle(
-                    color: AppColors.textTertiary,
-                    fontSize: 12,
-                  ),
-                ),
-              ],
-            ),
-          );
-        }
-
+      data: (items) {
         return RefreshIndicator(
-          onRefresh: () async => ref.invalidate(wishlistBooksProvider),
+          onRefresh: () async {
+            ref.invalidate(wishlistItemsProvider(isMusic));
+            // Wait for the provider to reload before dismissing the indicator
+            await ref.read(wishlistItemsProvider(isMusic).future);
+          },
           color: AppColors.primary,
-          child: ListView.builder(
-            padding: const EdgeInsets.all(16),
-            itemCount: books.length,
-            itemBuilder: (context, index) =>
-                _buildWishlistCard(context, ref, books[index]),
-          ),
+          child: items.isEmpty
+              ? ListView(
+                  physics: const AlwaysScrollableScrollPhysics(),
+                  children: [
+                    SizedBox(
+                      height: MediaQuery.of(context).size.height * 0.6,
+                      child: Center(
+                        child: Column(
+                          mainAxisAlignment: MainAxisAlignment.center,
+                          children: [
+                            Icon(
+                              Icons.favorite_border,
+                              size: 64,
+                              color: AppColors.textTertiary.withOpacity(0.5),
+                            ),
+                            const SizedBox(height: 16),
+                            const Text(
+                              'لیست علاقه‌مندی خالی است',
+                              style: TextStyle(color: AppColors.textSecondary),
+                            ),
+                            const SizedBox(height: 8),
+                            Text(
+                              isMusic
+                                  ? 'موسیقی‌های مورد علاقه را به این لیست اضافه کنید'
+                                  : 'کتاب‌های مورد علاقه را به این لیست اضافه کنید',
+                              style: const TextStyle(
+                                color: AppColors.textTertiary,
+                                fontSize: 12,
+                              ),
+                            ),
+                          ],
+                        ),
+                      ),
+                    ),
+                  ],
+                )
+              : ListView.builder(
+                  physics: const AlwaysScrollableScrollPhysics(),
+                  padding: const EdgeInsets.all(16),
+                  itemCount: items.length,
+                  itemBuilder: (context, index) =>
+                      _buildWishlistCard(context, ref, items[index]),
+                ),
         );
       },
     );
   }
 
   Widget _buildWishlistCard(
-      BuildContext context, WidgetRef ref, Map<String, dynamic> book) {
+      BuildContext context, WidgetRef ref, Map<String, dynamic> item) {
     return Card(
       color: AppColors.surface,
       margin: const EdgeInsets.only(bottom: 12),
@@ -542,7 +898,7 @@ class _WishlistTab extends ConsumerWidget {
             context,
             MaterialPageRoute<void>(
               builder: (context) => AudiobookDetailScreen(
-                audiobookId: book['id'] as int,
+                audiobookId: item['id'] as int,
               ),
             ),
           );
@@ -553,20 +909,24 @@ class _WishlistTab extends ConsumerWidget {
             width: 50,
             height: 60,
             color: AppColors.surfaceLight,
-            child: book['cover_url'] != null
-                ? Image.network(
-                    book['cover_url'] as String,
+            child: item['cover_url'] != null
+                ? CachedNetworkImage(
+                    imageUrl: item['cover_url'] as String,
                     fit: BoxFit.cover,
-                    errorBuilder: (_, __, ___) => const Icon(
-                      Icons.book,
+                    placeholder: (_, __) => Icon(
+                      isMusic ? Icons.music_note : Icons.book,
+                      color: AppColors.textTertiary,
+                    ),
+                    errorWidget: (_, __, ___) => Icon(
+                      isMusic ? Icons.music_note : Icons.book,
                       color: AppColors.textTertiary,
                     ),
                   )
-                : const Icon(Icons.book, color: AppColors.textTertiary),
+                : Icon(isMusic ? Icons.music_note : Icons.book, color: AppColors.textTertiary),
           ),
         ),
         title: Text(
-          (book['title_fa'] as String?) ?? '',
+          (item['title_fa'] as String?) ?? '',
           style: const TextStyle(
             color: AppColors.textPrimary,
             fontWeight: FontWeight.w500,
@@ -575,11 +935,11 @@ class _WishlistTab extends ConsumerWidget {
           overflow: TextOverflow.ellipsis,
         ),
         subtitle: Text(
-          book['is_free'] == true
+          item['is_free'] == true
               ? 'رایگان'
-              : '${(book['price_toman'] as num?) ?? 0}',
+              : '${(item['price_toman'] as num?) ?? 0}',
           style: TextStyle(
-            color: book['is_free'] == true ? AppColors.success : AppColors.primary,
+            color: item['is_free'] == true ? AppColors.success : AppColors.primary,
             fontSize: 12,
           ),
         ),
@@ -592,12 +952,353 @@ class _WishlistTab extends ConsumerWidget {
             await Supabase.instance.client
                 .from('user_wishlist')
                 .delete()
-                .eq('user_id', user.id as Object)
-                .eq('audiobook_id', book['id'] as Object);
+                .eq('user_id', user.id)
+                .eq('audiobook_id', item['id'] as int);
+
+            ref.invalidate(wishlistItemsProvider(isMusic));
+          },
+        ),
+      ),
+    );
+  }
+}
+
+// =============================================================================
+// PLAYLISTS TAB
+// =============================================================================
+
+class _PlaylistsTab extends ConsumerWidget {
+  final bool isMusic;
+
+  const _PlaylistsTab({super.key, required this.isMusic});
 
-            ref.invalidate(wishlistBooksProvider);
+  @override
+  Widget build(BuildContext context, WidgetRef ref) {
+    // Filter playlists by type (book or music)
+    final playlistsAsync = isMusic
+        ? ref.watch(musicPlaylistsProvider)
+        : ref.watch(bookPlaylistsProvider);
+
+    return playlistsAsync.when(
+      loading: () => const LibraryListSkeleton(),
+      error: (e, _) => Center(
+        child: Column(
+          mainAxisAlignment: MainAxisAlignment.center,
+          children: [
+            const Icon(Icons.error_outline, color: AppColors.error, size: 48),
+            const SizedBox(height: 16),
+            const Text(
+              'خطا در بارگذاری لیست‌های پخش',
+              style: TextStyle(color: AppColors.error),
+            ),
+            const SizedBox(height: 8),
+            ElevatedButton(
+              onPressed: () {
+                if (isMusic) {
+                  ref.invalidate(musicPlaylistsProvider);
+                } else {
+                  ref.invalidate(bookPlaylistsProvider);
+                }
+              },
+              child: const Text('تلاش مجدد'),
+            ),
+          ],
+        ),
+      ),
+      data: (playlists) {
+        return RefreshIndicator(
+          onRefresh: () async {
+            if (isMusic) {
+              ref.invalidate(musicPlaylistsProvider);
+              await ref.read(musicPlaylistsProvider.future);
+            } else {
+              ref.invalidate(bookPlaylistsProvider);
+              await ref.read(bookPlaylistsProvider.future);
+            }
           },
+          color: AppColors.primary,
+          child: playlists.isEmpty
+              ? _buildEmptyState(context, ref)
+              : _buildPlaylistList(context, ref, playlists),
+        );
+      },
+    );
+  }
+
+  Widget _buildEmptyState(BuildContext context, WidgetRef ref) {
+    return ListView(
+      physics: const AlwaysScrollableScrollPhysics(),
+      children: [
+        SizedBox(
+          height: MediaQuery.of(context).size.height * 0.5,
+          child: Center(
+            child: Column(
+              mainAxisAlignment: MainAxisAlignment.center,
+              children: [
+                Icon(
+                  Icons.playlist_play,
+                  size: 64,
+                  color: AppColors.textTertiary.withOpacity(0.5),
+                ),
+                const SizedBox(height: 16),
+                Text(
+                  isMusic
+                      ? 'هنوز لیست پخش موسیقی ندارید'
+                      : 'هنوز لیست پخش کتاب ندارید',
+                  style: AppTypography.emptyState,
+                ),
+                const SizedBox(height: 8),
+                Text(
+                  isMusic
+                      ? 'موسیقی‌های مورد علاقه را در لیست‌های پخش سازماندهی کنید'
+                      : 'کتاب‌های مورد علاقه را در لیست‌های پخش سازماندهی کنید',
+                  style: AppTypography.bodySmall.copyWith(color: AppColors.textTertiary),
+                  textAlign: TextAlign.center,
+                ),
+                const SizedBox(height: 24),
+                ElevatedButton.icon(
+                  onPressed: () => _showCreatePlaylistDialog(context, ref),
+                  icon: const Icon(Icons.add),
+                  label: const Text('لیست پخش جدید'),
+                  style: ElevatedButton.styleFrom(
+                    backgroundColor: AppColors.primary,
+                    foregroundColor: Colors.white,
+                    padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
+                  ),
+                ),
+              ],
+            ),
+          ),
+        ),
+      ],
+    );
+  }
+
+  Widget _buildPlaylistList(BuildContext context, WidgetRef ref, List<Playlist> playlists) {
+    return Column(
+      children: [
+        // Create button at top
+        Padding(
+          padding: const EdgeInsets.all(16),
+          child: SizedBox(
+            width: double.infinity,
+            child: OutlinedButton.icon(
+              onPressed: () => _showCreatePlaylistDialog(context, ref),
+              icon: const Icon(Icons.add),
+              label: const Text('لیست پخش جدید'),
+              style: OutlinedButton.styleFrom(
+                foregroundColor: AppColors.primary,
+                side: const BorderSide(color: AppColors.primary),
+                padding: const EdgeInsets.symmetric(vertical: 12),
+              ),
+            ),
+          ),
+        ),
+        // Playlist list
+        Expanded(
+          child: ListView.builder(
+            physics: const AlwaysScrollableScrollPhysics(),
+            padding: const EdgeInsets.symmetric(horizontal: 16),
+            itemCount: playlists.length,
+            itemBuilder: (context, index) {
+              final playlist = playlists[index];
+              return _PlaylistCard(
+                playlist: playlist,
+                onTap: () {
+                  Navigator.push(
+                    context,
+                    MaterialPageRoute<void>(
+                      builder: (_) => PlaylistDetailScreen(playlistId: playlist.id),
+                    ),
+                  ).then((_) {
+                    // Refresh playlists when returning
+                    if (isMusic) {
+                      ref.invalidate(musicPlaylistsProvider);
+                    } else {
+                      ref.invalidate(bookPlaylistsProvider);
+                    }
+                  });
+                },
+              );
+            },
+          ),
+        ),
+      ],
+    );
+  }
+
+  void _showCreatePlaylistDialog(BuildContext context, WidgetRef ref) {
+    final titleController = TextEditingController();
+
+    showDialog<void>(
+      context: context,
+      builder: (context) => Directionality(
+        textDirection: TextDirection.rtl,
+        child: AlertDialog(
+          backgroundColor: AppColors.surface,
+          title: const Text(
+            'لیست پخش جدید',
+            style: TextStyle(color: AppColors.textPrimary),
+          ),
+          content: Column(
+            mainAxisSize: MainAxisSize.min,
+            crossAxisAlignment: CrossAxisAlignment.start,
+            children: [
+              TextField(
+                controller: titleController,
+                decoration: const InputDecoration(
+                  labelText: 'نام لیست پخش',
+                  hintText: 'مثال: مورد علاقه‌های من',
+                ),
+                autofocus: true,
+              ),
+              const SizedBox(height: 16),
+              Container(
+                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
+                decoration: BoxDecoration(
+                  color: AppColors.primary.withOpacity(0.1),
+                  borderRadius: BorderRadius.circular(8),
+                ),
+                child: Row(
+                  mainAxisSize: MainAxisSize.min,
+                  children: [
+                    Icon(
+                      isMusic ? Icons.music_note : Icons.book,
+                      size: 16,
+                      color: AppColors.primary,
+                    ),
+                    const SizedBox(width: 8),
+                    Text(
+                      isMusic ? 'لیست پخش موسیقی' : 'لیست پخش کتاب',
+                      style: const TextStyle(
+                        color: AppColors.primary,
+                        fontSize: 12,
+                        fontWeight: FontWeight.w500,
+                      ),
+                    ),
+                  ],
+                ),
+              ),
+            ],
+          ),
+          actions: [
+            TextButton(
+              onPressed: () => Navigator.pop(context),
+              child: const Text('انصراف'),
+            ),
+            ElevatedButton(
+              onPressed: () async {
+                final title = titleController.text.trim();
+                if (title.isEmpty) {
+                  ScaffoldMessenger.of(context).showSnackBar(
+                    const SnackBar(
+                      content: Text('لطفاً نام لیست پخش را وارد کنید'),
+                      backgroundColor: AppColors.error,
+                    ),
+                  );
+                  return;
+                }
+
+                // Capture context before async gap
+                final scaffoldMessenger = ScaffoldMessenger.of(context);
+                Navigator.pop(context);
+
+                final service = ref.read(playlistServiceProvider);
+                final playlist = await service.createPlaylist(
+                  title: title,
+                  isMusic: isMusic,
+                );
+
+                if (playlist != null) {
+                  // Refresh the list
+                  if (isMusic) {
+                    ref.invalidate(musicPlaylistsProvider);
+                  } else {
+                    ref.invalidate(bookPlaylistsProvider);
+                  }
+                  scaffoldMessenger.showSnackBar(
+                    SnackBar(
+                      content: Text('لیست پخش "$title" ایجاد شد'),
+                      backgroundColor: AppColors.success,
+                    ),
+                  );
+                } else {
+                  scaffoldMessenger.showSnackBar(
+                    const SnackBar(
+                      content: Text('خطا در ایجاد لیست پخش'),
+                      backgroundColor: AppColors.error,
+                    ),
+                  );
+                }
+              },
+              child: const Text('ایجاد'),
+            ),
+          ],
+        ),
+      ),
+    );
+  }
+}
+
+class _PlaylistCard extends StatelessWidget {
+  final Playlist playlist;
+  final VoidCallback onTap;
+
+  const _PlaylistCard({required this.playlist, required this.onTap});
+
+  @override
+  Widget build(BuildContext context) {
+    return Card(
+      color: AppColors.surface,
+      margin: const EdgeInsets.only(bottom: 12),
+      child: ListTile(
+        onTap: onTap,
+        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
+        leading: Container(
+          width: 50,
+          height: 50,
+          decoration: BoxDecoration(
+            color: AppColors.primary.withOpacity(0.1),
+            borderRadius: BorderRadius.circular(8),
+          ),
+          child: Icon(
+            playlist.isMusic ? Icons.music_note : Icons.book,
+            color: AppColors.primary,
+          ),
+        ),
+        title: Text(
+          playlist.title,
+          style: const TextStyle(
+            color: AppColors.textPrimary,
+            fontWeight: FontWeight.w600,
+          ),
+          maxLines: 1,
+          overflow: TextOverflow.ellipsis,
+        ),
+        subtitle: Row(
+          children: [
+            Container(
+              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
+              decoration: BoxDecoration(
+                color: AppColors.primary.withOpacity(0.1),
+                borderRadius: BorderRadius.circular(8),
+              ),
+              child: Text(
+                playlist.typeLabel,
+                style: const TextStyle(fontSize: 10, color: AppColors.primary),
+              ),
+            ),
+            const SizedBox(width: 8),
+            Text(
+              '${playlist.itemCount} مورد',
+              style: const TextStyle(
+                color: AppColors.textTertiary,
+                fontSize: 12,
+              ),
+            ),
+          ],
         ),
+        trailing: const Icon(Icons.chevron_left, color: AppColors.textTertiary),
       ),
     );
   }
diff --git a/lib/screens/listener/main_shell.dart b/lib/screens/listener/main_shell.dart
index 9f979e4..dc63f56 100644
--- a/lib/screens/listener/main_shell.dart
+++ b/lib/screens/listener/main_shell.dart
@@ -4,10 +4,14 @@ import 'package:myna/theme/app_theme.dart';
 import 'package:myna/providers/audio_provider.dart';
 import 'package:myna/widgets/mini_player.dart';
 import 'package:myna/screens/listener/home_screen.dart';
-import 'package:myna/screens/listener/search_screen.dart';
+import 'package:myna/screens/listener/music_screen.dart';
 import 'package:myna/screens/listener/library_screen.dart';
 import 'package:myna/screens/listener/profile_screen.dart';
 
+/// Main shell for listener role with bottom navigation
+/// Tabs: خانه (Home), موسیقی (Music), کتابخانه (Library), پروفایل (Profile)
+/// Note: Search is accessible via the search icon in the app bar (on Home and Music screens)
+/// PERFORMANCE: Uses lazy loading - only builds screens when first visited
 class MainShell extends ConsumerStatefulWidget {
   const MainShell({super.key});
   @override
@@ -16,12 +20,25 @@ class MainShell extends ConsumerStatefulWidget {
 
 class _MainShellState extends ConsumerState<MainShell> {
   int _currentIndex = 0;
-  final _screens = const [
-    HomeScreen(),
-    SearchScreen(),
-    LibraryScreen(),
-    ProfileScreen(),
-  ];
+
+  // Track which screens have been visited (for lazy building)
+  final Set<int> _visitedScreens = {0}; // Home is always visited first
+
+  // Build screen only if it's been visited
+  Widget _buildScreen(int index) {
+    switch (index) {
+      case 0:
+        return const HomeScreen();
+      case 1:
+        return const MusicScreen();
+      case 2:
+        return const LibraryScreen();
+      case 3:
+        return const ProfileScreen();
+      default:
+        return const HomeScreen();
+    }
+  }
 
   @override
   Widget build(BuildContext context) {
@@ -32,18 +49,24 @@ class _MainShellState extends ConsumerState<MainShell> {
       child: Scaffold(
         body: Column(
           children: [
-            // Main content
+            // Main content - only build visited screens
             Expanded(
               child: IndexedStack(
                 index: _currentIndex,
-                children: _screens,
+                children: [
+                  for (int i = 0; i < 4; i++)
+                    if (_visitedScreens.contains(i))
+                      _buildScreen(i)
+                    else
+                      const SizedBox.shrink(), // Placeholder for unvisited screens
+                ],
               ),
             ),
             // Mini player at bottom
             if (audio.hasAudio) const MiniPlayer(),
           ],
         ),
-        bottomNavigationBar: Container(
+        bottomNavigationBar: DecoratedBox(
           decoration: BoxDecoration(
             color: AppColors.surface,
             boxShadow: [
@@ -61,7 +84,7 @@ class _MainShellState extends ConsumerState<MainShell> {
                 mainAxisAlignment: MainAxisAlignment.spaceAround,
                 children: [
                   _buildNavItem(0, Icons.home, 'خانه'),
-                  _buildNavItem(1, Icons.search, 'جستجو'),
+                  _buildNavItem(1, Icons.music_note, 'موسیقی'), // Changed from search to music
                   _buildNavItem(2, Icons.library_books, 'کتابخانه'),
                   _buildNavItem(3, Icons.person, 'پروفایل'),
                 ],
@@ -76,7 +99,10 @@ class _MainShellState extends ConsumerState<MainShell> {
   Widget _buildNavItem(int index, IconData icon, String label) {
     final isSelected = _currentIndex == index;
     return GestureDetector(
-      onTap: () => setState(() => _currentIndex = index),
+      onTap: () => setState(() {
+        _visitedScreens.add(index); // Mark screen as visited (lazy load)
+        _currentIndex = index;
+      }),
       child: Container(
         padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
         decoration: BoxDecoration(
diff --git a/lib/screens/listener/notifications_screen.dart b/lib/screens/listener/notifications_screen.dart
index f26ffd8..1c479c4 100644
--- a/lib/screens/listener/notifications_screen.dart
+++ b/lib/screens/listener/notifications_screen.dart
@@ -211,10 +211,10 @@ class NotificationsScreen extends ConsumerWidget {
                       borderRadius: BorderRadius.circular(12),
                       border: Border.all(color: AppColors.primary.withOpacity(0.2)),
                     ),
-                    child: Row(
+                    child: const Row(
                       children: [
                         Icon(Icons.info_outline, color: AppColors.primary, size: 24),
-                        const SizedBox(width: 12),
+                        SizedBox(width: 12),
                         Expanded(
                           child: Text(
                             'اعلان‌ها را مدیریت کنید تا فقط موارد مهم را دریافت کنید',
@@ -312,7 +312,7 @@ class NotificationsScreen extends ConsumerWidget {
   }
 
   Widget _buildCard(List<Widget> children) {
-    return Container(
+    return DecoratedBox(
       decoration: BoxDecoration(
         color: AppColors.surface,
         borderRadius: BorderRadius.circular(12),
diff --git a/lib/screens/listener/profile_screen.dart b/lib/screens/listener/profile_screen.dart
index 37d1dd3..bf637e1 100644
--- a/lib/screens/listener/profile_screen.dart
+++ b/lib/screens/listener/profile_screen.dart
@@ -12,6 +12,7 @@ import 'package:myna/providers/audio_provider.dart';
 import 'package:myna/providers/download_provider.dart';
 import 'package:myna/providers/support_providers.dart';
 import 'package:myna/providers/home_providers.dart';
+import 'package:myna/providers/app_mode_provider.dart';
 
 final profileDataProvider = FutureProvider<Map<String, dynamic>?>((ref) async {
   final user = Supabase.instance.client.auth.currentUser;
@@ -84,7 +85,7 @@ class ProfileScreen extends ConsumerWidget {
                     padding: const EdgeInsets.only(top: 8),
                     child: Text(
                       profile['bio'] as String,
-                      style: TextStyle(color: AppColors.textSecondary, fontSize: 14),
+                      style: const TextStyle(color: AppColors.textSecondary, fontSize: 14),
                       textAlign: TextAlign.center,
                     ),
                   ),
@@ -157,6 +158,14 @@ class ProfileScreen extends ConsumerWidget {
                     _showAboutDialog(context);
                   },
                 ),
+
+                // Narrator mode switch button (only for narrator users)
+                if (profile?['role'] == 'narrator' || profile?['role'] == 'admin')
+                  Padding(
+                    padding: const EdgeInsets.only(top: 16),
+                    child: _buildNarratorModeButton(context, ref),
+                  ),
+
                 const SizedBox(height: 16),
 
                 // Logout button
@@ -288,7 +297,7 @@ class ProfileScreen extends ConsumerWidget {
       context: context,
       builder: (context) => AlertDialog(
         backgroundColor: AppColors.surface,
-        title: const Text('مینا', style: TextStyle(color: AppColors.textPrimary)),
+        title: const Text('پرستو', style: TextStyle(color: AppColors.textPrimary)),
         content: const Column(
           mainAxisSize: MainAxisSize.min,
           crossAxisAlignment: CrossAxisAlignment.start,
@@ -310,6 +319,32 @@ class ProfileScreen extends ConsumerWidget {
       ),
     );
   }
+
+  Widget _buildNarratorModeButton(BuildContext context, WidgetRef ref) {
+    return SizedBox(
+      width: double.infinity,
+      child: ElevatedButton.icon(
+        onPressed: () {
+          ref.read(appModeProvider.notifier).state = AppMode.narrator;
+        },
+        icon: const Icon(Icons.mic, color: Colors.white),
+        label: const Text(
+          'رفتن به داشبورد راوی',
+          style: TextStyle(
+            color: Colors.white,
+            fontWeight: FontWeight.w600,
+          ),
+        ),
+        style: ElevatedButton.styleFrom(
+          backgroundColor: AppColors.primary,
+          padding: const EdgeInsets.symmetric(vertical: 14),
+          shape: RoundedRectangleBorder(
+            borderRadius: BorderRadius.circular(12),
+          ),
+        ),
+      ),
+    );
+  }
 }
 
 // ============================================
@@ -365,13 +400,13 @@ class _ListeningStatsCard extends ConsumerWidget {
               // Header with listener level
               Row(
                 children: [
-                  Icon(
+                  const Icon(
                     Icons.headphones,
                     size: 20,
                     color: AppColors.primary,
                   ),
                   const SizedBox(width: 8),
-                  Text(
+                  const Text(
                     'آمار گوش دادن',
                     style: TextStyle(
                       fontSize: 16,
@@ -397,7 +432,7 @@ class _ListeningStatsCard extends ConsumerWidget {
                         const SizedBox(width: 4),
                         Text(
                           stats.listenerLevel,
-                          style: TextStyle(
+                          style: const TextStyle(
                             fontSize: 12,
                             color: AppColors.primary,
                             fontWeight: FontWeight.w500,
@@ -482,7 +517,7 @@ class _ListeningStatsCard extends ConsumerWidget {
                   child: Row(
                     mainAxisSize: MainAxisSize.min,
                     children: [
-                      Icon(
+                      const Icon(
                         Icons.check_circle_outline,
                         size: 16,
                         color: AppColors.success,
@@ -490,7 +525,7 @@ class _ListeningStatsCard extends ConsumerWidget {
                       const SizedBox(width: 6),
                       Text(
                         '${stats.booksCompleted} کتاب تمام شده',
-                        style: TextStyle(
+                        style: const TextStyle(
                           fontSize: 13,
                           color: AppColors.success,
                           fontWeight: FontWeight.w500,
@@ -506,7 +541,7 @@ class _ListeningStatsCard extends ConsumerWidget {
                 const SizedBox(height: 16),
                 const Divider(height: 1, color: AppColors.surfaceLight),
                 const SizedBox(height: 16),
-                Text(
+                const Text(
                   'دستاوردها',
                   style: TextStyle(
                     fontSize: 14,
diff --git a/lib/screens/listener/reviews_screen.dart b/lib/screens/listener/reviews_screen.dart
index c60860c..fa8df56 100644
--- a/lib/screens/listener/reviews_screen.dart
+++ b/lib/screens/listener/reviews_screen.dart
@@ -68,7 +68,7 @@ class _ReviewsScreenState extends ConsumerState<ReviewsScreen> {
             decoration: BoxDecoration(color: AppColors.surface, borderRadius: BorderRadius.circular(12)),
             child: Row(children: [Text(widget.averageRating.toStringAsFixed(1), style: const TextStyle(fontSize: 36, fontWeight: FontWeight.bold, color: AppColors.textPrimary)),
               const SizedBox(width: 12), Column(crossAxisAlignment: CrossAxisAlignment.start, children: [RatingStars(rating: widget.averageRating, size: 20),
-                const SizedBox(height: 4), Text('از ${widget.reviewCount} نظر', style: TextStyle(color: AppColors.textSecondary, fontSize: 12))])])))),
+                const SizedBox(height: 4), Text('از ${widget.reviewCount} نظر', style: const TextStyle(color: AppColors.textSecondary, fontSize: 12))])])))),
           _reviews.isEmpty
             ? SliverFillRemaining(child: Center(child: Column(mainAxisAlignment: MainAxisAlignment.center, children: [
                 Icon(Icons.rate_review_outlined, size: 64, color: AppColors.textTertiary.withOpacity(0.5)),
diff --git a/lib/screens/listener/search_screen.dart b/lib/screens/listener/search_screen.dart
index 429e4ee..4e389fd 100644
--- a/lib/screens/listener/search_screen.dart
+++ b/lib/screens/listener/search_screen.dart
@@ -66,8 +66,11 @@ class _SearchScreenState extends ConsumerState<SearchScreen> {
     // Normalize the query for better Farsi matching
     final normalizedQuery = FarsiUtils.normalizeSearchQuery(query);
 
-    // Allow search with just category filter (no text query)
-    if (normalizedQuery.isEmpty && _selectedCategoryId == null) {
+    // NOTE(Issue 2 fix): Allow search with just price filter (no text, no category).
+    // If no query, no category, AND no price filter selected, show initial state.
+    // But if price filter is set (e.g., "رایگان"), perform the filtered search.
+    final hasAnyFilter = _selectedCategoryId != null || _priceFilter != PriceFilter.all;
+    if (normalizedQuery.isEmpty && !hasAnyFilter) {
       setState(() {
         _results = [];
         _hasSearched = false;
@@ -189,9 +192,10 @@ class _SearchScreenState extends ConsumerState<SearchScreen> {
   void _onPriceFilterChanged(PriceFilter filter) {
     if (_priceFilter == filter) return;
     setState(() => _priceFilter = filter);
-    if (_hasSearched || _selectedCategoryId != null) {
-      _performSearch();
-    }
+    // NOTE(Issue 2 fix): Always perform search when price filter changes.
+    // If user taps "رایگان" without text query, show all free audiobooks.
+    // This makes filters work independently of the search text field.
+    _performSearch();
   }
 
   void _onSortChanged(SortOption sort) {
@@ -294,7 +298,8 @@ class _SearchScreenState extends ConsumerState<SearchScreen> {
                           onRetry: _retrySearch,
                           compact: true,
                         )
-                      : !_hasSearched && _selectedCategoryId == null
+                      // NOTE(Issue 2 fix): Show initial state only if no search AND no filters active
+                      : !_hasSearched && !_hasActiveFilters
                           ? _buildInitialState()
                           : _results.isEmpty
                               ? _buildEmptyState()
diff --git a/lib/screens/listener/settings_screen.dart b/lib/screens/listener/settings_screen.dart
index 5f2b1d6..7ad29d1 100644
--- a/lib/screens/listener/settings_screen.dart
+++ b/lib/screens/listener/settings_screen.dart
@@ -1,7 +1,10 @@
+import 'dart:io';
 import 'package:flutter/material.dart';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
 import 'package:shared_preferences/shared_preferences.dart';
 import 'package:myna/theme/app_theme.dart';
+import 'package:myna/providers/audio_provider.dart';
+import 'package:myna/screens/debug/notification_diagnostics_screen.dart';
 
 /// Settings keys for SharedPreferences
 class SettingsKeys {
@@ -113,11 +116,63 @@ class SettingsNotifier extends StateNotifier<SettingsState> {
   }
 }
 
-class SettingsScreen extends ConsumerWidget {
+class SettingsScreen extends ConsumerStatefulWidget {
   const SettingsScreen({super.key});
 
   @override
-  Widget build(BuildContext context, WidgetRef ref) {
+  ConsumerState<SettingsScreen> createState() => _SettingsScreenState();
+}
+
+class _SettingsScreenState extends ConsumerState<SettingsScreen> {
+  // Hidden debug mode: tap version 7 times to unlock
+  int _versionTapCount = 0;
+  DateTime? _lastTapTime;
+  static const _tapThreshold = Duration(milliseconds: 500);
+  static const _requiredTaps = 7;
+
+  void _onVersionTap() {
+    final now = DateTime.now();
+
+    // Reset count if too much time has passed since last tap
+    if (_lastTapTime != null && now.difference(_lastTapTime!) > _tapThreshold) {
+      _versionTapCount = 0;
+    }
+
+    _lastTapTime = now;
+    _versionTapCount++;
+
+    if (_versionTapCount >= _requiredTaps) {
+      _versionTapCount = 0;
+      // Only show on Android - diagnostics are Android-specific
+      if (Platform.isAndroid) {
+        Navigator.push(
+          context,
+          MaterialPageRoute<void>(
+            builder: (_) => const NotificationDiagnosticsScreen(),
+          ),
+        );
+      } else {
+        ScaffoldMessenger.of(context).showSnackBar(
+          const SnackBar(
+            content: Text('Notification diagnostics only available on Android'),
+            duration: Duration(seconds: 2),
+          ),
+        );
+      }
+    } else if (_versionTapCount >= 4) {
+      // Give a hint after 4 taps
+      ScaffoldMessenger.of(context).showSnackBar(
+        SnackBar(
+          content: Text('${_requiredTaps - _versionTapCount} more taps to unlock diagnostics'),
+          duration: const Duration(milliseconds: 500),
+          behavior: SnackBarBehavior.floating,
+        ),
+      );
+    }
+  }
+
+  @override
+  Widget build(BuildContext context) {
     final settings = ref.watch(settingsProvider);
     final notifier = ref.read(settingsProvider.notifier);
 
@@ -146,7 +201,11 @@ class SettingsScreen extends ConsumerWidget {
                       title: 'پخش خودکار فصل بعدی',
                       subtitle: 'پس از اتمام هر فصل، فصل بعدی پخش شود',
                       value: settings.autoPlayNext,
-                      onChanged: notifier.setAutoPlayNext,
+                      onChanged: (value) async {
+                        await notifier.setAutoPlayNext(value);
+                        // Also update the cached value in audio provider for fast access
+                        ref.read(audioProvider.notifier).updateAutoPlayNextCache(value);
+                      },
                     ),
                     const Divider(height: 1, color: AppColors.border),
                     _buildSwitchTile(
@@ -193,11 +252,7 @@ class SettingsScreen extends ConsumerWidget {
                   _buildSectionHeader('درباره'),
                   const SizedBox(height: 8),
                   _buildCard([
-                    _buildInfoTile(
-                      icon: Icons.info_outline,
-                      title: 'نسخه برنامه',
-                      value: '۱.۰.۰',
-                    ),
+                    _buildVersionTile(),
                   ]),
                   const SizedBox(height: 32),
                 ],
@@ -206,6 +261,19 @@ class SettingsScreen extends ConsumerWidget {
     );
   }
 
+  /// Version tile with hidden 7-tap to unlock notification diagnostics
+  Widget _buildVersionTile() {
+    return ListTile(
+      leading: const Icon(Icons.info_outline, color: AppColors.primary),
+      title: const Text('نسخه برنامه', style: TextStyle(color: AppColors.textPrimary)),
+      trailing: const Text(
+        '۱.۰.۰',
+        style: TextStyle(color: AppColors.textTertiary),
+      ),
+      onTap: _onVersionTap,
+    );
+  }
+
   Widget _buildSectionHeader(String title) {
     return Text(
       title,
@@ -218,7 +286,7 @@ class SettingsScreen extends ConsumerWidget {
   }
 
   Widget _buildCard(List<Widget> children) {
-    return Container(
+    return DecoratedBox(
       decoration: BoxDecoration(
         color: AppColors.surface,
         borderRadius: BorderRadius.circular(12),
@@ -415,18 +483,4 @@ class SettingsScreen extends ConsumerWidget {
     );
   }
 
-  Widget _buildInfoTile({
-    required IconData icon,
-    required String title,
-    required String value,
-  }) {
-    return ListTile(
-      leading: Icon(icon, color: AppColors.primary),
-      title: Text(title, style: const TextStyle(color: AppColors.textPrimary)),
-      trailing: Text(
-        value,
-        style: const TextStyle(color: AppColors.textTertiary),
-      ),
-    );
-  }
 }
diff --git a/lib/screens/listener/shelf_detail_screen.dart b/lib/screens/listener/shelf_detail_screen.dart
index 8d5150c..c9fb75a 100644
--- a/lib/screens/listener/shelf_detail_screen.dart
+++ b/lib/screens/listener/shelf_detail_screen.dart
@@ -87,7 +87,7 @@ class ShelfDetailScreen extends ConsumerWidget {
                       padding: const EdgeInsets.all(16),
                       child: Text(
                         shelf['description_fa'] as String,
-                        style: TextStyle(color: AppColors.textSecondary, fontSize: 14),
+                        style: const TextStyle(color: AppColors.textSecondary, fontSize: 14),
                       ),
                     ),
 
@@ -125,7 +125,7 @@ class ShelfDetailScreen extends ConsumerWidget {
           builder: (_) => AudiobookDetailScreen(audiobookId: book['id'] as int),
         ),
       ),
-      child: Container(
+      child: DecoratedBox(
         decoration: BoxDecoration(
           color: AppColors.surface,
           borderRadius: BorderRadius.circular(12),
@@ -176,11 +176,14 @@ class ShelfDetailScreen extends ConsumerWidget {
                         final author = (book['author_fa'] as String?) ??
                             (book['author_en'] as String?) ??
                             '';
-                        final narrator = book['profiles'] != null
+                        // Check if this book is branded as "پرستو"
+                        final isParastoBrand = (book['is_parasto_brand'] as bool?) ?? false;
+                        final narratorRaw = book['profiles'] != null
                             ? ((book['profiles']['display_name'] as String?) ??
                                 (book['profiles']['full_name'] as String?) ??
                                 '')
                             : '';
+                        final narrator = isParastoBrand ? 'پرستو' : narratorRaw;
                         final displayText = author.isNotEmpty ? author : narrator;
                         if (displayText.isEmpty) return const SizedBox.shrink();
                         return Text(
@@ -221,7 +224,7 @@ class ShelfDetailScreen extends ConsumerWidget {
                         else
                           Text(
                             _formatPriceUsd((book['price_toman'] as num?)?.toDouble() ?? 0),
-                            style: TextStyle(color: AppColors.primary, fontSize: 10),
+                            style: const TextStyle(color: AppColors.primary, fontSize: 10),
                           ),
                       ],
                     ),
diff --git a/lib/screens/narrator/audio_guidelines_screen.dart b/lib/screens/narrator/audio_guidelines_screen.dart
index 696b1f2..12ea1c7 100644
--- a/lib/screens/narrator/audio_guidelines_screen.dart
+++ b/lib/screens/narrator/audio_guidelines_screen.dart
@@ -239,11 +239,11 @@ class AudioGuidelinesScreen extends StatelessWidget {
               color: AppColors.primary.withOpacity(0.1),
               borderRadius: BorderRadius.circular(8),
             ),
-            child: Row(
+            child: const Row(
               children: [
                 Icon(Icons.lightbulb_outline, color: AppColors.primary, size: 20),
-                const SizedBox(width: 8),
-                const Expanded(
+                SizedBox(width: 8),
+                Expanded(
                   child: Text(
                     'با این تنظیمات، هر ساعت صدا حدود ۳۰ مگابایت خواهد شد.',
                     style: TextStyle(
@@ -357,7 +357,7 @@ class AudioGuidelinesScreen extends StatelessWidget {
               const SizedBox(height: 4),
               Text(
                 description,
-                style: TextStyle(
+                style: const TextStyle(
                   color: AppColors.textSecondary,
                   fontSize: 13,
                   height: 1.4,
@@ -445,7 +445,7 @@ class AudioGuidelinesScreen extends StatelessWidget {
                   child: Center(
                     child: Text(
                       '${entry.key + 1}',
-                      style: TextStyle(
+                      style: const TextStyle(
                         color: AppColors.primary,
                         fontSize: 11,
                         fontWeight: FontWeight.bold,
@@ -457,7 +457,7 @@ class AudioGuidelinesScreen extends StatelessWidget {
                 Expanded(
                   child: Text(
                     entry.value,
-                    style: TextStyle(
+                    style: const TextStyle(
                       color: AppColors.textSecondary,
                       fontSize: 13,
                     ),
@@ -522,7 +522,7 @@ class AudioGuidelinesScreen extends StatelessWidget {
         Expanded(
           child: Text(
             tip,
-            style: TextStyle(
+            style: const TextStyle(
               color: AppColors.textSecondary,
               fontSize: 13,
               height: 1.4,
diff --git a/lib/screens/narrator/chapter_management_screen.dart b/lib/screens/narrator/chapter_management_screen.dart
index 3d32be7..e758491 100644
--- a/lib/screens/narrator/chapter_management_screen.dart
+++ b/lib/screens/narrator/chapter_management_screen.dart
@@ -1,3 +1,4 @@
+import 'dart:typed_data';
 import 'package:flutter/material.dart';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
 import 'package:supabase_flutter/supabase_flutter.dart';
@@ -9,6 +10,27 @@ import 'package:myna/utils/app_logger.dart';
 import 'package:myna/utils/audio_validator.dart';
 import 'package:myna/screens/narrator/audio_guidelines_screen.dart';
 
+/// Model for a chapter pending bulk upload (narrator-only)
+class _NarratorChapterToUpload {
+  String titleFa;
+  String? titleEn;
+  bool isPreview = false;
+  final String fileName;
+  final int fileSize;
+  final Uint8List bytes;
+  bool isUploading = false;
+  bool isUploaded = false;
+  String? error;
+  double uploadProgress = 0;
+
+  _NarratorChapterToUpload({
+    required this.titleFa,
+    required this.fileName,
+    required this.fileSize,
+    required this.bytes,
+  });
+}
+
 class ChapterManagementScreen extends ConsumerStatefulWidget {
   final int audiobookId;
   final String audiobookTitle;
@@ -32,6 +54,11 @@ class _ChapterManagementScreenState extends ConsumerState<ChapterManagementScree
   double _uploadProgress = 0;
   String _uploadingChapterName = '';
 
+  // Bulk upload state (narrator)
+  bool _isBulkUploading = false;
+  int _bulkUploadedCount = 0;
+  int _bulkTotalCount = 0;
+
   // Controllers for manual order input
   final Map<int, TextEditingController> _orderControllers = {};
 
@@ -326,18 +353,29 @@ class _ChapterManagementScreenState extends ConsumerState<ChapterManagementScree
           ? 1
           : (_chapters.map((c) => (c['chapter_index'] as int?) ?? 0).reduce((a, b) => a > b ? a : b) + 1);
 
-      // Create chapter record
-      await Supabase.instance.client.from('chapters').insert({
-        'audiobook_id': widget.audiobookId,
-        'title_fa': chapterInfo['title_fa'],
-        'title_en': chapterInfo['title_en'],
-        'chapter_index': nextIndex,
-        'audio_storage_path': path,
-        'duration_seconds': 0, // Will be updated when audio is processed
-        'file_size_bytes': file.size,
-        'audio_format': extension,
-        'is_preview': (chapterInfo['is_preview'] as bool?) ?? false,
-      });
+      // Create chapter record - with orphan file cleanup on failure
+      try {
+        await Supabase.instance.client.from('chapters').insert({
+          'audiobook_id': widget.audiobookId,
+          'title_fa': chapterInfo['title_fa'],
+          'title_en': chapterInfo['title_en'],
+          'chapter_index': nextIndex,
+          'audio_storage_path': path,
+          'duration_seconds': 0, // Will be updated when audio is processed
+          'file_size_bytes': file.size,
+          'audio_format': extension,
+          'is_preview': (chapterInfo['is_preview'] as bool?) ?? false,
+        });
+      } catch (dbError) {
+        // DB insert failed - clean up orphan file from storage
+        AppLogger.w('Chapter DB insert failed, cleaning up uploaded file: $path');
+        try {
+          await Supabase.instance.client.storage.from(Env.audioBucket).remove([path]);
+        } catch (cleanupError) {
+          AppLogger.e('Failed to cleanup orphan audio file: $path', error: cleanupError);
+        }
+        rethrow;
+      }
 
       setState(() => _uploadProgress = 0.9);
 
@@ -362,7 +400,7 @@ class _ChapterManagementScreenState extends ConsumerState<ChapterManagementScree
       }
     } catch (e) {
       AppLogger.e('Upload error', error: e);
-      setState(() => _error = 'خطا در آپلود: $e');
+      setState(() => _error = AudioValidator.getUploadErrorMessage(e));
     } finally {
       setState(() {
         _isUploading = false;
@@ -372,6 +410,232 @@ class _ChapterManagementScreenState extends ConsumerState<ChapterManagementScree
     }
   }
 
+  /// Bulk upload multiple chapters at once (narrator feature)
+  Future<void> _addChaptersBulk() async {
+    try {
+      // Pick multiple audio files
+      final result = await FilePicker.platform.pickFiles(
+        type: FileType.custom,
+        allowedExtensions: AudioValidator.getAllowedExtensions(),
+        allowMultiple: true,
+        withData: true,
+      );
+
+      if (result == null || result.files.isEmpty) {
+        AppLogger.d('Narrator bulk upload: No files selected');
+        return;
+      }
+
+      AppLogger.d('Narrator bulk upload: selected ${result.files.length} files for audiobook ${widget.audiobookId}');
+
+      // Validate and prepare chapters
+      final chaptersToUpload = <_NarratorChapterToUpload>[];
+      final validationErrors = <String>[];
+
+      for (int i = 0; i < result.files.length; i++) {
+        final file = result.files[i];
+        AppLogger.d('Narrator bulk upload: file[$i] = ${file.name}, size=${file.size}');
+
+        if (file.bytes == null) {
+          validationErrors.add('${file.name}: خطا در خواندن فایل');
+          continue;
+        }
+
+        // Validate audio file
+        final validation = AudioValidator.validate(
+          fileName: file.name,
+          fileSizeBytes: file.size,
+          mimeType: file.extension,
+        );
+
+        if (!validation.isValid) {
+          validationErrors.add('${file.name}: ${validation.errorMessage?.split('\n').first ?? 'فرمت نامعتبر'}');
+          continue;
+        }
+
+        // Generate title from file name
+        final titleFa = _generateTitleFromFileName(file.name, _chapters.length + chaptersToUpload.length + 1);
+
+        chaptersToUpload.add(_NarratorChapterToUpload(
+          titleFa: titleFa,
+          fileName: file.name,
+          fileSize: file.size,
+          bytes: file.bytes!,
+        ));
+      }
+
+      // Show validation errors if any
+      if (validationErrors.isNotEmpty && mounted) {
+        ScaffoldMessenger.of(context).showSnackBar(
+          SnackBar(
+            content: Text('${validationErrors.length} فایل رد شد: ${validationErrors.first}'),
+            backgroundColor: AppColors.warning,
+            duration: const Duration(seconds: 4),
+          ),
+        );
+      }
+
+      if (chaptersToUpload.isEmpty) {
+        if (mounted) {
+          setState(() => _error = 'هیچ فایل معتبری انتخاب نشد');
+        }
+        return;
+      }
+
+      // Show bulk upload confirmation/editing dialog
+      final confirmed = await _showBulkUploadDialog(chaptersToUpload);
+      if (confirmed != true) return;
+
+      // Start bulk upload
+      setState(() {
+        _isBulkUploading = true;
+        _bulkUploadedCount = 0;
+        _bulkTotalCount = chaptersToUpload.length;
+        _error = null;
+      });
+
+      final user = Supabase.instance.client.auth.currentUser;
+      if (user == null) {
+        setState(() {
+          _isBulkUploading = false;
+          _error = 'کاربر وارد نشده است';
+        });
+        return;
+      }
+
+      int successCount = 0;
+      int failCount = 0;
+
+      // Get current max chapter index
+      int nextIndex = _chapters.isEmpty
+          ? 1
+          : (_chapters.map((c) => (c['chapter_index'] as int?) ?? 0).reduce((a, b) => a > b ? a : b) + 1);
+
+      // Upload chapters sequentially (to avoid overloading)
+      for (int i = 0; i < chaptersToUpload.length; i++) {
+        final chapter = chaptersToUpload[i];
+        AppLogger.d('Narrator bulk upload: uploading ${i + 1}/${chaptersToUpload.length}: ${chapter.fileName}');
+
+        try {
+          // Upload audio file
+          final timestamp = DateTime.now().millisecondsSinceEpoch;
+          final extension = chapter.fileName.split('.').last.toLowerCase();
+          final path = '${user.id}/${widget.audiobookId}/$timestamp.$extension';
+
+          await Supabase.instance.client.storage
+              .from(Env.audioBucket)
+              .uploadBinary(path, chapter.bytes);
+
+          // Create chapter record - with orphan file cleanup on failure
+          try {
+            await Supabase.instance.client.from('chapters').insert({
+              'audiobook_id': widget.audiobookId,
+              'title_fa': chapter.titleFa.trim(),
+              'title_en': chapter.titleEn?.trim().isEmpty == true ? null : chapter.titleEn?.trim(),
+              'chapter_index': nextIndex,
+              'audio_storage_path': path,
+              'duration_seconds': 0,
+              'file_size_bytes': chapter.fileSize,
+              'audio_format': extension,
+              'is_preview': chapter.isPreview,
+            });
+          } catch (dbError) {
+            // DB insert failed - clean up orphan file from storage
+            AppLogger.w('Bulk upload: DB insert failed, cleaning up file: $path');
+            try {
+              await Supabase.instance.client.storage.from(Env.audioBucket).remove([path]);
+            } catch (cleanupError) {
+              AppLogger.e('Failed to cleanup orphan audio file: $path', error: cleanupError);
+            }
+            rethrow;
+          }
+
+          nextIndex++;
+          successCount++;
+
+          if (mounted) {
+            setState(() => _bulkUploadedCount = successCount);
+          }
+
+          AppLogger.d('Narrator bulk upload: chapter ${chapter.fileName} uploaded successfully');
+        } catch (e) {
+          AppLogger.e('Narrator bulk upload: failed to upload ${chapter.fileName}', error: e);
+          failCount++;
+          // Continue with next file (best-effort)
+        }
+      }
+
+      // Update audiobook chapter count
+      if (successCount > 0) {
+        final newTotalCount = _chapters.length + successCount;
+        await Supabase.instance.client
+            .from('audiobooks')
+            .update({'chapter_count': newTotalCount})
+            .eq('id', widget.audiobookId);
+      }
+
+      // Reload chapters
+      await _loadChapters();
+
+      if (mounted) {
+        setState(() => _isBulkUploading = false);
+
+        if (failCount == 0) {
+          ScaffoldMessenger.of(context).showSnackBar(
+            SnackBar(
+              content: Text('همه $successCount فصل با موفقیت آپلود شدند'),
+              backgroundColor: AppColors.success,
+            ),
+          );
+        } else {
+          ScaffoldMessenger.of(context).showSnackBar(
+            SnackBar(
+              content: Text('$successCount فصل آپلود شد، $failCount فایل خطا داشت'),
+              backgroundColor: AppColors.warning,
+            ),
+          );
+        }
+      }
+    } catch (e) {
+      AppLogger.e('Narrator bulk upload error', error: e);
+      if (mounted) {
+        setState(() {
+          _isBulkUploading = false;
+          _error = AudioValidator.getUploadErrorMessage(e);
+        });
+      }
+    }
+  }
+
+  /// Generate a default title from file name
+  String _generateTitleFromFileName(String fileName, int index) {
+    // Remove extension
+    final nameWithoutExt = fileName.replaceAll(RegExp(r'\.[^.]+$'), '');
+    // Clean up common patterns
+    final cleaned = nameWithoutExt
+        .replaceAll(RegExp(r'[-_]'), ' ')
+        .replaceAll(RegExp(r'\s+'), ' ')
+        .trim();
+
+    if (cleaned.isEmpty) {
+      return 'فصل $index';
+    }
+    return cleaned;
+  }
+
+  /// Show dialog for bulk upload confirmation and editing
+  Future<bool?> _showBulkUploadDialog(List<_NarratorChapterToUpload> chapters) async {
+    return showDialog<bool>(
+      context: context,
+      barrierDismissible: false,
+      builder: (dialogContext) => _BulkUploadDialog(
+        chapters: chapters,
+        onConfirm: () => Navigator.pop(dialogContext, true),
+        onCancel: () => Navigator.pop(dialogContext, false),
+      ),
+    );
+  }
+
   Future<void> _showValidationErrorDialog(String errorMessage) async {
     return showDialog<void>(
       context: context,
@@ -379,11 +643,11 @@ class _ChapterManagementScreenState extends ConsumerState<ChapterManagementScree
         textDirection: TextDirection.rtl,
         child: AlertDialog(
           backgroundColor: AppColors.surface,
-          title: Row(
+          title: const Row(
             children: [
               Icon(Icons.warning_amber_rounded, color: AppColors.error, size: 28),
-              const SizedBox(width: 8),
-              const Text('خطای فایل صوتی'),
+              SizedBox(width: 8),
+              Text('خطای فایل صوتی'),
             ],
           ),
           content: SingleChildScrollView(
@@ -401,13 +665,19 @@ class _ChapterManagementScreenState extends ConsumerState<ChapterManagementScree
                 const SizedBox(height: 16),
                 OutlinedButton.icon(
                   onPressed: () {
+                    // FIX: Close dialog first, then push new route after frame completes
+                    // This avoids _debugLocked error from navigating while navigator is locked
                     Navigator.pop(context);
-                    Navigator.push(
-                      context,
-                      MaterialPageRoute<void>(
-                        builder: (_) => const AudioGuidelinesScreen(),
-                      ),
-                    );
+                    WidgetsBinding.instance.addPostFrameCallback((_) {
+                      if (mounted) {
+                        Navigator.push(
+                          this.context, // Use widget context, not dialog context
+                          MaterialPageRoute<void>(
+                            builder: (_) => const AudioGuidelinesScreen(),
+                          ),
+                        );
+                      }
+                    });
                   },
                   icon: const Icon(Icons.help_outline),
                   label: const Text('مشاهده راهنمای کامل'),
@@ -468,7 +738,7 @@ class _ChapterManagementScreenState extends ConsumerState<ChapterManagementScree
                               const SizedBox(height: 2),
                               Text(
                                 Formatters.formatFileSize(fileSize),
-                                style: TextStyle(
+                                style: const TextStyle(
                                   fontSize: 11,
                                   color: AppColors.textTertiary,
                                 ),
@@ -514,14 +784,14 @@ class _ChapterManagementScreenState extends ConsumerState<ChapterManagementScree
                       ),
                       const Text('نمونه رایگان'),
                       const SizedBox(width: 8),
-                      Icon(
+                      const Icon(
                         Icons.info_outline,
                         size: 16,
                         color: AppColors.textTertiary,
                       ),
                     ],
                   ),
-                  Text(
+                  const Text(
                     'فصل‌های نمونه برای همه کاربران قابل پخش است',
                     style: TextStyle(
                       fontSize: 11,
@@ -878,23 +1148,23 @@ class _ChapterManagementScreenState extends ConsumerState<ChapterManagementScree
               icon: const Icon(Icons.help_outline),
               tooltip: 'راهنمای صدا',
             ),
-            if (_chapters.isNotEmpty)
-              TextButton.icon(
-                onPressed: _isLoading ? null : _submitForReview,
-                icon: const Icon(Icons.send, size: 18),
-                label: const Text('ارسال'),
-              ),
           ],
         ),
+        // LAYOUT FIX: All actions consolidated into a single bottom bar.
+        // Previously had overlapping FAB + bottom bar which caused UI issues on small screens.
+        // Now using Column + Expanded + fixed bottom bar pattern for robust layout.
         body: Column(
           children: [
-            // Upload progress
+            // Upload progress (single file)
             if (_isUploading) _buildUploadProgress(),
 
+            // Bulk upload progress
+            if (_isBulkUploading) _buildBulkUploadProgress(),
+
             // Error message
             if (_error != null) _buildError(),
 
-            // Chapters list
+            // Chapters list (scrollable, takes remaining space)
             Expanded(
               child: _isLoading
                   ? const Center(
@@ -905,21 +1175,30 @@ class _ChapterManagementScreenState extends ConsumerState<ChapterManagementScree
                       : _buildChaptersList(),
             ),
 
-            // Save order button (only show when chapters exist)
-            if (_chapters.length > 1) _buildSaveOrderButton(),
+            // Unified bottom action bar (no overlapping FAB)
+            _buildBottomActionBar(),
           ],
         ),
-        floatingActionButton: FloatingActionButton.extended(
-          onPressed: _isUploading ? null : _addChapter,
-          backgroundColor: _isUploading ? AppColors.surfaceLight : AppColors.primary,
-          icon: const Icon(Icons.add),
-          label: const Text('افزودن فصل'),
-        ),
+        // No floatingActionButton - all actions are in the bottom bar
       ),
     );
   }
 
-  Widget _buildSaveOrderButton() {
+  /// Unified bottom action bar with all actions:
+  /// - Add chapter buttons (single + bulk)
+  /// - Save order button (when >1 chapter)
+  /// - Submit for review button (when chapters exist)
+  ///
+  /// FIX: Prevents overlapping buttons on small screens by:
+  /// 1. Using SafeArea with proper padding
+  /// 2. All buttons in a single Column (no floating/positioned elements)
+  /// 3. Keyboard dismissal before actions
+  /// 4. Responsive layout with LayoutBuilder for very small screens
+  Widget _buildBottomActionBar() {
+    final bool isUploadDisabled = _isUploading || _isBulkUploading;
+    final bool hasChapters = _chapters.isNotEmpty;
+    final bool hasMultipleChapters = _chapters.length > 1;
+
     return Container(
       padding: EdgeInsets.only(
         left: 16,
@@ -927,44 +1206,190 @@ class _ChapterManagementScreenState extends ConsumerState<ChapterManagementScree
         top: 12,
         bottom: MediaQuery.of(context).padding.bottom + 12,
       ),
-      decoration: BoxDecoration(
+      decoration: const BoxDecoration(
         color: AppColors.surface,
         border: Border(
           top: BorderSide(color: AppColors.border),
         ),
       ),
-      child: Row(
-        children: [
-          Expanded(
-            child: Text(
-              'شماره ترتیب هر فصل را وارد کنید',
-              style: TextStyle(
-                color: AppColors.textSecondary,
-                fontSize: 12,
-              ),
-            ),
-          ),
-          const SizedBox(width: 12),
-          ElevatedButton.icon(
-            onPressed: _isSavingOrder ? null : _saveManualOrder,
-            style: ElevatedButton.styleFrom(
-              backgroundColor: AppColors.primary,
-              foregroundColor: AppColors.background,
-              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
-            ),
-            icon: _isSavingOrder
-                ? const SizedBox(
-                    width: 18,
-                    height: 18,
-                    child: CircularProgressIndicator(
-                      strokeWidth: 2,
-                      color: AppColors.background,
+      child: LayoutBuilder(
+        builder: (context, constraints) {
+          // Use compact layout on very small screens (< 300px width)
+          final bool isCompact = constraints.maxWidth < 300;
+
+          return Column(
+            mainAxisSize: MainAxisSize.min,
+            children: [
+              // Row 1: Add chapter buttons (always visible)
+              // On very small screens, stack vertically
+              if (isCompact) ...[
+                // Compact: Stack buttons vertically
+                SizedBox(
+                  width: double.infinity,
+                  child: ElevatedButton.icon(
+                    onPressed: isUploadDisabled ? null : () {
+                      FocusScope.of(context).unfocus();
+                      _addChapter();
+                    },
+                    style: ElevatedButton.styleFrom(
+                      backgroundColor: isUploadDisabled ? AppColors.surfaceLight : AppColors.primary,
+                      foregroundColor: Colors.white,
+                      padding: const EdgeInsets.symmetric(vertical: 12),
+                      minimumSize: const Size(44, 44), // Minimum touch target
                     ),
-                  )
-                : const Icon(Icons.save, size: 18),
-            label: const Text('ذخیره ترتیب فصل‌ها'),
-          ),
-        ],
+                    icon: const Icon(Icons.add, size: 20),
+                    label: const Text('افزودن فصل', style: TextStyle(fontSize: 14)),
+                  ),
+                ),
+                const SizedBox(height: 8),
+                SizedBox(
+                  width: double.infinity,
+                  child: OutlinedButton.icon(
+                    onPressed: isUploadDisabled ? null : () {
+                      FocusScope.of(context).unfocus();
+                      _addChaptersBulk();
+                    },
+                    style: OutlinedButton.styleFrom(
+                      foregroundColor: isUploadDisabled ? AppColors.textTertiary : AppColors.primary,
+                      side: BorderSide(
+                        color: isUploadDisabled ? AppColors.border : AppColors.primary,
+                      ),
+                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
+                      minimumSize: const Size(44, 44),
+                    ),
+                    icon: const Icon(Icons.library_add, size: 18),
+                    label: const Text('آپلود چند فصل', style: TextStyle(fontSize: 12)),
+                  ),
+                ),
+              ] else ...[
+                // Normal: Side by side
+                Row(
+                  children: [
+                    // Single chapter upload (primary action)
+                    Expanded(
+                      child: ElevatedButton.icon(
+                        onPressed: isUploadDisabled ? null : () {
+                          FocusScope.of(context).unfocus();
+                          _addChapter();
+                        },
+                        style: ElevatedButton.styleFrom(
+                          backgroundColor: isUploadDisabled ? AppColors.surfaceLight : AppColors.primary,
+                          foregroundColor: Colors.white,
+                          padding: const EdgeInsets.symmetric(vertical: 12),
+                          minimumSize: const Size(44, 44),
+                        ),
+                        icon: const Icon(Icons.add, size: 20),
+                        label: const Text('افزودن فصل', style: TextStyle(fontSize: 14)),
+                      ),
+                    ),
+                    const SizedBox(width: 12),
+                    // Bulk upload (secondary action)
+                    OutlinedButton.icon(
+                      onPressed: isUploadDisabled ? null : () {
+                        FocusScope.of(context).unfocus();
+                        _addChaptersBulk();
+                      },
+                      style: OutlinedButton.styleFrom(
+                        foregroundColor: isUploadDisabled ? AppColors.textTertiary : AppColors.primary,
+                        side: BorderSide(
+                          color: isUploadDisabled ? AppColors.border : AppColors.primary,
+                        ),
+                        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
+                        minimumSize: const Size(44, 44),
+                      ),
+                      icon: const Icon(Icons.library_add, size: 18),
+                      label: const Text('چند فصل', style: TextStyle(fontSize: 12)),
+                    ),
+                  ],
+                ),
+              ],
+
+              // Row 2: Save order (only when >1 chapter)
+              if (hasMultipleChapters) ...[
+                const SizedBox(height: 12),
+                Row(
+                  children: [
+                    Expanded(
+                      child: Text(
+                        'شماره ترتیب هر فصل را وارد کنید',
+                        style: TextStyle(
+                          color: AppColors.textSecondary,
+                          fontSize: isCompact ? 11 : 12,
+                        ),
+                      ),
+                    ),
+                    const SizedBox(width: 8),
+                    OutlinedButton.icon(
+                      onPressed: _isSavingOrder ? null : () {
+                        FocusScope.of(context).unfocus();
+                        _saveManualOrder();
+                      },
+                      style: OutlinedButton.styleFrom(
+                        foregroundColor: AppColors.primary,
+                        padding: EdgeInsets.symmetric(
+                          horizontal: isCompact ? 8 : 12,
+                          vertical: 8,
+                        ),
+                        minimumSize: const Size(44, 44),
+                      ),
+                      icon: _isSavingOrder
+                          ? const SizedBox(
+                              width: 16,
+                              height: 16,
+                              child: CircularProgressIndicator(
+                                strokeWidth: 2,
+                                color: AppColors.primary,
+                              ),
+                            )
+                          : const Icon(Icons.save, size: 16),
+                      label: Text(
+                        'ذخیره ترتیب',
+                        style: TextStyle(fontSize: isCompact ? 11 : 12),
+                      ),
+                    ),
+                  ],
+                ),
+              ],
+
+              // Row 3: Submit for review (only when chapters exist)
+              if (hasChapters) ...[
+                const SizedBox(height: 12),
+                SizedBox(
+                  width: double.infinity,
+                  child: ElevatedButton.icon(
+                    onPressed: _isLoading ? null : () {
+                      FocusScope.of(context).unfocus();
+                      _submitForReview();
+                    },
+                    style: ElevatedButton.styleFrom(
+                      backgroundColor: AppColors.warning,
+                      foregroundColor: Colors.white,
+                      padding: const EdgeInsets.symmetric(vertical: 14),
+                      minimumSize: const Size(44, 48),
+                    ),
+                    icon: _isLoading
+                        ? const SizedBox(
+                            width: 18,
+                            height: 18,
+                            child: CircularProgressIndicator(
+                              strokeWidth: 2,
+                              color: Colors.white,
+                            ),
+                          )
+                        : const Icon(Icons.send),
+                    label: Text(
+                      'ارسال برای بررسی',
+                      style: TextStyle(
+                        fontSize: isCompact ? 14 : 15,
+                        fontWeight: FontWeight.w600,
+                      ),
+                    ),
+                  ),
+                ),
+              ],
+            ],
+          );
+        },
       ),
     );
   }
@@ -1009,6 +1434,49 @@ class _ChapterManagementScreenState extends ConsumerState<ChapterManagementScree
     );
   }
 
+  Widget _buildBulkUploadProgress() {
+    return Container(
+      padding: const EdgeInsets.all(16),
+      color: AppColors.surface,
+      child: Column(
+        children: [
+          Row(
+            children: [
+              const SizedBox(
+                width: 20,
+                height: 20,
+                child: CircularProgressIndicator(
+                  strokeWidth: 2,
+                  color: AppColors.primary,
+                ),
+              ),
+              const SizedBox(width: 12),
+              Expanded(
+                child: Text(
+                  'آپلود دسته‌ای: $_bulkUploadedCount از $_bulkTotalCount فصل',
+                  style: const TextStyle(color: AppColors.textPrimary),
+                ),
+              ),
+              Text(
+                '$_bulkUploadedCount/$_bulkTotalCount',
+                style: const TextStyle(
+                  color: AppColors.primary,
+                  fontWeight: FontWeight.w600,
+                ),
+              ),
+            ],
+          ),
+          const SizedBox(height: 8),
+          LinearProgressIndicator(
+            value: _bulkTotalCount > 0 ? _bulkUploadedCount / _bulkTotalCount : 0,
+            backgroundColor: AppColors.surfaceLight,
+            color: AppColors.primary,
+          ),
+        ],
+      ),
+    );
+  }
+
   Widget _buildError() {
     return Container(
       padding: const EdgeInsets.all(12),
@@ -1055,7 +1523,7 @@ class _ChapterManagementScreenState extends ConsumerState<ChapterManagementScree
             ),
             const SizedBox(height: 8),
             const Text(
-              'روی دکمه + کلیک کنید تا فایل صوتی اضافه کنید',
+              'از دکمه‌های پایین صفحه برای افزودن فصل استفاده کنید',
               style: TextStyle(
                 color: AppColors.textTertiary,
                 fontSize: 13,
@@ -1073,11 +1541,11 @@ class _ChapterManagementScreenState extends ConsumerState<ChapterManagementScree
               ),
               child: Column(
                 children: [
-                  Row(
+                  const Row(
                     children: [
                       Icon(Icons.info_outline, color: AppColors.primary, size: 20),
-                      const SizedBox(width: 8),
-                      const Text(
+                      SizedBox(width: 8),
+                      Text(
                         'فرمت‌های مجاز',
                         style: TextStyle(
                           color: AppColors.textPrimary,
@@ -1088,8 +1556,8 @@ class _ChapterManagementScreenState extends ConsumerState<ChapterManagementScree
                   ),
                   const SizedBox(height: 8),
                   Text(
-                    'MP3 یا M4A • حداکثر ۵۰ مگابایت • حداکثر ۶۰ دقیقه',
-                    style: TextStyle(
+                    'MP3 یا M4A • حداکثر ${AudioValidator.kServerMaxFileSizeMB} مگابایت • حداکثر ۲۴۰ دقیقه',
+                    style: const TextStyle(
                       color: AppColors.textSecondary,
                       fontSize: 12,
                     ),
@@ -1110,7 +1578,7 @@ class _ChapterManagementScreenState extends ConsumerState<ChapterManagementScree
                 ],
               ),
             ),
-            const SizedBox(height: 80), // Space for FAB
+            const SizedBox(height: 16), // Bottom margin
           ],
         ),
       ),
@@ -1119,7 +1587,8 @@ class _ChapterManagementScreenState extends ConsumerState<ChapterManagementScree
 
   Widget _buildChaptersList() {
     return ReorderableListView.builder(
-      padding: const EdgeInsets.fromLTRB(16, 16, 16, 100),
+      // Bottom padding reduced since bottom bar is now part of Column layout
+      padding: const EdgeInsets.fromLTRB(16, 16, 16, 16),
       itemCount: _chapters.length,
       onReorder: _reorderChapters,
       itemBuilder: (context, index) {
@@ -1165,11 +1634,11 @@ class _ChapterManagementScreenState extends ConsumerState<ChapterManagementScree
                   ),
                   enabledBorder: OutlineInputBorder(
                     borderRadius: BorderRadius.circular(8),
-                    borderSide: BorderSide(color: AppColors.border, width: 1),
+                    borderSide: const BorderSide(color: AppColors.border, width: 1),
                   ),
                   focusedBorder: OutlineInputBorder(
                     borderRadius: BorderRadius.circular(8),
-                    borderSide: BorderSide(color: AppColors.primary, width: 1.5),
+                    borderSide: const BorderSide(color: AppColors.primary, width: 1.5),
                   ),
                 ),
               ),
@@ -1191,23 +1660,34 @@ class _ChapterManagementScreenState extends ConsumerState<ChapterManagementScree
                     overflow: TextOverflow.ellipsis,
                   ),
                   const SizedBox(height: 4),
-                  Row(
+                  Wrap(
+                    spacing: 8,
+                    runSpacing: 4,
+                    crossAxisAlignment: WrapCrossAlignment.center,
                     children: [
-                      Icon(Icons.access_time, size: 12, color: AppColors.textTertiary),
-                      const SizedBox(width: 4),
-                      Text(
-                        _formatDuration(chapter['duration_seconds'] as int?),
-                        style: TextStyle(color: AppColors.textTertiary, fontSize: 11),
+                      Row(
+                        mainAxisSize: MainAxisSize.min,
+                        children: [
+                          const Icon(Icons.access_time, size: 12, color: AppColors.textTertiary),
+                          const SizedBox(width: 4),
+                          Text(
+                            _formatDuration(chapter['duration_seconds'] as int?),
+                            style: const TextStyle(color: AppColors.textTertiary, fontSize: 11),
+                          ),
+                        ],
                       ),
-                      const SizedBox(width: 8),
-                      Icon(Icons.storage, size: 12, color: AppColors.textTertiary),
-                      const SizedBox(width: 4),
-                      Text(
-                        _formatFileSize(chapter['file_size_bytes'] as int?),
-                        style: TextStyle(color: AppColors.textTertiary, fontSize: 11),
+                      Row(
+                        mainAxisSize: MainAxisSize.min,
+                        children: [
+                          const Icon(Icons.storage, size: 12, color: AppColors.textTertiary),
+                          const SizedBox(width: 4),
+                          Text(
+                            _formatFileSize(chapter['file_size_bytes'] as int?),
+                            style: const TextStyle(color: AppColors.textTertiary, fontSize: 11),
+                          ),
+                        ],
                       ),
-                      if (isPreview) ...[
-                        const SizedBox(width: 8),
+                      if (isPreview)
                         Container(
                           padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                           decoration: BoxDecoration(
@@ -1222,7 +1702,6 @@ class _ChapterManagementScreenState extends ConsumerState<ChapterManagementScree
                             ),
                           ),
                         ),
-                      ],
                     ],
                   ),
                 ],
@@ -1294,3 +1773,221 @@ class _ChapterSortEntry {
     required this.originalIndex,
   });
 }
+
+/// Dialog for bulk upload confirmation and editing chapter titles
+class _BulkUploadDialog extends StatefulWidget {
+  final List<_NarratorChapterToUpload> chapters;
+  final VoidCallback onConfirm;
+  final VoidCallback onCancel;
+
+  const _BulkUploadDialog({
+    required this.chapters,
+    required this.onConfirm,
+    required this.onCancel,
+  });
+
+  @override
+  State<_BulkUploadDialog> createState() => _BulkUploadDialogState();
+}
+
+class _BulkUploadDialogState extends State<_BulkUploadDialog> {
+  late List<TextEditingController> _titleControllers;
+
+  @override
+  void initState() {
+    super.initState();
+    _titleControllers = widget.chapters
+        .map((c) => TextEditingController(text: c.titleFa))
+        .toList();
+  }
+
+  @override
+  void dispose() {
+    for (final controller in _titleControllers) {
+      controller.dispose();
+    }
+    super.dispose();
+  }
+
+  void _reorder(int oldIndex, int newIndex) {
+    if (newIndex > oldIndex) newIndex--;
+    setState(() {
+      final chapter = widget.chapters.removeAt(oldIndex);
+      widget.chapters.insert(newIndex, chapter);
+      final controller = _titleControllers.removeAt(oldIndex);
+      _titleControllers.insert(newIndex, controller);
+    });
+  }
+
+  void _removeItem(int index) {
+    setState(() {
+      widget.chapters.removeAt(index);
+      _titleControllers[index].dispose();
+      _titleControllers.removeAt(index);
+    });
+  }
+
+  void _confirmUpload() {
+    // Check for empty titles
+    for (int i = 0; i < widget.chapters.length; i++) {
+      final title = _titleControllers[i].text.trim();
+      if (title.isEmpty) {
+        ScaffoldMessenger.of(context).showSnackBar(
+          SnackBar(
+            content: Text('عنوان فصل ${i + 1} خالی است'),
+            backgroundColor: AppColors.error,
+          ),
+        );
+        return;
+      }
+      widget.chapters[i].titleFa = title;
+    }
+    widget.onConfirm();
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    return Directionality(
+      textDirection: TextDirection.rtl,
+      child: AlertDialog(
+        backgroundColor: AppColors.surface,
+        title: Row(
+          children: [
+            const Icon(Icons.library_add, color: AppColors.primary),
+            const SizedBox(width: 8),
+            Text('آپلود ${widget.chapters.length} فصل'),
+          ],
+        ),
+        content: SizedBox(
+          width: double.maxFinite,
+          height: 400,
+          child: widget.chapters.isEmpty
+              ? const Center(
+                  child: Text(
+                    'همه فایل‌ها حذف شدند',
+                    style: TextStyle(color: AppColors.textSecondary),
+                  ),
+                )
+              : Column(
+                  crossAxisAlignment: CrossAxisAlignment.start,
+                  children: [
+                    const Text(
+                      'می‌توانید عنوان‌ها را ویرایش کنید یا ترتیب را تغییر دهید:',
+                      style: TextStyle(
+                        color: AppColors.textSecondary,
+                        fontSize: 12,
+                      ),
+                    ),
+                    const SizedBox(height: 12),
+                    Expanded(
+                      child: ReorderableListView.builder(
+                        itemCount: widget.chapters.length,
+                        onReorder: _reorder,
+                        itemBuilder: (context, index) {
+                          final chapter = widget.chapters[index];
+                          return Card(
+                            key: ValueKey('bulk_chapter_$index'),
+                            color: AppColors.background,
+                            margin: const EdgeInsets.only(bottom: 8),
+                            child: Padding(
+                              padding: const EdgeInsets.all(8),
+                              child: Row(
+                                children: [
+                                  // Order number
+                                  Container(
+                                    width: 28,
+                                    height: 28,
+                                    decoration: BoxDecoration(
+                                      color: AppColors.primary.withOpacity(0.1),
+                                      borderRadius: BorderRadius.circular(6),
+                                    ),
+                                    alignment: Alignment.center,
+                                    child: Text(
+                                      '${index + 1}',
+                                      style: const TextStyle(
+                                        color: AppColors.primary,
+                                        fontWeight: FontWeight.w600,
+                                        fontSize: 12,
+                                      ),
+                                    ),
+                                  ),
+                                  const SizedBox(width: 8),
+                                  // Title field and file info
+                                  Expanded(
+                                    child: Column(
+                                      crossAxisAlignment: CrossAxisAlignment.start,
+                                      children: [
+                                        TextField(
+                                          controller: _titleControllers[index],
+                                          style: const TextStyle(fontSize: 13),
+                                          decoration: InputDecoration(
+                                            isDense: true,
+                                            contentPadding: const EdgeInsets.symmetric(
+                                              horizontal: 8,
+                                              vertical: 8,
+                                            ),
+                                            hintText: 'عنوان فصل',
+                                            border: OutlineInputBorder(
+                                              borderRadius: BorderRadius.circular(6),
+                                              borderSide: BorderSide.none,
+                                            ),
+                                            filled: true,
+                                            fillColor: AppColors.surface,
+                                          ),
+                                        ),
+                                        const SizedBox(height: 4),
+                                        Text(
+                                          '${chapter.fileName} • ${Formatters.formatFileSize(chapter.fileSize)}',
+                                          style: const TextStyle(
+                                            color: AppColors.textTertiary,
+                                            fontSize: 10,
+                                          ),
+                                          overflow: TextOverflow.ellipsis,
+                                        ),
+                                      ],
+                                    ),
+                                  ),
+                                  // Delete button
+                                  IconButton(
+                                    icon: const Icon(
+                                      Icons.close,
+                                      color: AppColors.error,
+                                      size: 18,
+                                    ),
+                                    onPressed: () => _removeItem(index),
+                                    visualDensity: VisualDensity.compact,
+                                  ),
+                                  // Drag handle
+                                  ReorderableDragStartListener(
+                                    index: index,
+                                    child: const Icon(
+                                      Icons.drag_handle,
+                                      color: AppColors.textTertiary,
+                                      size: 20,
+                                    ),
+                                  ),
+                                ],
+                              ),
+                            ),
+                          );
+                        },
+                      ),
+                    ),
+                  ],
+                ),
+        ),
+        actions: [
+          TextButton(
+            onPressed: widget.onCancel,
+            child: const Text('انصراف'),
+          ),
+          ElevatedButton.icon(
+            onPressed: widget.chapters.isEmpty ? null : _confirmUpload,
+            icon: const Icon(Icons.upload, size: 18),
+            label: Text('آپلود ${widget.chapters.length} فصل'),
+          ),
+        ],
+      ),
+    );
+  }
+}
diff --git a/lib/screens/narrator/narrator_audiobooks_screen.dart b/lib/screens/narrator/narrator_audiobooks_screen.dart
index 485f3f9..7f7ac59 100644
--- a/lib/screens/narrator/narrator_audiobooks_screen.dart
+++ b/lib/screens/narrator/narrator_audiobooks_screen.dart
@@ -40,6 +40,7 @@ class _NarratorAudiobooksScreenState extends ConsumerState<NarratorAudiobooksScr
         return;
       }
 
+      // Include rejection_reason for displaying feedback to narrator
       final response = await Supabase.instance.client
           .from('audiobooks')
           .select('*, categories(name_fa)')
@@ -64,7 +65,7 @@ class _NarratorAudiobooksScreenState extends ConsumerState<NarratorAudiobooksScr
       case 'draft':
         return 'پیش‌نویس';
       case 'submitted':
-        return 'در انتظار';
+        return 'ارسال شده';
       case 'under_review':
         return 'در حال بررسی';
       case 'approved':
@@ -76,13 +77,31 @@ class _NarratorAudiobooksScreenState extends ConsumerState<NarratorAudiobooksScr
     }
   }
 
+  String _getStatusDescription(String? status) {
+    switch (status) {
+      case 'draft':
+        return 'فصل‌ها را اضافه کرده و ارسال کنید';
+      case 'submitted':
+        return 'در صف بررسی توسط تیم ما';
+      case 'under_review':
+        return 'در حال بررسی توسط تیم ما';
+      case 'approved':
+        return 'کتاب شما در اپ منتشر شده';
+      case 'rejected':
+        return 'لطفاً اصلاحات را انجام دهید';
+      default:
+        return '';
+    }
+  }
+
   Color _getStatusColor(String? status) {
     switch (status) {
       case 'draft':
         return AppColors.textTertiary;
       case 'submitted':
+        return AppColors.warning; // Yellow/amber for "waiting"
       case 'under_review':
-        return Colors.orange;
+        return Colors.blue; // Blue for "actively being reviewed"
       case 'approved':
         return AppColors.success;
       case 'rejected':
@@ -97,8 +116,9 @@ class _NarratorAudiobooksScreenState extends ConsumerState<NarratorAudiobooksScr
       case 'draft':
         return Icons.edit_note;
       case 'submitted':
+        return Icons.schedule; // Clock for "waiting in queue"
       case 'under_review':
-        return Icons.hourglass_empty;
+        return Icons.visibility; // Eye for "being reviewed"
       case 'approved':
         return Icons.check_circle;
       case 'rejected':
@@ -125,9 +145,9 @@ class _NarratorAudiobooksScreenState extends ConsumerState<NarratorAudiobooksScr
   }
 
   void _openChapterManagement(Map<String, dynamic> book) async {
-    final result = await Navigator.push(
+    final result = await Navigator.push<String?>(
       context,
-      MaterialPageRoute<bool>(
+      MaterialPageRoute<String?>(
         builder: (context) => ChapterManagementScreen(
           audiobookId: book['id'] as int,
           audiobookTitle: (book['title_fa'] as String?) ?? '',
@@ -136,7 +156,7 @@ class _NarratorAudiobooksScreenState extends ConsumerState<NarratorAudiobooksScr
     );
 
     // Reload if submitted or changes were made
-    if (result == true) {
+    if (result == 'submitted') {
       _loadAudiobooks();
     }
   }
@@ -194,15 +214,27 @@ class _NarratorAudiobooksScreenState extends ConsumerState<NarratorAudiobooksScr
                   _openChapterManagement(book);
                 },
               ),
+              // Show submit option for drafts with chapters
               if (book['status'] == 'draft' && ((book['chapter_count'] as int?) ?? 0) > 0)
                 ListTile(
-                  leading: const Icon(Icons.send, color: Colors.orange),
+                  leading: const Icon(Icons.send, color: AppColors.warning),
                   title: const Text('ارسال برای بررسی'),
                   onTap: () async {
                     Navigator.pop(context);
                     await _submitForReview(book);
                   },
                 ),
+              // Show re-submit option for rejected books (after edits)
+              if (book['status'] == 'rejected')
+                ListTile(
+                  leading: const Icon(Icons.replay, color: AppColors.primary),
+                  title: const Text('ارسال مجدد برای بررسی'),
+                  subtitle: const Text('پس از انجام اصلاحات', style: TextStyle(fontSize: 12, color: AppColors.textTertiary)),
+                  onTap: () async {
+                    Navigator.pop(context);
+                    await _submitForReview(book);
+                  },
+                ),
               const SizedBox(height: 16),
             ],
           ),
@@ -370,7 +402,7 @@ class _NarratorAudiobooksScreenState extends ConsumerState<NarratorAudiobooksScr
                     if (categoryName.isNotEmpty)
                       Text(
                         categoryName,
-                        style: TextStyle(
+                        style: const TextStyle(
                           color: AppColors.textSecondary,
                           fontSize: 12,
                         ),
@@ -380,11 +412,11 @@ class _NarratorAudiobooksScreenState extends ConsumerState<NarratorAudiobooksScr
                     Row(
                       children: [
                         // Chapters
-                        Icon(Icons.list, size: 14, color: AppColors.textTertiary),
+                        const Icon(Icons.list, size: 14, color: AppColors.textTertiary),
                         const SizedBox(width: 4),
                         Text(
                           '$chapterCount فصل',
-                          style: TextStyle(
+                          style: const TextStyle(
                             color: AppColors.textTertiary,
                             fontSize: 12,
                           ),
@@ -407,7 +439,7 @@ class _NarratorAudiobooksScreenState extends ConsumerState<NarratorAudiobooksScr
                       ],
                     ),
                     const SizedBox(height: 8),
-                    // Status badge
+                    // Status badge with description
                     Container(
                       padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                       decoration: BoxDecoration(
@@ -434,11 +466,52 @@ class _NarratorAudiobooksScreenState extends ConsumerState<NarratorAudiobooksScr
                         ],
                       ),
                     ),
+                    // Status description
+                    if (_getStatusDescription(status).isNotEmpty) ...[
+                      const SizedBox(height: 4),
+                      Text(
+                        _getStatusDescription(status),
+                        style: const TextStyle(
+                          color: AppColors.textTertiary,
+                          fontSize: 10,
+                        ),
+                      ),
+                    ],
+                    // Rejection reason
+                    if (status == 'rejected' && book['rejection_reason'] != null) ...[
+                      const SizedBox(height: 6),
+                      Container(
+                        padding: const EdgeInsets.all(8),
+                        decoration: BoxDecoration(
+                          color: AppColors.error.withOpacity(0.1),
+                          borderRadius: BorderRadius.circular(6),
+                          border: Border.all(color: AppColors.error.withOpacity(0.3)),
+                        ),
+                        child: Row(
+                          crossAxisAlignment: CrossAxisAlignment.start,
+                          children: [
+                            const Icon(Icons.info_outline, size: 14, color: AppColors.error),
+                            const SizedBox(width: 6),
+                            Expanded(
+                              child: Text(
+                                book['rejection_reason'] as String,
+                                style: const TextStyle(
+                                  color: AppColors.error,
+                                  fontSize: 11,
+                                ),
+                                maxLines: 2,
+                                overflow: TextOverflow.ellipsis,
+                              ),
+                            ),
+                          ],
+                        ),
+                      ),
+                    ],
                   ],
                 ),
               ),
               // Arrow
-              Icon(
+              const Icon(
                 Icons.chevron_left,
                 color: AppColors.textTertiary,
               ),
diff --git a/lib/screens/narrator/narrator_dashboard_screen.dart b/lib/screens/narrator/narrator_dashboard_screen.dart
index 02b61d7..069fc3e 100644
--- a/lib/screens/narrator/narrator_dashboard_screen.dart
+++ b/lib/screens/narrator/narrator_dashboard_screen.dart
@@ -19,10 +19,10 @@ final narratorDashboardStatsProvider = FutureProvider<Map<String, dynamic>>((ref
 
   final books = List<Map<String, dynamic>>.from(audiobooks);
 
-  int totalBooks = books.length;
-  int publishedBooks = books.where((b) => b['status'] == 'approved').length;
-  int pendingBooks = books.where((b) => b['status'] == 'submitted' || b['status'] == 'under_review').length;
-  int draftBooks = books.where((b) => b['status'] == 'draft').length;
+  final int totalBooks = books.length;
+  final int publishedBooks = books.where((b) => b['status'] == 'approved').length;
+  final int pendingBooks = books.where((b) => b['status'] == 'submitted' || b['status'] == 'under_review').length;
+  final int draftBooks = books.where((b) => b['status'] == 'draft').length;
   int totalPlays = 0;
   int totalPurchases = 0;
   int totalEarnings = 0;
@@ -123,7 +123,7 @@ class NarratorDashboardScreen extends ConsumerWidget {
                       child: CircularProgressIndicator(color: AppColors.primary),
                     ),
                   ),
-                  error: (e, _) => Center(
+                  error: (e, _) => const Center(
                     child: Text(
                       'خطا در بارگذاری آمار',
                       style: TextStyle(color: AppColors.error),
diff --git a/lib/screens/narrator/narrator_edit_screen.dart b/lib/screens/narrator/narrator_edit_screen.dart
index 1adbdc6..51350ff 100644
--- a/lib/screens/narrator/narrator_edit_screen.dart
+++ b/lib/screens/narrator/narrator_edit_screen.dart
@@ -2,10 +2,11 @@ import 'dart:typed_data';
 import 'package:flutter/material.dart';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
 import 'package:supabase_flutter/supabase_flutter.dart';
-import 'package:file_picker/file_picker.dart';
+import 'package:image_picker/image_picker.dart';
 import 'package:myna/theme/app_theme.dart';
 import 'package:myna/screens/narrator/chapter_management_screen.dart';
 import 'package:myna/utils/app_logger.dart';
+import 'package:myna/services/creator_service.dart';
 
 class NarratorEditScreen extends ConsumerStatefulWidget {
   final int audiobookId;
@@ -119,20 +120,20 @@ class _NarratorEditScreenState extends ConsumerState<NarratorEditScreen> {
 
   Future<void> _pickCoverImage() async {
     try {
-      final result = await FilePicker.platform.pickFiles(
-        type: FileType.image,
-        allowMultiple: false,
-        withData: true,
+      final picker = ImagePicker();
+      final XFile? image = await picker.pickImage(
+        source: ImageSource.gallery,
+        maxWidth: 1200,
+        maxHeight: 1200,
+        imageQuality: 85,
       );
 
-      if (result != null && result.files.isNotEmpty) {
-        final file = result.files.first;
-        if (file.bytes != null) {
-          setState(() {
-            _newCoverBytes = file.bytes;
-            _newCoverFileName = file.name;
-          });
-        }
+      if (image != null) {
+        final bytes = await image.readAsBytes();
+        setState(() {
+          _newCoverBytes = bytes;
+          _newCoverFileName = image.name;
+        });
       }
     } catch (e) {
       setState(() => _error = 'خطا در انتخاب تصویر: $e');
@@ -177,44 +178,87 @@ class _NarratorEditScreenState extends ConsumerState<NarratorEditScreen> {
 
     try {
       String? coverUrl = _existingCoverUrl;
+      String? newCoverPath; // Track new cover for cleanup if DB fails
 
       // Upload new cover if selected
       if (_newCoverBytes != null) {
         coverUrl = await _uploadNewCover();
+        // Extract path from URL for potential cleanup
+        if (coverUrl != null) {
+          try {
+            final uri = Uri.parse(coverUrl);
+            final pathSegments = uri.pathSegments;
+            final bucketIndex = pathSegments.indexOf('audiobook-covers');
+            if (bucketIndex != -1 && bucketIndex < pathSegments.length - 1) {
+              newCoverPath = pathSegments.sublist(bucketIndex + 1).join('/');
+            }
+          } catch (_) {}
+        }
       }
 
       final price = _isFree ? 0 : int.tryParse(_priceController.text) ?? 0;
 
-      await Supabase.instance.client
-          .from('audiobooks')
-          .update({
-            'title_fa': _titleFaController.text.trim(),
-            'title_en': _titleEnController.text.trim().isEmpty
-                ? null
-                : _titleEnController.text.trim(),
-            'author_fa': _authorFaController.text.trim().isEmpty
-                ? null
-                : _authorFaController.text.trim(),
-            'author_en': _authorEnController.text.trim().isEmpty
-                ? null
-                : _authorEnController.text.trim(),
-            'translator_fa': _translatorFaController.text.trim().isEmpty
-                ? null
-                : _translatorFaController.text.trim(),
-            'translator_en': _translatorEnController.text.trim().isEmpty
-                ? null
-                : _translatorEnController.text.trim(),
-            'description_fa': _descriptionFaController.text.trim(),
-            'description_en': _descriptionEnController.text.trim().isEmpty
-                ? null
-                : _descriptionEnController.text.trim(),
-            'category_id': _selectedCategoryId,
-            'cover_url': coverUrl,
-            'price_toman': price,
-            'is_free': _isFree,
-            'updated_at': DateTime.now().toIso8601String(),
-          })
-          .eq('id', widget.audiobookId);
+      // Update audiobook - with orphan cover cleanup on failure
+      try {
+        await Supabase.instance.client
+            .from('audiobooks')
+            .update({
+              'title_fa': _titleFaController.text.trim(),
+              'title_en': _titleEnController.text.trim().isEmpty
+                  ? null
+                  : _titleEnController.text.trim(),
+              'author_fa': _authorFaController.text.trim().isEmpty
+                  ? null
+                  : _authorFaController.text.trim(),
+              'author_en': _authorEnController.text.trim().isEmpty
+                  ? null
+                  : _authorEnController.text.trim(),
+              'translator_fa': _translatorFaController.text.trim().isEmpty
+                  ? null
+                  : _translatorFaController.text.trim(),
+              'translator_en': _translatorEnController.text.trim().isEmpty
+                  ? null
+                  : _translatorEnController.text.trim(),
+              'description_fa': _descriptionFaController.text.trim(),
+              'description_en': _descriptionEnController.text.trim().isEmpty
+                  ? null
+                  : _descriptionEnController.text.trim(),
+              'category_id': _selectedCategoryId,
+              'cover_url': coverUrl,
+              'price_toman': price,
+              'is_free': _isFree,
+              'updated_at': DateTime.now().toIso8601String(),
+            })
+            .eq('id', widget.audiobookId);
+      } catch (dbError) {
+        // DB update failed - clean up newly uploaded cover if any
+        if (newCoverPath != null) {
+          AppLogger.w('Narrator audiobook DB update failed, cleaning up new cover: $newCoverPath');
+          try {
+            await Supabase.instance.client.storage.from('audiobook-covers').remove([newCoverPath]);
+          } catch (cleanupError) {
+            AppLogger.e('Failed to cleanup orphan cover: $newCoverPath', error: cleanupError);
+          }
+        }
+        rethrow;
+      }
+
+      // Auto-sync creators from author/translator fields
+      try {
+        final creatorService = CreatorService();
+        await creatorService.syncCreatorsForAudiobook(
+          audiobookId: widget.audiobookId,
+          isMusic: false, // Narrators can only edit books
+          authorName: _authorFaController.text,
+          authorNameEn: _authorEnController.text,
+          translatorName: _translatorFaController.text,
+          translatorNameEn: _translatorEnController.text,
+        );
+        AppLogger.d('Creator sync completed for audiobook ${widget.audiobookId}');
+      } catch (e) {
+        // Log but don't fail the save
+        AppLogger.e('Failed to sync creators', error: e);
+      }
 
       if (mounted) {
         ScaffoldMessenger.of(context).showSnackBar(
@@ -536,11 +580,11 @@ class _NarratorEditScreenState extends ConsumerState<NarratorEditScreen> {
                             child: Column(
                               crossAxisAlignment: CrossAxisAlignment.start,
                               children: [
-                                Row(
+                                const Row(
                                   children: [
-                                    const Icon(Icons.person, color: AppColors.primary, size: 20),
-                                    const SizedBox(width: 8),
-                                    const Text(
+                                    Icon(Icons.person, color: AppColors.primary, size: 20),
+                                    SizedBox(width: 8),
+                                    Text(
                                       'اطلاعات نویسنده و مترجم',
                                       style: TextStyle(
                                         fontSize: 14,
@@ -751,7 +795,7 @@ class _NarratorEditScreenState extends ConsumerState<NarratorEditScreen> {
           const Spacer(),
           Text(
             '${(_audiobook?['chapter_count'] as int?) ?? 0} فصل',
-            style: TextStyle(color: AppColors.textSecondary),
+            style: const TextStyle(color: AppColors.textSecondary),
           ),
         ],
       ),
diff --git a/lib/screens/narrator/narrator_feedback_screen.dart b/lib/screens/narrator/narrator_feedback_screen.dart
index 4d04299..9a2e2ab 100644
--- a/lib/screens/narrator/narrator_feedback_screen.dart
+++ b/lib/screens/narrator/narrator_feedback_screen.dart
@@ -89,18 +89,18 @@ class _NarratorFeedbackScreenState extends ConsumerState<NarratorFeedbackScreen>
           ),
           data: (feedbackList) {
             if (feedbackList.isEmpty) {
-              return Center(
+              return const Center(
                 child: Column(
                   mainAxisAlignment: MainAxisAlignment.center,
                   children: [
                     Icon(Icons.feedback_outlined, size: 64, color: AppColors.textTertiary),
-                    const SizedBox(height: 16),
-                    const Text(
+                    SizedBox(height: 16),
+                    Text(
                       'هنوز بازخوردی دریافت نکرده‌اید',
                       style: TextStyle(color: AppColors.textSecondary, fontSize: 16),
                     ),
-                    const SizedBox(height: 8),
-                    const Text(
+                    SizedBox(height: 8),
+                    Text(
                       'بازخوردهای مدیریت در اینجا نمایش داده می‌شوند',
                       style: TextStyle(color: AppColors.textTertiary, fontSize: 13),
                     ),
@@ -204,7 +204,7 @@ class _NarratorFeedbackScreenState extends ConsumerState<NarratorFeedbackScreen>
             Row(
               children: [
                 if (audiobookTitle != null) ...[
-                  Icon(Icons.book, size: 14, color: AppColors.textTertiary),
+                  const Icon(Icons.book, size: 14, color: AppColors.textTertiary),
                   const SizedBox(width: 4),
                   Flexible(
                     child: Text(
@@ -220,7 +220,7 @@ class _NarratorFeedbackScreenState extends ConsumerState<NarratorFeedbackScreen>
                     child: Text('•', style: TextStyle(color: AppColors.textTertiary)),
                   ),
                 if (chapterTitle != null) ...[
-                  Icon(Icons.audiotrack, size: 14, color: AppColors.textTertiary),
+                  const Icon(Icons.audiotrack, size: 14, color: AppColors.textTertiary),
                   const SizedBox(width: 4),
                   Flexible(
                     child: Text(
@@ -257,7 +257,7 @@ class _NarratorFeedbackScreenState extends ConsumerState<NarratorFeedbackScreen>
           const SizedBox(height: 12),
           Row(
             children: [
-              Icon(Icons.person_outline, size: 14, color: AppColors.textTertiary),
+              const Icon(Icons.person_outline, size: 14, color: AppColors.textTertiary),
               const SizedBox(width: 4),
               Text(
                 adminName,
@@ -265,7 +265,7 @@ class _NarratorFeedbackScreenState extends ConsumerState<NarratorFeedbackScreen>
               ),
               const Spacer(),
               if (createdAt != null) ...[
-                Icon(Icons.access_time, size: 14, color: AppColors.textTertiary),
+                const Icon(Icons.access_time, size: 14, color: AppColors.textTertiary),
                 const SizedBox(width: 4),
                 Text(
                   _formatDate(createdAt),
@@ -358,7 +358,7 @@ class _NarratorFeedbackScreenState extends ConsumerState<NarratorFeedbackScreen>
         ),
         if (!canEdit) ...[
           const SizedBox(height: 8),
-          Text(
+          const Text(
             'این کتاب تایید شده و قابل ویرایش نیست',
             style: TextStyle(fontSize: 11, color: AppColors.textTertiary),
           ),
diff --git a/lib/screens/narrator/narrator_profile_screen.dart b/lib/screens/narrator/narrator_profile_screen.dart
index f10e333..982e829 100644
--- a/lib/screens/narrator/narrator_profile_screen.dart
+++ b/lib/screens/narrator/narrator_profile_screen.dart
@@ -4,6 +4,7 @@ import 'package:supabase_flutter/supabase_flutter.dart';
 import 'package:myna/theme/app_theme.dart';
 import 'package:myna/screens/listener/edit_profile_screen.dart';
 import 'package:myna/providers/audio_provider.dart';
+import 'package:myna/providers/app_mode_provider.dart';
 
 final narratorProfileProvider = FutureProvider<Map<String, dynamic>?>((ref) async {
   final user = Supabase.instance.client.auth.currentUser;
@@ -33,8 +34,8 @@ final narratorStatsProvider = FutureProvider<Map<String, dynamic>>((ref) async {
   int totalPurchases = 0;
 
   for (final book in books) {
-    totalPlays += ((book['play_count'] as int?) ?? 0);
-    totalPurchases += ((book['purchase_count'] as int?) ?? 0);
+    totalPlays += (book['play_count'] as int?) ?? 0;
+    totalPurchases += (book['purchase_count'] as int?) ?? 0;
   }
 
   return {
@@ -207,6 +208,10 @@ class NarratorProfileScreen extends ConsumerWidget {
                 ),
                 const SizedBox(height: 16),
 
+                // Switch to listener mode button
+                _buildListenerModeButton(context, ref),
+                const SizedBox(height: 16),
+
                 // Logout button
                 SizedBox(
                   width: double.infinity,
@@ -293,4 +298,30 @@ class NarratorProfileScreen extends ConsumerWidget {
       ),
     );
   }
+
+  Widget _buildListenerModeButton(BuildContext context, WidgetRef ref) {
+    return SizedBox(
+      width: double.infinity,
+      child: OutlinedButton.icon(
+        onPressed: () {
+          ref.read(appModeProvider.notifier).state = AppMode.listener;
+        },
+        icon: const Icon(Icons.headphones, color: AppColors.primary),
+        label: const Text(
+          'بازگشت به حالت شنونده',
+          style: TextStyle(
+            color: AppColors.primary,
+            fontWeight: FontWeight.w600,
+          ),
+        ),
+        style: OutlinedButton.styleFrom(
+          side: const BorderSide(color: AppColors.primary),
+          padding: const EdgeInsets.symmetric(vertical: 14),
+          shape: RoundedRectangleBorder(
+            borderRadius: BorderRadius.circular(12),
+          ),
+        ),
+      ),
+    );
+  }
 }
\ No newline at end of file
diff --git a/lib/screens/narrator/narrator_upload_screen.dart b/lib/screens/narrator/narrator_upload_screen.dart
index a9cfccb..e098032 100644
--- a/lib/screens/narrator/narrator_upload_screen.dart
+++ b/lib/screens/narrator/narrator_upload_screen.dart
@@ -2,13 +2,14 @@ import 'dart:typed_data';
 import 'package:flutter/material.dart';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
 import 'package:supabase_flutter/supabase_flutter.dart';
-import 'package:file_picker/file_picker.dart';
+import 'package:image_picker/image_picker.dart';
 import 'package:myna/theme/app_theme.dart';
 import 'package:myna/config/env.dart';
 import 'package:myna/utils/app_logger.dart';
 import 'package:myna/screens/narrator/chapter_management_screen.dart';
 import 'package:myna/screens/narrator/narrator_main_shell.dart';
 import 'package:myna/providers/home_providers.dart';
+import 'package:myna/services/creator_service.dart';
 
 class NarratorUploadScreen extends ConsumerStatefulWidget {
   const NarratorUploadScreen({super.key});
@@ -34,6 +35,10 @@ class _NarratorUploadScreenState extends ConsumerState<NarratorUploadScreen> {
   // State
   int? _selectedCategoryId;
   bool _isFree = true;
+  // NOTE: Narrators can only upload audiobooks, not music.
+  // Music upload is restricted to admin role only.
+  // _isMusic is always false for narrators.
+  final bool _isMusic = false;
   bool _isLoading = false;
   String? _error;
   
@@ -57,20 +62,20 @@ class _NarratorUploadScreenState extends ConsumerState<NarratorUploadScreen> {
 
   Future<void> _pickCoverImage() async {
     try {
-      final result = await FilePicker.platform.pickFiles(
-        type: FileType.image,
-        allowMultiple: false,
-        withData: true, // Important for web
+      final picker = ImagePicker();
+      final XFile? image = await picker.pickImage(
+        source: ImageSource.gallery,
+        maxWidth: 1200,
+        maxHeight: 1200,
+        imageQuality: 85,
       );
 
-      if (result != null && result.files.isNotEmpty) {
-        final file = result.files.first;
-        if (file.bytes != null) {
-          setState(() {
-            _coverImageBytes = file.bytes;
-            _coverFileName = file.name;
-          });
-        }
+      if (image != null) {
+        final bytes = await image.readAsBytes();
+        setState(() {
+          _coverImageBytes = bytes;
+          _coverFileName = image.name;
+        });
       }
     } catch (e) {
       setState(() => _error = 'خطا در انتخاب تصویر: $e');
@@ -140,46 +145,72 @@ class _NarratorUploadScreenState extends ConsumerState<NarratorUploadScreen> {
         throw Exception('خطا در آپلود تصویر جلد');
       }
 
-      // 2. Create audiobook record
+      // 2. Create audiobook record - with orphan cover cleanup on failure
       final price = _isFree ? 0 : int.tryParse(_priceController.text) ?? 0;
 
-      final response = await Supabase.instance.client
-          .from('audiobooks')
-          .insert({
-            'title_fa': _titleFaController.text.trim(),
-            'title_en': _titleEnController.text.trim().isEmpty
-                ? null
-                : _titleEnController.text.trim(),
-            'author_fa': _authorFaController.text.trim(),
-            'author_en': _authorEnController.text.trim().isEmpty
-                ? null
-                : _authorEnController.text.trim(),
-            'translator_fa': _translatorFaController.text.trim().isEmpty
-                ? null
-                : _translatorFaController.text.trim(),
-            'translator_en': _translatorEnController.text.trim().isEmpty
-                ? null
-                : _translatorEnController.text.trim(),
-            'description_fa': _descriptionFaController.text.trim(),
-            'description_en': _descriptionEnController.text.trim().isEmpty
-                ? null
-                : _descriptionEnController.text.trim(),
-            'category_id': _selectedCategoryId,
-            'narrator_id': user.id,
-            'cover_url': coverUrl,
-            'price_toman': price,
-            'is_free': _isFree,
-            'status': 'draft',
-            'language': 'fa',
-            'chapter_count': 0,
-            'total_duration_seconds': 0,
-            'play_count': 0,
-            'purchase_count': 0,
-            'review_count': 0,
-            'is_featured': false,
-          })
-          .select()
-          .single();
+      // Extract cover path from URL for potential cleanup
+      String? coverPath;
+      try {
+        final uri = Uri.parse(coverUrl);
+        final pathSegments = uri.pathSegments;
+        final bucketIndex = pathSegments.indexOf('audiobook-covers');
+        if (bucketIndex != -1 && bucketIndex < pathSegments.length - 1) {
+          coverPath = pathSegments.sublist(bucketIndex + 1).join('/');
+        }
+      } catch (_) {}
+
+      late final Map<String, dynamic> response;
+      try {
+        response = await Supabase.instance.client
+            .from('audiobooks')
+            .insert({
+              'title_fa': _titleFaController.text.trim(),
+              'title_en': _titleEnController.text.trim().isEmpty
+                  ? null
+                  : _titleEnController.text.trim(),
+              'author_fa': _authorFaController.text.trim(),
+              'author_en': _authorEnController.text.trim().isEmpty
+                  ? null
+                  : _authorEnController.text.trim(),
+              'translator_fa': _translatorFaController.text.trim().isEmpty
+                  ? null
+                  : _translatorFaController.text.trim(),
+              'translator_en': _translatorEnController.text.trim().isEmpty
+                  ? null
+                  : _translatorEnController.text.trim(),
+              'description_fa': _descriptionFaController.text.trim(),
+              'description_en': _descriptionEnController.text.trim().isEmpty
+                  ? null
+                  : _descriptionEnController.text.trim(),
+              'category_id': _selectedCategoryId,
+              'narrator_id': user.id,
+              'cover_url': coverUrl,
+              'price_toman': price,
+              'is_free': _isFree,
+              'is_music': _isMusic, // Content type flag
+              'status': 'draft',
+              'language': 'fa',
+              'chapter_count': 0,
+              'total_duration_seconds': 0,
+              'play_count': 0,
+              'purchase_count': 0,
+              'review_count': 0,
+              'is_featured': false,
+            })
+            .select()
+            .single();
+      } catch (dbError) {
+        // DB insert failed - clean up orphan cover file from storage
+        if (coverPath != null) {
+          AppLogger.w('Narrator audiobook DB insert failed, cleaning up cover: $coverPath');
+          try {
+            await Supabase.instance.client.storage.from(Env.coversBucket).remove([coverPath]);
+          } catch (cleanupError) {
+            AppLogger.e('Failed to cleanup orphan cover: $coverPath', error: cleanupError);
+          }
+        }
+        rethrow;
+      }
 
       final audiobookId = response['id'] as int?;
       final audiobookTitle = (response['title_fa'] as String?) ?? '';
@@ -191,6 +222,47 @@ class _NarratorUploadScreenState extends ConsumerState<NarratorUploadScreen> {
         throw Exception('شناسه کتاب برگردانده نشد');
       }
 
+      // 3. Insert book metadata into the new book_metadata table
+      try {
+        await Supabase.instance.client
+            .from('book_metadata')
+            .insert({
+              'audiobook_id': audiobookId,
+              'author_name': _authorFaController.text.trim().isEmpty
+                  ? null : _authorFaController.text.trim(),
+              'author_name_en': _authorEnController.text.trim().isEmpty
+                  ? null : _authorEnController.text.trim(),
+              'translator': _translatorFaController.text.trim().isEmpty
+                  ? null : _translatorFaController.text.trim(),
+              'translator_en': _translatorEnController.text.trim().isEmpty
+                  ? null : _translatorEnController.text.trim(),
+              // narrator_name will be filled from the user's profile
+              // when they complete the upload
+            });
+        AppLogger.i('Book metadata inserted for audiobook $audiobookId');
+      } catch (e) {
+        // Log but don't fail if metadata insert fails
+        // The legacy columns have the data as backup
+        AppLogger.e('Failed to insert book_metadata', error: e);
+      }
+
+      // 4. Auto-sync creators from author/translator fields
+      try {
+        final creatorService = CreatorService();
+        await creatorService.syncCreatorsForAudiobook(
+          audiobookId: audiobookId,
+          isMusic: false, // Narrators can only upload books
+          authorName: _authorFaController.text,
+          authorNameEn: _authorEnController.text,
+          translatorName: _translatorFaController.text,
+          translatorNameEn: _translatorEnController.text,
+        );
+        AppLogger.i('Creator sync completed for audiobook $audiobookId');
+      } catch (e) {
+        // Log but don't fail if creator sync fails
+        AppLogger.e('Failed to sync creators', error: e);
+      }
+
       if (!mounted) return;
 
       // 3. Show success and navigate to chapter management
@@ -247,6 +319,7 @@ class _NarratorUploadScreenState extends ConsumerState<NarratorUploadScreen> {
     setState(() {
       _selectedCategoryId = null;
       _isFree = true;
+      // _isMusic is final (always false for narrators)
       _coverImageBytes = null;
       _coverFileName = null;
     });
@@ -279,6 +352,10 @@ class _NarratorUploadScreenState extends ConsumerState<NarratorUploadScreen> {
                 _buildCoverPicker(),
                 const SizedBox(height: 24),
 
+                // NOTE: Content Type Toggle removed for narrators.
+                // Narrators can only upload audiobooks (کتاب صوتی).
+                // Music upload is restricted to admin role only.
+
                 // Persian Title (Required)
                 TextFormField(
                   controller: _titleFaController,
@@ -319,11 +396,11 @@ class _NarratorUploadScreenState extends ConsumerState<NarratorUploadScreen> {
                   child: Column(
                     crossAxisAlignment: CrossAxisAlignment.start,
                     children: [
-                      Row(
+                      const Row(
                         children: [
-                          const Icon(Icons.person, color: AppColors.primary, size: 20),
-                          const SizedBox(width: 8),
-                          const Text(
+                          Icon(Icons.person, color: AppColors.primary, size: 20),
+                          SizedBox(width: 8),
+                          Text(
                             'اطلاعات نویسنده و مترجم',
                             style: TextStyle(
                               fontSize: 14,
@@ -568,6 +645,9 @@ class _NarratorUploadScreenState extends ConsumerState<NarratorUploadScreen> {
     );
   }
 
+  // NOTE: _buildContentTypeToggle() removed for narrator screen.
+  // Narrators can only upload audiobooks. Music upload is admin-only.
+
   Widget _buildCoverPicker() {
     return GestureDetector(
       onTap: _pickCoverImage,
@@ -624,7 +704,7 @@ class _NarratorUploadScreenState extends ConsumerState<NarratorUploadScreen> {
                     ),
                   ),
                   const SizedBox(height: 4),
-                  Text(
+                  const Text(
                     'حداکثر ۱۰ مگابایت',
                     style: TextStyle(
                       color: AppColors.textTertiary,
diff --git a/lib/screens/payment/payment_failure_screen.dart b/lib/screens/payment/payment_failure_screen.dart
index c9fa9ec..5e998bd 100644
--- a/lib/screens/payment/payment_failure_screen.dart
+++ b/lib/screens/payment/payment_failure_screen.dart
@@ -124,8 +124,8 @@ class PaymentFailureScreen extends StatelessWidget {
 
                 // Info text
                 if (!wasCancelled)
-                  Padding(
-                    padding: const EdgeInsets.only(bottom: 24),
+                  const Padding(
+                    padding: EdgeInsets.only(bottom: 24),
                     child: Row(
                       mainAxisAlignment: MainAxisAlignment.center,
                       children: [
@@ -134,7 +134,7 @@ class PaymentFailureScreen extends StatelessWidget {
                           size: 16,
                           color: AppColors.textTertiary,
                         ),
-                        const SizedBox(width: 8),
+                        SizedBox(width: 8),
                         Flexible(
                           child: Text(
                             'اگر مبلغی از حساب شما کسر شده است، طی ۷۲ ساعت بازگردانده می‌شود.',
diff --git a/lib/screens/payment/payment_processing_screen.dart b/lib/screens/payment/payment_processing_screen.dart
index 3d5df2b..10d2e33 100644
--- a/lib/screens/payment/payment_processing_screen.dart
+++ b/lib/screens/payment/payment_processing_screen.dart
@@ -83,7 +83,7 @@ class PaymentProcessingScreen extends StatelessWidget {
                     const SizedBox(height: 8),
 
                     // Info text
-                    Text(
+                    const Text(
                       'لطفاً صبر کنید و از بستن برنامه خودداری کنید',
                       style: TextStyle(
                         fontSize: 13,
diff --git a/lib/screens/payment/payment_success_screen.dart b/lib/screens/payment/payment_success_screen.dart
index 4affda0..6d700a3 100644
--- a/lib/screens/payment/payment_success_screen.dart
+++ b/lib/screens/payment/payment_success_screen.dart
@@ -132,7 +132,7 @@ class PaymentSuccessScreen extends StatelessWidget {
                                     priceToman > 0
                                         ? _formatPrice(priceToman)
                                         : 'رایگان',
-                                    style: TextStyle(
+                                    style: const TextStyle(
                                       fontSize: 14,
                                       color: AppColors.textSecondary,
                                     ),
diff --git a/lib/screens/player/player_screen.dart b/lib/screens/player/player_screen.dart
index fd18cbd..8b376d5 100644
--- a/lib/screens/player/player_screen.dart
+++ b/lib/screens/player/player_screen.dart
@@ -1,12 +1,15 @@
 import 'package:flutter/material.dart';
 import 'package:flutter/foundation.dart' show kIsWeb;
 import 'package:flutter_riverpod/flutter_riverpod.dart';
+import 'package:cached_network_image/cached_network_image.dart';
+import 'package:supabase_flutter/supabase_flutter.dart';
 import 'package:myna/theme/app_theme.dart';
 import 'package:myna/providers/audio_provider.dart';
 import 'package:myna/providers/bookmark_provider.dart';
 import 'package:myna/providers/download_provider.dart';
 import 'package:myna/services/bookmark_service.dart';
 import 'package:myna/utils/formatters.dart';
+import 'package:myna/utils/app_logger.dart';
 
 class PlayerScreen extends ConsumerStatefulWidget {
   final Map<String, dynamic> audiobook;
@@ -39,39 +42,84 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
     });
   }
 
-  void _initializePlayback() {
+  void _initializePlayback() async {
     if (_hasInitialized) return;
+    _hasInitialized = true;
 
     final audio = ref.read(audioProvider);
     final currentAudiobookId = audio.audiobook?['id'];
-    final newAudiobookId = widget.audiobook['id'];
-
-    if (!audio.hasAudio || currentAudiobookId != newAudiobookId) {
-      _hasInitialized = true;
-      ref.read(audioProvider.notifier).play(
-        audiobook: widget.audiobook,
-        chapters: widget.chapters,
-        chapterIndex: widget.initialChapterIndex,
-      );
-    } else {
-      _hasInitialized = true;
-    }
+    final newAudiobookId = widget.audiobook['id'] as int;
 
     // Load bookmarks for this audiobook
-    ref.read(bookmarkProvider.notifier).loadBookmarks(newAudiobookId as int);
+    ref.read(bookmarkProvider.notifier).loadBookmarks(newAudiobookId);
+
+    // If already playing this audiobook, don't restart
+    if (audio.hasAudio && currentAudiobookId == newAudiobookId) {
+      return;
+    }
+
+    // Try to load saved progress from database
+    int chapterIndex = widget.initialChapterIndex;
+    int? seekTo;
+
+    try {
+      final user = Supabase.instance.client.auth.currentUser;
+      if (user != null) {
+        final progress = await Supabase.instance.client
+            .from('listening_progress')
+            .select('current_chapter_index, position_seconds, is_completed')
+            .eq('user_id', user.id)
+            .eq('audiobook_id', newAudiobookId)
+            .maybeSingle();
+
+        if (progress != null && progress['is_completed'] != true) {
+          final savedChapterIndex = (progress['current_chapter_index'] as int?) ?? 0;
+          final savedPosition = (progress['position_seconds'] as int?) ?? 0;
+
+          // Only use saved progress if it's valid
+          if (savedChapterIndex >= 0 && savedChapterIndex < widget.chapters.length) {
+            chapterIndex = savedChapterIndex;
+            seekTo = savedPosition;
+          }
+        }
+      }
+    } catch (e) {
+      // Failed to load progress - continue without it
+    }
+
+    ref.read(audioProvider.notifier).play(
+      audiobook: widget.audiobook,
+      chapters: widget.chapters,
+      chapterIndex: chapterIndex,
+      seekTo: seekTo,
+    );
   }
 
   @override
   Widget build(BuildContext context) {
-    final audio = ref.watch(audioProvider);
+    final audioUi = ref.watch(
+      audioProvider.select(
+        (state) => (
+          audiobook: state.audiobook,
+          chapters: state.chapters,
+          currentChapterIndex: state.currentChapterIndex,
+          isPlaying: state.isPlaying,
+          isLoading: state.isLoading,
+          hasError: state.hasError,
+          errorMessage: state.errorMessage,
+          playbackSpeed: state.playbackSpeed,
+          isOwned: state.isOwned,
+        ),
+      ),
+    );
     final notifier = ref.read(audioProvider.notifier);
 
-    final displayAudiobook = audio.audiobook ?? widget.audiobook;
-    final displayChapters = audio.chapters.isNotEmpty ? audio.chapters : widget.chapters;
+    final displayAudiobook = audioUi.audiobook ?? widget.audiobook;
+    final displayChapters = audioUi.chapters.isNotEmpty ? audioUi.chapters : widget.chapters;
 
     final currentChapter = displayChapters.isNotEmpty &&
-            audio.currentChapterIndex < displayChapters.length
-        ? displayChapters[audio.currentChapterIndex]
+            audioUi.currentChapterIndex < displayChapters.length
+        ? displayChapters[audioUi.currentChapterIndex]
         : null;
 
     final narrator = (displayAudiobook['profiles']?['display_name'] as String?) ??
@@ -83,10 +131,15 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
       child: Scaffold(
         backgroundColor: AppColors.background,
         body: SafeArea(
-          child: Column(
-            children: [
-              // Header
-              _buildHeader(context, audio, displayChapters),
+              child: Column(
+                children: [
+                  // Header
+                  _buildHeader(
+                    context,
+                    displayChapters,
+                    audioUi.currentChapterIndex,
+                    audioUi.isOwned,
+                  ),
 
               // Main Content
               Expanded(
@@ -105,18 +158,75 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
                       const SizedBox(height: 32),
 
                       // Error Display
-                      if (audio.hasError) _buildErrorCard(audio, notifier),
+                      if (audioUi.hasError) _buildErrorCard(audioUi.errorMessage, notifier),
 
                       // Progress Section
-                      _buildProgressSection(audio, notifier),
+                      Consumer(
+                        builder: (context, ref, _) {
+                          final progress = ref.watch(
+                            audioProvider.select(
+                              (state) => (
+                                position: state.position,
+                                duration: state.duration,
+                                isBuffering: state.isBuffering,
+                                hasError: state.hasError,
+                              ),
+                            ),
+                          );
+                          return _buildProgressSection(
+                            position: progress.position,
+                            duration: progress.duration,
+                            isBuffering: progress.isBuffering,
+                            hasError: progress.hasError,
+                            notifier: notifier,
+                          );
+                        },
+                      ),
                       const SizedBox(height: 24),
 
                       // Main Controls
-                      _buildMainControls(audio, notifier, displayChapters),
+                      _buildMainControls(
+                        notifier: notifier,
+                        chapters: displayChapters,
+                        currentChapterIndex: audioUi.currentChapterIndex,
+                        isOwned: audioUi.isOwned,
+                        hasError: audioUi.hasError,
+                        isLoading: audioUi.isLoading,
+                        isPlaying: audioUi.isPlaying,
+                      ),
                       const SizedBox(height: 24),
 
                       // Secondary Controls
-                      _buildSecondaryControls(audio, ref, displayChapters),
+                      Consumer(
+                        builder: (context, ref, _) {
+                          final secondary = ref.watch(
+                            audioProvider.select(
+                              (state) => (
+                                audiobookId: state.audiobook?['id'] as int?,
+                                currentChapterIndex: state.currentChapterIndex,
+                                positionSeconds: state.position.inSeconds,
+                                playbackSpeed: state.playbackSpeed,
+                                sleepTimerMode: state.sleepTimerMode,
+                                sleepTimerRemaining: state.sleepTimerRemaining,
+                                hasSleepTimer: state.hasSleepTimer,
+                                isOwned: state.isOwned,
+                              ),
+                            ),
+                          );
+                          return _buildSecondaryControls(
+                            chapters: displayChapters,
+                            audiobookId: secondary.audiobookId,
+                            currentChapterIndex: secondary.currentChapterIndex,
+                            positionSeconds: secondary.positionSeconds,
+                            playbackSpeed: secondary.playbackSpeed,
+                            sleepTimerMode: secondary.sleepTimerMode,
+                            sleepTimerRemaining: secondary.sleepTimerRemaining,
+                            hasSleepTimer: secondary.hasSleepTimer,
+                            isOwned: secondary.isOwned,
+                            ref: ref,
+                          );
+                        },
+                      ),
                       const SizedBox(height: 32),
                     ],
                   ),
@@ -129,7 +239,12 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
     );
   }
 
-  Widget _buildHeader(BuildContext context, AudioState audio, List<Map<String, dynamic>> chapters) {
+  Widget _buildHeader(
+    BuildContext context,
+    List<Map<String, dynamic>> chapters,
+    int currentChapterIndex,
+    bool isOwned,
+  ) {
     return Padding(
       padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
       child: Row(
@@ -160,8 +275,8 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
                 borderRadius: BorderRadius.circular(16),
               ),
               child: Text(
-                'فصل ${audio.currentChapterIndex + 1} از ${chapters.length}',
-                style: TextStyle(
+                'فصل ${currentChapterIndex + 1} از ${chapters.length}',
+                style: const TextStyle(
                   color: AppColors.textSecondary,
                   fontSize: 13,
                   fontWeight: FontWeight.w500,
@@ -182,7 +297,13 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
               color: AppColors.textPrimary,
               onPressed: chapters.isEmpty
                   ? null
-                  : () => _showChaptersSheet(context, ref, audio, chapters),
+                  : () => _showChaptersSheet(
+                        context,
+                        ref,
+                        chapters,
+                        currentChapterIndex,
+                        isOwned,
+                      ),
               padding: EdgeInsets.zero,
             ),
           ),
@@ -218,10 +339,11 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
         child: ClipRRect(
           borderRadius: BorderRadius.circular(20),
           child: coverUrl != null
-              ? Image.network(
-                  coverUrl,
+              ? CachedNetworkImage(
+                  imageUrl: coverUrl,
                   fit: BoxFit.cover,
-                  errorBuilder: (_, __, ___) => _buildCoverPlaceholder(),
+                  placeholder: (_, __) => _buildCoverPlaceholder(),
+                  errorWidget: (_, __, ___) => _buildCoverPlaceholder(),
                 )
               : _buildCoverPlaceholder(),
         ),
@@ -230,9 +352,9 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
   }
 
   Widget _buildCoverPlaceholder() {
-    return Container(
+    return const ColoredBox(
       color: AppColors.surface,
-      child: const Center(
+      child: Center(
         child: Icon(Icons.headphones, size: 80, color: AppColors.textTertiary),
       ),
     );
@@ -279,7 +401,7 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
         if (narrator.isNotEmpty) ...[
           Text(
             narrator,
-            style: TextStyle(
+            style: const TextStyle(
               fontSize: 15,
               color: AppColors.textSecondary,
             ),
@@ -302,7 +424,7 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
                     color: AppColors.success.withOpacity(0.15),
                     borderRadius: BorderRadius.circular(12),
                   ),
-                  child: Row(
+                  child: const Row(
                     mainAxisSize: MainAxisSize.min,
                     children: [
                       Icon(
@@ -310,7 +432,7 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
                         size: 12,
                         color: AppColors.success,
                       ),
-                      const SizedBox(width: 4),
+                      SizedBox(width: 4),
                       Text(
                         'آفلاین',
                         style: TextStyle(
@@ -334,7 +456,7 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
                   ),
                   child: Text(
                     chapterTitle,
-                    style: TextStyle(
+                    style: const TextStyle(
                       fontSize: 13,
                       color: AppColors.primary,
                       fontWeight: FontWeight.w500,
@@ -351,7 +473,7 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
     );
   }
 
-  Widget _buildErrorCard(AudioState audio, AudioNotifier notifier) {
+  Widget _buildErrorCard(String? errorMessage, AudioNotifier notifier) {
     return Container(
       padding: const EdgeInsets.all(20),
       margin: const EdgeInsets.only(bottom: 24),
@@ -365,7 +487,7 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
           const Icon(Icons.error_outline, color: AppColors.error, size: 36),
           const SizedBox(height: 12),
           Text(
-            audio.errorMessage ?? 'خطایی در پخش رخ داد',
+            errorMessage ?? 'خطایی در پخش رخ داد',
             style: const TextStyle(color: AppColors.error, fontSize: 14),
             textAlign: TextAlign.center,
           ),
@@ -387,9 +509,13 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
     );
   }
 
-  Widget _buildProgressSection(AudioState audio, AudioNotifier notifier) {
-    final position = audio.position;
-    final duration = audio.duration;
+  Widget _buildProgressSection({
+    required Duration position,
+    required Duration duration,
+    required bool isBuffering,
+    required bool hasError,
+    required AudioNotifier notifier,
+  }) {
 
     // Use drag position while dragging, otherwise use actual position
     final displayProgress = _isDragging
@@ -407,27 +533,35 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
         SliderTheme(
           data: SliderThemeData(
             trackHeight: 6,
-            thumbShape: const RoundSliderThumbShape(enabledThumbRadius: 8),
-            overlayShape: const RoundSliderOverlayShape(overlayRadius: 16),
+            thumbShape: const RoundSliderThumbShape(enabledThumbRadius: 10),
+            overlayShape: const RoundSliderOverlayShape(overlayRadius: 20),
             activeTrackColor: AppColors.primary,
             inactiveTrackColor: AppColors.surfaceLight,
             thumbColor: AppColors.primary,
             overlayColor: AppColors.primary.withOpacity(0.2),
+            trackShape: const RoundedRectSliderTrackShape(),
           ),
           child: Directionality(
             textDirection: TextDirection.ltr, // Progress bar should always go left to right
             child: Slider(
               value: displayProgress.clamp(0.0, 1.0),
-              onChanged: audio.hasError
+              onChangeStart: hasError
+                  ? null
+                  : (_) {
+                      // Mark as dragging when user starts touch
+                      setState(() {
+                        _isDragging = true;
+                      });
+                    },
+              onChanged: hasError
                   ? null
                   : (newProgress) {
                       // Update drag state - don't seek yet
                       setState(() {
-                        _isDragging = true;
                         _dragProgress = newProgress;
                       });
                     },
-              onChangeEnd: audio.hasError
+              onChangeEnd: hasError
                   ? null
                   : (finalProgress) {
                       // Seek only when user releases the slider
@@ -453,15 +587,15 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
               // Remaining time (on right in RTL, which is visually on left)
               Text(
                 '-${Formatters.formatDurationFromDurationLong(duration - displayPosition)}',
-                style: TextStyle(
+                style: const TextStyle(
                   color: AppColors.textTertiary,
                   fontSize: 13,
                   fontWeight: FontWeight.w500,
                 ),
               ),
               // Buffering indicator
-              if (audio.isBuffering && !_isDragging)
-                Row(
+              if (isBuffering && !_isDragging)
+                const Row(
                   mainAxisSize: MainAxisSize.min,
                   children: [
                     SizedBox(
@@ -472,7 +606,7 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
                         strokeWidth: 2,
                       ),
                     ),
-                    const SizedBox(width: 6),
+                    SizedBox(width: 6),
                     Text(
                       'در حال بارگذاری...',
                       style: TextStyle(
@@ -485,7 +619,7 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
               // Elapsed time (on left in RTL, which is visually on right)
               Text(
                 Formatters.formatDurationFromDurationLong(displayPosition),
-                style: TextStyle(
+                style: const TextStyle(
                   color: AppColors.textTertiary,
                   fontSize: 13,
                   fontWeight: FontWeight.w500,
@@ -498,14 +632,44 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
     );
   }
 
-  Widget _buildMainControls(
-    AudioState audio,
-    AudioNotifier notifier,
+  bool _canPlayChapter(List<Map<String, dynamic>> chapters, int chapterIndex, bool isOwned) {
+    if (isOwned) return true;
+    if (chapterIndex < 0 || chapterIndex >= chapters.length) return false;
+    // Free audiobooks can always be played
+    if (widget.audiobook['is_free'] == true) return true;
+    return chapters[chapterIndex]['is_preview'] == true;
+  }
+
+  bool _hasNextPlayableChapter(
+    List<Map<String, dynamic>> chapters,
+    int currentChapterIndex,
+    bool isOwned,
+  ) {
+    if (currentChapterIndex >= chapters.length - 1) return false;
+    return _canPlayChapter(chapters, currentChapterIndex + 1, isOwned);
+  }
+
+  bool _hasPreviousPlayableChapter(
     List<Map<String, dynamic>> chapters,
+    int currentChapterIndex,
+    bool isOwned,
   ) {
+    if (currentChapterIndex <= 0) return false;
+    return _canPlayChapter(chapters, currentChapterIndex - 1, isOwned);
+  }
+
+  Widget _buildMainControls({
+    required AudioNotifier notifier,
+    required List<Map<String, dynamic>> chapters,
+    required int currentChapterIndex,
+    required bool isOwned,
+    required bool hasError,
+    required bool isLoading,
+    required bool isPlaying,
+  }) {
     // Use access-aware checks: only enable if user can play the chapter
-    final canPrevious = audio.hasPreviousPlayableChapter;
-    final canNext = audio.hasNextPlayableChapter;
+    final canPrevious = _hasPreviousPlayableChapter(chapters, currentChapterIndex, isOwned);
+    final canNext = _hasNextPlayableChapter(chapters, currentChapterIndex, isOwned);
 
     // Use LayoutBuilder for responsive sizing
     return LayoutBuilder(
@@ -524,7 +688,7 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
             _buildControlButton(
               icon: Icons.skip_previous_rounded,
               size: controlSize,
-              enabled: canPrevious && !audio.hasError,
+              enabled: canPrevious && !hasError,
               onPressed: () => notifier.previousChapter(),
             ),
             SizedBox(width: spacing * 0.8),
@@ -533,20 +697,26 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
             _buildControlButton(
               icon: Icons.replay_10_rounded,
               size: skipSize,
-              enabled: !audio.hasError,
+              enabled: !hasError,
               onPressed: () => notifier.skipBackward(),
             ),
             SizedBox(width: spacing),
 
             // Play/Pause
-            _buildPlayPauseButton(audio, notifier, size: playButtonSize),
+            _buildPlayPauseButton(
+              isPlaying: isPlaying,
+              isLoading: isLoading,
+              hasError: hasError,
+              notifier: notifier,
+              size: playButtonSize,
+            ),
             SizedBox(width: spacing),
 
             // Skip Forward
             _buildControlButton(
               icon: Icons.forward_10_rounded,
               size: skipSize,
-              enabled: !audio.hasError,
+              enabled: !hasError,
               onPressed: () => notifier.skipForward(),
             ),
             SizedBox(width: spacing * 0.8),
@@ -555,7 +725,7 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
             _buildControlButton(
               icon: Icons.skip_next_rounded,
               size: controlSize,
-              enabled: canNext && !audio.hasError,
+              enabled: canNext && !hasError,
               onPressed: () => notifier.nextChapter(),
             ),
           ],
@@ -587,21 +757,27 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
     );
   }
 
-  Widget _buildPlayPauseButton(AudioState audio, AudioNotifier notifier, {double size = 80}) {
+  Widget _buildPlayPauseButton({
+    required bool isPlaying,
+    required bool isLoading,
+    required bool hasError,
+    required AudioNotifier notifier,
+    double size = 80,
+  }) {
     final iconSize = size * 0.5;
     final loaderSize = size * 0.4;
 
     Widget child;
     Color bgColor = AppColors.primary;
 
-    if (audio.hasError) {
+    if (hasError) {
       bgColor = AppColors.error;
       child = IconButton(
         icon: Icon(Icons.refresh_rounded, size: iconSize * 0.9),
         color: Colors.white,
         onPressed: () => notifier.retry(),
       );
-    } else if (audio.isLoading) {
+    } else if (isLoading) {
       child = Center(
         child: SizedBox(
           width: loaderSize,
@@ -615,7 +791,7 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
     } else {
       child = IconButton(
         icon: Icon(
-          audio.isPlaying ? Icons.pause_rounded : Icons.play_arrow_rounded,
+          isPlaying ? Icons.pause_rounded : Icons.play_arrow_rounded,
           size: iconSize,
         ),
         color: Colors.white,
@@ -641,18 +817,23 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
     );
   }
 
-  Widget _buildSecondaryControls(
-    AudioState audio,
-    WidgetRef ref,
-    List<Map<String, dynamic>> chapters,
-  ) {
+  Widget _buildSecondaryControls({
+    required List<Map<String, dynamic>> chapters,
+    required int? audiobookId,
+    required int currentChapterIndex,
+    required int positionSeconds,
+    required double playbackSpeed,
+    required SleepTimerMode sleepTimerMode,
+    required Duration sleepTimerRemaining,
+    required bool hasSleepTimer,
+    required bool isOwned,
+    required WidgetRef ref,
+  }) {
     final bookmarkState = ref.watch(bookmarkProvider);
-    final audiobookId = audio.audiobook?['id'] as int?;
-    final currentChapter = chapters.isNotEmpty && audio.currentChapterIndex < chapters.length
-        ? chapters[audio.currentChapterIndex]
+    final currentChapter = chapters.isNotEmpty && currentChapterIndex < chapters.length
+        ? chapters[currentChapterIndex]
         : null;
     final chapterId = currentChapter?['id'] as int?;
-    final positionSeconds = audio.position.inSeconds;
 
     // Check if there's a bookmark near current position
     final hasBookmark = audiobookId != null &&
@@ -671,8 +852,8 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
           // Playback Speed
           _buildSecondaryButton(
             icon: Icons.speed_rounded,
-            label: '${audio.playbackSpeed}x',
-            onPressed: () => _showSpeedDialog(context, ref, audio.playbackSpeed),
+            label: '${playbackSpeed}x',
+            onPressed: () => _showSpeedDialog(context, ref, playbackSpeed),
           ),
 
           // Divider
@@ -692,7 +873,12 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
           _buildVerticalDivider(),
 
           // Sleep Timer
-          _buildSleepTimerButton(audio, ref),
+          _buildSleepTimerButton(
+            sleepTimerMode: sleepTimerMode,
+            sleepTimerRemaining: sleepTimerRemaining,
+            hasSleepTimer: hasSleepTimer,
+            ref: ref,
+          ),
 
           // Divider
           _buildVerticalDivider(),
@@ -703,7 +889,13 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
             label: '${chapters.length} فصل',
             onPressed: chapters.isEmpty
                 ? null
-                : () => _showChaptersSheet(context, ref, audio, chapters),
+                : () => _showChaptersSheet(
+                      context,
+                      ref,
+                      chapters,
+                      currentChapterIndex,
+                      isOwned,
+                    ),
           ),
         ],
       ),
@@ -818,7 +1010,7 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
           maxLines: 3,
           decoration: InputDecoration(
             hintText: 'یادداشت خود را بنویسید...',
-            hintStyle: TextStyle(color: AppColors.textTertiary),
+            hintStyle: const TextStyle(color: AppColors.textTertiary),
             filled: true,
             fillColor: AppColors.surfaceLight,
             border: OutlineInputBorder(
@@ -897,7 +1089,7 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
                   ),
                   Text(
                     '${bookmarks.length} نشان',
-                    style: TextStyle(
+                    style: const TextStyle(
                       fontSize: 14,
                       color: AppColors.textTertiary,
                     ),
@@ -908,7 +1100,7 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
             // Bookmarks List
             Expanded(
               child: bookmarks.isEmpty
-                  ? Center(
+                  ? const Center(
                       child: Column(
                         mainAxisSize: MainAxisSize.min,
                         children: [
@@ -917,7 +1109,7 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
                             size: 48,
                             color: AppColors.textTertiary,
                           ),
-                          const SizedBox(height: 12),
+                          SizedBox(height: 12),
                           Text(
                             'هنوز نشانی اضافه نکرده‌اید',
                             style: TextStyle(
@@ -998,7 +1190,7 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
               const SizedBox(height: 4),
               Text(
                 bookmark.formattedPosition,
-                style: TextStyle(
+                style: const TextStyle(
                   color: AppColors.textTertiary,
                   fontSize: 13,
                 ),
@@ -1007,7 +1199,7 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
                 const SizedBox(height: 4),
                 Text(
                   bookmark.note!,
-                  style: TextStyle(
+                  style: const TextStyle(
                     color: AppColors.textSecondary,
                     fontSize: 12,
                     fontStyle: FontStyle.italic,
@@ -1080,14 +1272,19 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
     );
   }
 
-  Widget _buildSleepTimerButton(AudioState audio, WidgetRef ref) {
-    final isActive = audio.hasSleepTimer;
+  Widget _buildSleepTimerButton({
+    required SleepTimerMode sleepTimerMode,
+    required Duration sleepTimerRemaining,
+    required bool hasSleepTimer,
+    required WidgetRef ref,
+  }) {
+    final isActive = hasSleepTimer;
     String label;
 
-    if (audio.sleepTimerMode == SleepTimerMode.endOfChapter) {
+    if (sleepTimerMode == SleepTimerMode.endOfChapter) {
       label = 'پایان فصل';
-    } else if (audio.sleepTimerMode == SleepTimerMode.timed) {
-      final remaining = audio.sleepTimerRemaining;
+    } else if (sleepTimerMode == SleepTimerMode.timed) {
+      final remaining = sleepTimerRemaining;
       if (remaining.inMinutes > 0) {
         label = '${remaining.inMinutes} دقیقه';
       } else {
@@ -1100,7 +1297,13 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
     return Material(
       color: Colors.transparent,
       child: InkWell(
-        onTap: () => _showSleepTimerSheet(context, ref, audio),
+        onTap: () => _showSleepTimerSheet(
+          context,
+          ref,
+          sleepTimerMode,
+          sleepTimerRemaining,
+          hasSleepTimer,
+        ),
         borderRadius: BorderRadius.circular(12),
         child: Padding(
           padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
@@ -1128,7 +1331,13 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
     );
   }
 
-  void _showSleepTimerSheet(BuildContext context, WidgetRef ref, AudioState audio) {
+  void _showSleepTimerSheet(
+    BuildContext context,
+    WidgetRef ref,
+    SleepTimerMode sleepTimerMode,
+    Duration sleepTimerRemaining,
+    bool hasSleepTimer,
+  ) {
     final timerOptions = [
       {'minutes': 5, 'label': '۵ دقیقه'},
       {'minutes': 10, 'label': '۱۰ دقیقه'},
@@ -1168,7 +1377,7 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
               ),
             ),
             const SizedBox(height: 8),
-            Text(
+            const Text(
               'پخش پس از زمان تعیین‌شده متوقف می‌شود',
               style: TextStyle(
                 fontSize: 13,
@@ -1187,11 +1396,11 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
                 width: double.infinity,
                 padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 20),
                 decoration: BoxDecoration(
-                  color: audio.sleepTimerMode == SleepTimerMode.endOfChapter
+                  color: sleepTimerMode == SleepTimerMode.endOfChapter
                       ? AppColors.primary.withOpacity(0.15)
                       : AppColors.surfaceLight,
                   borderRadius: BorderRadius.circular(16),
-                  border: audio.sleepTimerMode == SleepTimerMode.endOfChapter
+                  border: sleepTimerMode == SleepTimerMode.endOfChapter
                       ? Border.all(color: AppColors.primary.withOpacity(0.5))
                       : null,
                 ),
@@ -1200,7 +1409,7 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
                     Icon(
                       Icons.bookmark_outline,
                       size: 24,
-                      color: audio.sleepTimerMode == SleepTimerMode.endOfChapter
+                      color: sleepTimerMode == SleepTimerMode.endOfChapter
                           ? AppColors.primary
                           : AppColors.textSecondary,
                     ),
@@ -1214,13 +1423,13 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
                             style: TextStyle(
                               fontSize: 16,
                               fontWeight: FontWeight.w600,
-                              color: audio.sleepTimerMode == SleepTimerMode.endOfChapter
+                              color: sleepTimerMode == SleepTimerMode.endOfChapter
                                   ? AppColors.primary
                                   : AppColors.textPrimary,
                             ),
                           ),
                           const SizedBox(height: 2),
-                          Text(
+                          const Text(
                             'وقتی فصل تمام شد متوقف می‌شود',
                             style: TextStyle(
                               fontSize: 12,
@@ -1228,9 +1437,9 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
                             ),
                           ),
                         ],
-                      ),
+                        ),
                     ),
-                    if (audio.sleepTimerMode == SleepTimerMode.endOfChapter)
+                    if (sleepTimerMode == SleepTimerMode.endOfChapter)
                       const Icon(Icons.check_circle, color: AppColors.primary, size: 22),
                   ],
                 ),
@@ -1246,8 +1455,8 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
               children: timerOptions.map((option) {
                 final minutes = option['minutes'] as int;
                 final label = option['label'] as String;
-                final isSelected = audio.sleepTimerMode == SleepTimerMode.timed &&
-                    audio.sleepTimerRemaining.inMinutes == minutes;
+                final isSelected = sleepTimerMode == SleepTimerMode.timed &&
+                    sleepTimerRemaining.inMinutes == minutes;
 
                 return GestureDetector(
                   onTap: () {
@@ -1277,7 +1486,7 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
             ),
 
             // Cancel timer button (if active)
-            if (audio.hasSleepTimer) ...[
+            if (hasSleepTimer) ...[
               const SizedBox(height: 24),
               SizedBox(
                 width: double.infinity,
@@ -1382,9 +1591,11 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
   void _showChaptersSheet(
     BuildContext context,
     WidgetRef ref,
-    AudioState audio,
     List<Map<String, dynamic>> displayChapters,
+    int currentChapterIndex,
+    bool isOwned,
   ) {
+    AppLogger.audio('PLAYER_SCREEN: Opening chapter list (${displayChapters.length} chapters, current=$currentChapterIndex)');
     showModalBottomSheet<void>(
       context: context,
       backgroundColor: AppColors.surface,
@@ -1427,7 +1638,7 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
                   ),
                   Text(
                     '${displayChapters.length} فصل',
-                    style: TextStyle(
+                    style: const TextStyle(
                       fontSize: 14,
                       color: AppColors.textTertiary,
                     ),
@@ -1443,9 +1654,9 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
                 itemCount: displayChapters.length,
                 itemBuilder: (context, index) {
                   final chapter = displayChapters[index];
-                  final isCurrent = index == audio.currentChapterIndex;
+                  final isCurrent = index == currentChapterIndex;
                   final duration = (chapter['duration_seconds'] as int?) ?? 0;
-                  final canPlay = audio.canPlayChapter(index);
+                  final canPlay = _canPlayChapter(displayChapters, index, isOwned);
                   final isPreview = chapter['is_preview'] == true;
 
                   return Container(
@@ -1470,10 +1681,10 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
                           child: isCurrent
                               ? const Icon(Icons.graphic_eq_rounded, color: Colors.white, size: 22)
                               : !canPlay
-                                  ? Icon(Icons.lock_outline, color: AppColors.textTertiary, size: 20)
+                                  ? const Icon(Icons.lock_outline, color: AppColors.textTertiary, size: 20)
                                   : Text(
                                       '${index + 1}',
-                                      style: TextStyle(
+                                      style: const TextStyle(
                                         color: AppColors.textSecondary,
                                         fontWeight: FontWeight.w600,
                                         fontSize: 16,
@@ -1495,7 +1706,7 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
                               ),
                             ),
                           ),
-                          if (isPreview && !audio.isOwned)
+                          if (isPreview && !isOwned)
                             Container(
                               margin: const EdgeInsets.only(right: 8),
                               padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
@@ -1516,7 +1727,7 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
                       ),
                       subtitle: Text(
                         Formatters.formatDurationLong(duration),
-                        style: TextStyle(
+                        style: const TextStyle(
                           color: AppColors.textTertiary,
                           fontSize: 13,
                         ),
@@ -1550,11 +1761,17 @@ class _PlayerScreenState extends ConsumerState<PlayerScreen> {
                                 ),
                       onTap: canPlay
                           ? () {
+                              final chapter = displayChapters[index];
+                              AppLogger.audio(
+                                'PLAYER_SCREEN: Chapter tapped - index=$index, '
+                                'chapterId=${chapter['id']}, title="${chapter['title_fa']}"',
+                              );
                               ref.read(audioProvider.notifier).goToChapter(index);
                               Navigator.pop(context);
                             }
                           : () {
                               // Show locked chapter message
+                              AppLogger.audio('PLAYER_SCREEN: Locked chapter tapped - index=$index');
                               Navigator.pop(context);
                               ScaffoldMessenger.of(context).showSnackBar(
                                 const SnackBar(
diff --git a/lib/screens/support/create_ticket_screen.dart b/lib/screens/support/create_ticket_screen.dart
index 0d2d778..428feb4 100644
--- a/lib/screens/support/create_ticket_screen.dart
+++ b/lib/screens/support/create_ticket_screen.dart
@@ -117,12 +117,12 @@ class _CreateTicketScreenState extends ConsumerState<CreateTicketScreen> {
                       // Info Card
                       Card(
                         color: AppColors.primary.withOpacity(0.1),
-                        child: Padding(
-                          padding: const EdgeInsets.all(12),
+                        child: const Padding(
+                          padding: EdgeInsets.all(12),
                           child: Row(
                             children: [
-                              const Icon(Icons.info_outline, color: AppColors.primary),
-                              const SizedBox(width: 12),
+                              Icon(Icons.info_outline, color: AppColors.primary),
+                              SizedBox(width: 12),
                               Expanded(
                                 child: Text(
                                   'تیم پشتیبانی در اسرع وقت پاسخگوی شما خواهد بود.',
diff --git a/lib/screens/support/user_support_screen.dart b/lib/screens/support/user_support_screen.dart
index e807987..c2093fd 100644
--- a/lib/screens/support/user_support_screen.dart
+++ b/lib/screens/support/user_support_screen.dart
@@ -48,7 +48,7 @@ class UserSupportScreen extends ConsumerWidget {
                     const SizedBox(height: 16),
                     const Text('تیکتی ثبت نشده است', style: TextStyle(color: AppColors.textSecondary)),
                     const SizedBox(height: 8),
-                    Text(
+                    const Text(
                       'برای ارتباط با پشتیبانی یک تیکت جدید ایجاد کنید',
                       style: TextStyle(color: AppColors.textTertiary, fontSize: 12),
                       textAlign: TextAlign.center,
@@ -159,7 +159,7 @@ class _TicketCard extends StatelessWidget {
                         const SizedBox(height: 4),
                         Text(
                           _getTypeLabel(type),
-                          style: TextStyle(color: AppColors.textTertiary, fontSize: 12),
+                          style: const TextStyle(color: AppColors.textTertiary, fontSize: 12),
                         ),
                       ],
                     ),
@@ -182,7 +182,7 @@ class _TicketCard extends StatelessWidget {
                       Expanded(
                         child: Text(
                           (audiobook['title_fa'] as String?) ?? '',
-                          style: TextStyle(color: AppColors.textSecondary, fontSize: 12),
+                          style: const TextStyle(color: AppColors.textSecondary, fontSize: 12),
                           maxLines: 1,
                           overflow: TextOverflow.ellipsis,
                         ),
@@ -200,7 +200,7 @@ class _TicketCard extends StatelessWidget {
                     createdAt != null
                         ? '${createdAt.year}/${createdAt.month}/${createdAt.day}'
                         : '',
-                    style: TextStyle(color: AppColors.textTertiary, fontSize: 11),
+                    style: const TextStyle(color: AppColors.textTertiary, fontSize: 11),
                   ),
                   const Spacer(),
                   const Icon(Icons.chevron_left, color: AppColors.textTertiary),
diff --git a/lib/screens/support/user_ticket_detail_screen.dart b/lib/screens/support/user_ticket_detail_screen.dart
index 3306231..6f3e307 100644
--- a/lib/screens/support/user_ticket_detail_screen.dart
+++ b/lib/screens/support/user_ticket_detail_screen.dart
@@ -150,7 +150,7 @@ class _UserTicketDetailScreenState extends ConsumerState<UserTicketDetailScreen>
                           const SizedBox(width: 12),
                           Text(
                             'شماره تیکت: #${widget.ticketId}',
-                            style: TextStyle(color: AppColors.textTertiary, fontSize: 12),
+                            style: const TextStyle(color: AppColors.textTertiary, fontSize: 12),
                           ),
                         ],
                       ),
@@ -169,7 +169,7 @@ class _UserTicketDetailScreenState extends ConsumerState<UserTicketDetailScreen>
                               Expanded(
                                 child: Text(
                                   (audiobook['title_fa'] as String?) ?? '',
-                                  style: TextStyle(color: AppColors.textSecondary, fontSize: 12),
+                                  style: const TextStyle(color: AppColors.textSecondary, fontSize: 12),
                                   maxLines: 1,
                                   overflow: TextOverflow.ellipsis,
                                 ),
@@ -205,11 +205,11 @@ class _UserTicketDetailScreenState extends ConsumerState<UserTicketDetailScreen>
                   Container(
                     padding: const EdgeInsets.all(16),
                     color: AppColors.surface,
-                    child: Row(
+                    child: const Row(
                       mainAxisAlignment: MainAxisAlignment.center,
                       children: [
-                        const Icon(Icons.lock, color: AppColors.textTertiary),
-                        const SizedBox(width: 8),
+                        Icon(Icons.lock, color: AppColors.textTertiary),
+                        SizedBox(width: 8),
                         Text(
                           'این تیکت بسته شده است',
                           style: TextStyle(color: AppColors.textTertiary),
@@ -316,7 +316,7 @@ class _UserTicketDetailScreenState extends ConsumerState<UserTicketDetailScreen>
         color: AppColors.textTertiary.withOpacity(0.1),
         borderRadius: BorderRadius.circular(4),
       ),
-      child: Text(label, style: TextStyle(color: AppColors.textSecondary, fontSize: 11)),
+      child: Text(label, style: const TextStyle(color: AppColors.textSecondary, fontSize: 11)),
     );
   }
 }
@@ -346,10 +346,10 @@ class _MessageBubble extends StatelessWidget {
         mainAxisAlignment: isAdmin ? MainAxisAlignment.start : MainAxisAlignment.end,
         children: [
           if (isAdmin) ...[
-            CircleAvatar(
+            const CircleAvatar(
               radius: 18,
               backgroundColor: AppColors.primary,
-              child: const Icon(Icons.support_agent, color: Colors.white, size: 20),
+              child: Icon(Icons.support_agent, color: Colors.white, size: 20),
             ),
             const SizedBox(width: 8),
           ],
@@ -386,7 +386,7 @@ class _MessageBubble extends StatelessWidget {
                       if (createdAt != null)
                         Text(
                           '${createdAt.hour.toString().padLeft(2, '0')}:${createdAt.minute.toString().padLeft(2, '0')}',
-                          style: TextStyle(color: AppColors.textTertiary, fontSize: 10),
+                          style: const TextStyle(color: AppColors.textTertiary, fontSize: 10),
                         ),
                     ],
                   ),
@@ -401,10 +401,10 @@ class _MessageBubble extends StatelessWidget {
           ),
           if (!isAdmin) ...[
             const SizedBox(width: 8),
-            CircleAvatar(
+            const CircleAvatar(
               radius: 18,
               backgroundColor: AppColors.surfaceLight,
-              child: const Icon(Icons.person, color: AppColors.textSecondary, size: 20),
+              child: Icon(Icons.person, color: AppColors.textSecondary, size: 20),
             ),
           ],
         ],
diff --git a/lib/services/audio_handler.dart b/lib/services/audio_handler.dart
index c1c69f1..d389e79 100644
--- a/lib/services/audio_handler.dart
+++ b/lib/services/audio_handler.dart
@@ -2,6 +2,7 @@ import 'package:audio_service/audio_service.dart';
 import 'package:audio_session/audio_session.dart';
 import 'package:just_audio/just_audio.dart';
 import 'package:myna/utils/app_logger.dart';
+import 'package:myna/services/notification_permission_service.dart';
 
 /// Custom AudioHandler that bridges just_audio with audio_service
 /// for background playback and system media controls.
@@ -13,11 +14,18 @@ class MynaAudioHandler extends BaseAudioHandler with SeekHandler {
   List<Map<String, dynamic>> _chapters = [];
   int _currentChapterIndex = 0;
 
-  // Callbacks for progress saving
+  // Current playback speed - preserved across chapters
+  double _currentSpeed = 1.0;
+
+  // Callbacks for progress saving and chapter transitions
   void Function()? onProgressSave;
   void Function(int chapterIndex)? onChapterComplete;
+  /// Called when playback naturally completes (reaches end of audio).
+  /// This is critical for background auto-next to work properly.
+  void Function()? onPlaybackComplete;
 
   MynaAudioHandler() {
+    AppLogger.audioNotif('HANDLER: MynaAudioHandler constructor called');
     _init();
   }
 
@@ -25,25 +33,146 @@ class MynaAudioHandler extends BaseAudioHandler with SeekHandler {
   Map<String, dynamic>? get currentAudiobook => _currentAudiobook;
   List<Map<String, dynamic>> get chapters => _chapters;
   int get currentChapterIndex => _currentChapterIndex;
+  double get currentSpeed => _currentSpeed;
 
   Future<void> _init() async {
+    AppLogger.audioNotif('HANDLER: _init() started - configuring audio session');
+    AppLogger.audio('HANDLER(iOS): Initializing audio session...');
+
     // Configure audio session for audiobook playback
+    // CRITICAL: Do NOT use duckOthers - it prevents proper interruption behavior
+    // Using .none means other apps will properly interrupt us and vice versa
     final session = await AudioSession.instance;
-    await session.configure(const AudioSessionConfiguration.speech());
+    await session.configure(const AudioSessionConfiguration(
+      avAudioSessionCategory: AVAudioSessionCategory.playback,
+      // FIXED: Use .none instead of .duckOthers to properly handle interruptions
+      // This ensures when another app (YouTube, Spotify) starts playing,
+      // Parasto will pause instead of continuing to play underneath
+      avAudioSessionCategoryOptions: AVAudioSessionCategoryOptions.none,
+      avAudioSessionMode: AVAudioSessionMode.spokenAudio,
+      avAudioSessionRouteSharingPolicy: AVAudioSessionRouteSharingPolicy.defaultPolicy,
+      avAudioSessionSetActiveOptions: AVAudioSessionSetActiveOptions.none,
+      androidAudioAttributes: AndroidAudioAttributes(
+        contentType: AndroidAudioContentType.speech,
+        flags: AndroidAudioFlags.none,
+        usage: AndroidAudioUsage.media,
+      ),
+      androidAudioFocusGainType: AndroidAudioFocusGainType.gain,
+      androidWillPauseWhenDucked: true,
+    ));
+
+    // Activate the session for background playback
+    await session.setActive(true);
+    AppLogger.audio('HANDLER(iOS): Audio session configured with playback category (no ducking)');
+
+    // Handle audio interruptions (phone calls, other apps starting audio)
+    session.interruptionEventStream.listen((event) {
+      AppLogger.audio('HANDLER(iOS): Audio interruption - begin=${event.begin}, type=${event.type}');
+      if (event.begin) {
+        // Audio interrupted - pause playback
+        if (_player.playing) {
+          AppLogger.audio('HANDLER(iOS): Interruption began (type=${event.type}) - pausing');
+          pause();
+        }
+      } else {
+        // Interruption ended
+        // SAFE BEHAVIOR: Stay paused - let user manually resume
+        // This prevents unexpected audio when user is done with other app
+        AppLogger.audio('HANDLER(iOS): Interruption ended - staying paused (user must manually resume)');
+      }
+    });
+
+    // Handle becoming noisy (headphones unplugged)
+    session.becomingNoisyEventStream.listen((_) {
+      AppLogger.audio('HANDLER(iOS): Headphones unplugged - pausing');
+      // Pause when headphones are unplugged
+      if (_player.playing) {
+        pause();
+      }
+    });
 
     // Listen to player state and broadcast to system
-    _player.playbackEventStream.listen(_broadcastState);
+    AppLogger.audioNotif('HANDLER: Setting up playbackEventStream listener');
+    _player.playbackEventStream.listen(
+      _broadcastState,
+      onError: (Object error, StackTrace stackTrace) {
+        AppLogger.audioNotif('HANDLER: playbackEventStream ERROR: $error');
+        AppLogger.e('HANDLER: playbackEventStream error', error: error, stackTrace: stackTrace);
+      },
+    );
 
     // Listen for completion
     _player.processingStateStream.listen((state) {
+      AppLogger.audioNotif('HANDLER: processingStateStream event: $state');
       if (state == ProcessingState.completed) {
+        // [AUTO_NEXT] Log completion detection at handler level
+        final currentMediaId = mediaItem.valueOrNull?.id ?? 'null';
+        final chapterIdx = _currentChapterIndex;
+        final isPlaying = _player.playing;
+        AppLogger.audio('[AUTO_NEXT] CH_COMPLETE_HANDLER: processingState=completed, '
+            'mediaItemId=$currentMediaId, chapterIndex=$chapterIdx, playing=$isPlaying');
         _handleCompletion();
       }
     });
+
+    // FIX: Listen for duration changes from the player
+    // When just_audio discovers the actual duration (after loading audio source),
+    // update the MediaItem so iOS Control Center shows correct duration instead of -:--
+    _player.durationStream.listen((duration) {
+      if (duration != null && duration > Duration.zero) {
+        _updateMediaItemDuration(duration);
+      }
+    });
+
+    AppLogger.audioNotif('HANDLER: _init() completed - audio handler ready');
+    AppLogger.audio('Audio handler initialized');
+  }
+
+  /// Update the MediaItem with the actual duration discovered by the player.
+  /// This is critical for iOS Control Center to show correct duration instead of -:--
+  void _updateMediaItemDuration(Duration duration) {
+    final currentItem = mediaItem.valueOrNull;
+    if (currentItem == null) return;
+
+    // Only update if duration actually changed (avoid unnecessary broadcasts)
+    if (currentItem.duration == duration) return;
+
+    AppLogger.audio(
+      'HANDLER(iOS): Updating MediaItem duration from ${currentItem.duration?.inSeconds ?? 0}s to ${duration.inSeconds}s',
+    );
+
+    // Create updated MediaItem with correct duration
+    final updatedItem = currentItem.copyWith(duration: duration);
+    mediaItem.add(updatedItem);
+
+    // Re-broadcast state to ensure iOS Control Center picks up the new duration
+    _broadcastState(_player.playbackEvent);
   }
 
   void _broadcastState(PlaybackEvent event) {
     final playing = _player.playing;
+    final processingState = _player.processingState;
+
+    // Map just_audio states to audio_service states
+    final audioProcessingState = const {
+      ProcessingState.idle: AudioProcessingState.idle,
+      ProcessingState.loading: AudioProcessingState.loading,
+      ProcessingState.buffering: AudioProcessingState.buffering,
+      ProcessingState.ready: AudioProcessingState.ready,
+      ProcessingState.completed: AudioProcessingState.completed,
+    }[processingState] ?? AudioProcessingState.idle;
+
+    // Log significant state transitions for Android notification debugging
+    // These are the states that should trigger/update the notification
+    if (processingState == ProcessingState.ready ||
+        processingState == ProcessingState.loading ||
+        processingState == ProcessingState.completed) {
+      AppLogger.audioNotif('PLAYBACK_STATE: processingState=$processingState, '
+          'audioProcessingState=$audioProcessingState, playing=$playing, '
+          'position=${_player.position.inSeconds}s, buffered=${_player.bufferedPosition.inSeconds}s');
+    }
+
+    // FIX: Broadcast state with full controls for iOS lock screen
     playbackState.add(playbackState.value.copyWith(
       controls: [
         MediaControl.skipToPrevious,
@@ -56,31 +185,41 @@ class MynaAudioHandler extends BaseAudioHandler with SeekHandler {
         MediaAction.seek,
         MediaAction.seekForward,
         MediaAction.seekBackward,
+        MediaAction.skipToPrevious,
+        MediaAction.skipToNext,
+        MediaAction.play,
+        MediaAction.pause,
+        MediaAction.stop,
       },
       androidCompactActionIndices: const [0, 2, 4],
-      processingState: const {
-        ProcessingState.idle: AudioProcessingState.idle,
-        ProcessingState.loading: AudioProcessingState.loading,
-        ProcessingState.buffering: AudioProcessingState.buffering,
-        ProcessingState.ready: AudioProcessingState.ready,
-        ProcessingState.completed: AudioProcessingState.completed,
-      }[_player.processingState]!,
+      processingState: audioProcessingState,
       playing: playing,
       updatePosition: _player.position,
       bufferedPosition: _player.bufferedPosition,
       speed: _player.speed,
       queueIndex: _currentChapterIndex,
     ));
+
+    // Log when playing state changes (critical for notification visibility)
+    if (processingState == ProcessingState.ready) {
+      AppLogger.audioNotif('PLAYBACK_STATE: State broadcast complete - playing=$playing, '
+          'controls=[skipToPrev, rewind, ${playing ? "pause" : "play"}, fastFwd, skipToNext]');
+      AppLogger.audio('HANDLER: Playback state broadcast - playing=$playing, position=${_player.position.inSeconds}s');
+    }
   }
 
   void _handleCompletion() {
-    if (_currentChapterIndex < _chapters.length - 1) {
-      // Auto-advance to next chapter
-      skipToNext();
-    } else {
-      // Audiobook complete
-      onChapterComplete?.call(_currentChapterIndex);
-    }
+    // BACKGROUND PLAYBACK FIX: Notify AudioNotifier that playback completed.
+    // When the app is in background, Flutter's stream listeners may not receive events
+    // promptly. By actively calling the callback here (from audio_service's background
+    // execution context), we ensure chapter auto-advance works even when app is minimized.
+    //
+    // The AudioNotifier's _onChapterComplete() will handle the autoPlayNext logic.
+    final hasCallback = onPlaybackComplete != null;
+    AppLogger.audio('[AUTO_NEXT] CH_COMPLETE_HANDLER_CALLBACK: chapterIndex=$_currentChapterIndex, '
+        'hasCallback=$hasCallback, invoking callback...');
+    onPlaybackComplete?.call();
+    AppLogger.audio('[AUTO_NEXT] CH_COMPLETE_HANDLER_CALLBACK: callback invoked (if present)');
   }
 
   /// Load and play a chapter
@@ -92,15 +231,19 @@ class MynaAudioHandler extends BaseAudioHandler with SeekHandler {
     Duration? startPosition,
     bool isLocalFile = false,
   }) async {
+    // [AUTO_NEXT] Log playChapter call for tracking auto-next flow
+    AppLogger.audio('[AUTO_NEXT] CH_PLAYCHAPTER: audiobookId=${audiobook['id']}, '
+        'chapterIndex=$chapterIndex, totalChapters=${chapters.length}');
+    AppLogger.audioNotif('HANDLER: playChapter() ENTRY - '
+        'audiobookId=${audiobook['id']}, chapterIndex=$chapterIndex, '
+        'totalChapters=${chapters.length}, isLocalFile=$isLocalFile');
+
     if (chapters.isEmpty || chapterIndex < 0 || chapterIndex >= chapters.length) {
-      AppLogger.e('Invalid chapter index: $chapterIndex');
+      AppLogger.audioNotif('HANDLER: playChapter() FAILED - invalid chapter index: $chapterIndex');
+      AppLogger.e('HANDLER: Invalid chapter index: $chapterIndex');
       return;
     }
 
-    _currentAudiobook = audiobook;
-    _chapters = chapters;
-    _currentChapterIndex = chapterIndex;
-
     final chapter = chapters[chapterIndex];
     final title = (chapter['title_fa'] as String?) ?? 'فصل ${chapterIndex + 1}';
     final bookTitle = (audiobook['title'] as String?) ??
@@ -108,20 +251,72 @@ class MynaAudioHandler extends BaseAudioHandler with SeekHandler {
         'کتاب صوتی';
     final coverUrl = audiobook['cover_url'] as String?;
 
-    // Update media item for notification/lock screen
-    mediaItem.add(MediaItem(
+    AppLogger.audio(
+      'HANDLER: playChapter() - index=$chapterIndex, title="$title", '
+      'isLocal=$isLocalFile',
+    );
+
+    // CRITICAL FIX: Stop the player before setting a new source
+    // This prevents PlayerInterruptedException when switching chapters while playing
+    if (_player.playing || _player.processingState != ProcessingState.idle) {
+      AppLogger.audio('HANDLER: Stopping player before loading new source');
+      await _player.stop();
+    }
+
+    _currentAudiobook = audiobook;
+    _chapters = chapters;
+    _currentChapterIndex = chapterIndex;
+
+    // Get narrator/artist name for display
+    // Priority: narrator profile > author field > default "پرستو"
+    String artistName = 'پرستو';
+    if (audiobook['profiles'] != null) {
+      final profile = audiobook['profiles'] as Map<String, dynamic>;
+      artistName = (profile['display_name'] as String?) ??
+          (profile['full_name'] as String?) ??
+          (audiobook['author'] as String?) ??
+          'پرستو';
+    } else if (audiobook['author'] != null) {
+      artistName = audiobook['author'] as String;
+    }
+
+    // Update media item for notification/lock screen (iOS Control Center & Android notification)
+    final durationSeconds = (chapter['duration_seconds'] as int?) ?? 0;
+    final newMediaItem = MediaItem(
       id: '${audiobook['id']}_$chapterIndex',
       album: bookTitle,
       title: title,
-      artist: audiobook['author'] as String? ?? 'مینا',
-      duration: Duration(seconds: (chapter['duration_seconds'] as int?) ?? 0),
+      artist: artistName,
+      duration: Duration(seconds: durationSeconds),
       artUri: coverUrl != null ? Uri.parse(coverUrl) : null,
       extras: {
         'audiobook_id': audiobook['id'],
         'chapter_index': chapterIndex,
         'is_offline': isLocalFile,
       },
-    ));
+    );
+
+    // CRITICAL: Log all MediaItem fields for Android notification debugging
+    // Missing or malformed artUri can cause notification issues on some devices
+    AppLogger.audioNotif('MEDIAITEM: Setting MediaItem for notification - '
+        'id="${newMediaItem.id}", title="$title", album="$bookTitle", '
+        'artist="$artistName", duration=${durationSeconds}s, '
+        'artUri=${coverUrl != null ? "present (${coverUrl.length} chars)" : "NULL"}, '
+        'artUriValid=${coverUrl != null && Uri.tryParse(coverUrl) != null}');
+
+    if (coverUrl == null) {
+      AppLogger.audioNotif('MEDIAITEM: WARNING - artUri is null, notification may lack artwork');
+    } else if (Uri.tryParse(coverUrl) == null) {
+      AppLogger.audioNotif('MEDIAITEM: WARNING - artUri is malformed: $coverUrl');
+    }
+
+    AppLogger.audio(
+      'HANDLER(iOS): Now Playing info - title="$title", album="$bookTitle", '
+      'artist="$artistName", artUri=${coverUrl != null ? "present" : "null"}',
+    );
+
+    mediaItem.add(newMediaItem);
+    AppLogger.audioNotif('MEDIAITEM: mediaItem.add() called - notification should update');
 
     // Update queue
     queue.add(_chapters.map((ch) {
@@ -130,7 +325,7 @@ class MynaAudioHandler extends BaseAudioHandler with SeekHandler {
         id: '${audiobook['id']}_$idx',
         album: bookTitle,
         title: (ch['title_fa'] as String?) ?? 'فصل ${idx + 1}',
-        artist: audiobook['author'] as String? ?? 'مینا',
+        artist: audiobook['author'] as String? ?? 'پرستو',
         duration: Duration(seconds: (ch['duration_seconds'] as int?) ?? 0),
         artUri: coverUrl != null ? Uri.parse(coverUrl) : null,
       );
@@ -138,20 +333,40 @@ class MynaAudioHandler extends BaseAudioHandler with SeekHandler {
 
     if (audioUrl != null && audioUrl.isNotEmpty) {
       try {
+        AppLogger.audioNotif('HANDLER: Setting audio source - isLocal=$isLocalFile, urlLength=${audioUrl.length}');
+        AppLogger.audio('HANDLER: Setting audio source');
         if (isLocalFile) {
           await _player.setFilePath(audioUrl);
         } else {
           await _player.setUrl(audioUrl);
         }
+        AppLogger.audioNotif('HANDLER: Audio source set successfully');
+
+        // Apply saved playback speed (persists across chapters)
+        if (_currentSpeed != 1.0) {
+          await _player.setSpeed(_currentSpeed);
+        }
         if (startPosition != null && startPosition > Duration.zero) {
+          AppLogger.audio('HANDLER: Seeking to ${startPosition.inSeconds}s');
           await _player.seek(startPosition);
         }
+
+        AppLogger.audioNotif('HANDLER: Calling _player.play() - this should trigger foreground service');
+        AppLogger.audio('HANDLER: Starting playback');
         await _player.play();
-        AppLogger.audio('Background audio started${isLocalFile ? " (offline)" : ""}', chapter: title);
-      } catch (e) {
-        AppLogger.e('Error playing audio in handler', error: e);
+
+        AppLogger.audioNotif('HANDLER: playChapter() SUCCESS - '
+            '_player.playing=${_player.playing}, '
+            'processingState=${_player.processingState}');
+        AppLogger.audio('HANDLER: Playback started successfully${isLocalFile ? " (offline)" : ""} at ${_currentSpeed}x', chapter: title);
+      } catch (e, st) {
+        AppLogger.audioNotif('HANDLER: playChapter() FAILED - error: $e');
+        AppLogger.e('HANDLER ERROR: Failed to play audio', error: e, stackTrace: st);
         rethrow;
       }
+    } else {
+      AppLogger.audioNotif('HANDLER: playChapter() FAILED - no audio URL provided');
+      AppLogger.e('HANDLER: No audio URL provided');
     }
   }
 
@@ -210,7 +425,12 @@ class MynaAudioHandler extends BaseAudioHandler with SeekHandler {
   }
 
   @override
-  Future<void> setSpeed(double speed) => _player.setSpeed(speed);
+  Future<void> setSpeed(double speed) async {
+    _currentSpeed = speed;
+    await _player.setSpeed(speed);
+    // Update playback state to reflect new speed
+    _broadcastState(_player.playbackEvent);
+  }
 
   @override
   Future<void> skipToQueueItem(int index) async {
@@ -227,16 +447,42 @@ class MynaAudioHandler extends BaseAudioHandler with SeekHandler {
 
 /// Initialize the audio service - call this in main() before runApp
 Future<MynaAudioHandler> initAudioService() async {
-  return await AudioService.init(
-    builder: () => MynaAudioHandler(),
-    config: const AudioServiceConfig(
-      androidNotificationChannelId: 'app.myna.audio',
-      androidNotificationChannelName: 'مینا - پخش صوتی',
-      androidNotificationOngoing: true,
-      androidStopForegroundOnPause: true,
-      androidNotificationIcon: 'drawable/ic_notification',
-      fastForwardInterval: Duration(seconds: 10),
-      rewindInterval: Duration(seconds: 10),
-    ),
-  );
+  AppLogger.audioNotif('INIT: initAudioService() called - starting AudioService initialization');
+  AppLogger.audioNotif('INIT: AudioServiceConfig - '
+      'channelId="app.myna.audio", '
+      'channelName="پرستو - پخش صوتی", '
+      'ongoing=true, '
+      'stopForegroundOnPause=false, '
+      'icon="drawable/ic_notification"');
+
+  try {
+    final handler = await AudioService.init(
+      builder: () {
+        AppLogger.audioNotif('INIT: AudioService.init builder() called - constructing MynaAudioHandler');
+        return MynaAudioHandler();
+      },
+      config: AudioServiceConfig(
+        androidNotificationChannelId: 'app.myna.audio',
+        androidNotificationChannelName: 'پرستو - پخش صوتی',
+        androidNotificationOngoing: true,
+        // Keep notification visible when paused (prevents background kill)
+        androidStopForegroundOnPause: false,
+        // Notification icon must exist in android/app/src/main/res/drawable/
+        androidNotificationIcon: 'drawable/ic_notification',
+        fastForwardInterval: const Duration(seconds: 10),
+        rewindInterval: const Duration(seconds: 10),
+      ),
+    );
+
+    AppLogger.audioNotif('INIT: AudioService.init() completed successfully - handler created');
+
+    // Log notification diagnostics at startup to capture initial state
+    await NotificationPermissionService().logNotificationDiagnostics('STARTUP');
+
+    return handler;
+  } catch (e, st) {
+    AppLogger.audioNotif('INIT: AudioService.init() FAILED - error: $e');
+    AppLogger.e('INIT: AudioService initialization failed', error: e, stackTrace: st);
+    rethrow;
+  }
 }
diff --git a/lib/services/auth_service.dart b/lib/services/auth_service.dart
index 36cb478..71e58fd 100644
--- a/lib/services/auth_service.dart
+++ b/lib/services/auth_service.dart
@@ -1,6 +1,7 @@
 import 'package:flutter_riverpod/flutter_riverpod.dart';
 import 'package:supabase_flutter/supabase_flutter.dart';
 import 'package:myna/models/models.dart';
+import 'package:myna/utils/app_logger.dart';
 
 final supabaseProvider = Provider<SupabaseClient>((ref) {
   return Supabase.instance.client;
@@ -63,7 +64,27 @@ class AuthService {
     await _supabase.auth.signOut();
   }
 
+  /// Request a password reset email.
+  ///
+  /// NOTE(Issue 4): Password reset requires proper Supabase Dashboard configuration:
+  /// 1. Go to Authentication > Email Templates in Supabase Dashboard
+  /// 2. Configure the "Reset Password" email template
+  /// 3. Set the "Site URL" in Authentication > URL Configuration
+  /// 4. Add the app's deep link URL to "Redirect URLs" if using deep links
+  ///
+  /// The email is sent by Supabase, not by this app. If users don't receive
+  /// emails, check:
+  /// - Supabase email provider settings (default has rate limits)
+  /// - Spam/junk folder
+  /// - Email template configuration
   Future<void> resetPassword(String email) async {
-    await _supabase.auth.resetPasswordForEmail(email);
+    AppLogger.d('AuthService: Requesting password reset for email: ${email.substring(0, 3)}***');
+    try {
+      await _supabase.auth.resetPasswordForEmail(email);
+      AppLogger.d('AuthService: Password reset request sent successfully');
+    } catch (e, st) {
+      AppLogger.e('AuthService: Password reset request failed', error: e, stackTrace: st);
+      rethrow;
+    }
   }
 }
diff --git a/lib/services/book_summary_service.dart b/lib/services/book_summary_service.dart
index bce2bc4..5411f45 100644
--- a/lib/services/book_summary_service.dart
+++ b/lib/services/book_summary_service.dart
@@ -1,3 +1,4 @@
+import 'dart:convert';
 import 'package:flutter_riverpod/flutter_riverpod.dart';
 import 'package:supabase_flutter/supabase_flutter.dart';
 import 'package:myna/utils/app_logger.dart';
@@ -12,11 +13,17 @@ class BookSummaryResult {
   final String? summary;
   final bool rateLimitExceeded;
   final bool error;
+  final String? errorType;
+  final int? errorStatus;
+  final String? errorCode;
 
   const BookSummaryResult({
     this.summary,
     this.rateLimitExceeded = false,
     this.error = false,
+    this.errorType,
+    this.errorStatus,
+    this.errorCode,
   });
 
   bool get hasContent => summary != null && summary!.isNotEmpty;
@@ -49,12 +56,26 @@ class BookSummaryService {
   Future<BookSummaryResult> getBookSummary(int audiobookId, {bool forceRefresh = false}) async {
     // Check session cache first (unless force refresh)
     if (!forceRefresh && _sessionCache.containsKey(audiobookId)) {
-      AppLogger.d('BookSummary: Session cache hit for audiobook $audiobookId');
       return BookSummaryResult(summary: _sessionCache[audiobookId]);
     }
 
     try {
-      AppLogger.d('BookSummary: Fetching summary for audiobook $audiobookId (forceRefresh: $forceRefresh)');
+      // Check if we have a valid session - Edge Function requires authenticated user
+      final session = _supabase.auth.currentSession;
+      if (session == null) {
+        AppLogger.w('SUMMARY: No valid session (currentSession is null or expired).');
+        return const BookSummaryResult(error: true, errorType: 'unauthorized');
+      }
+
+      // Check if session is expired and try to refresh
+      if (session.isExpired) {
+        try {
+          await _supabase.auth.refreshSession();
+        } catch (e) {
+          AppLogger.e('SUMMARY: No valid session (currentSession is null or expired).', error: e);
+          return const BookSummaryResult(error: true, errorType: 'unauthorized');
+        }
+      }
 
       // Call the Edge Function with a timeout
       final response = await _supabase.functions
@@ -68,49 +89,56 @@ class BookSummaryService {
           .timeout(
             const Duration(seconds: 20),
             onTimeout: () {
-              AppLogger.w('BookSummary: Request timed out for audiobook $audiobookId');
+              AppLogger.w('SUMMARY: Request timed out');
               throw TimeoutException('Request timed out');
             },
           );
 
-      // Check for rate limit (429)
-      if (response.status == 429) {
-        AppLogger.w('BookSummary: Rate limit exceeded for audiobook $audiobookId');
-        return const BookSummaryResult(rateLimitExceeded: true);
-      }
-
-      // Check for other errors
-      if (response.status != 200) {
-        final errorType = response.data?['error'] as String? ?? 'unknown';
-        AppLogger.w('BookSummary: Error response ($errorType) for audiobook $audiobookId');
-        return const BookSummaryResult(error: true);
-      }
-
-      // Extract summary from response
+      // NOTE: Supabase functions.invoke() throws FunctionException for non-2xx responses
       final summaryFa = response.data?['summary_fa'] as String?;
 
       if (summaryFa == null || summaryFa.isEmpty) {
-        AppLogger.w('BookSummary: Empty summary returned for audiobook $audiobookId');
-        return const BookSummaryResult(error: true);
+        AppLogger.w('SUMMARY: Empty or invalid summary_fa from Edge Function.');
+        return const BookSummaryResult(error: true, errorType: 'invalid_summary');
       }
 
       // Cache in session memory
       _sessionCache[audiobookId] = summaryFa;
-
-      final wasCached = response.data?['cached'] == true;
-      AppLogger.d('BookSummary: Got summary for audiobook $audiobookId (cached: $wasCached)');
-
       return BookSummaryResult(summary: summaryFa);
 
     } on TimeoutException catch (_) {
-      // Already logged above
-      return const BookSummaryResult(error: true);
+      AppLogger.w('SUMMARY: Request timed out');
+      return const BookSummaryResult(error: true, errorType: 'timeout');
     } on FunctionException catch (e) {
-      AppLogger.e('BookSummary: Function error for audiobook $audiobookId', error: e);
-      return const BookSummaryResult(error: true);
+      final errorDetails = _parseErrorDetails(e.details);
+      final errorCode = _extractErrorCode(errorDetails);
+      final errorMessage = _extractErrorMessage(errorDetails);
+      AppLogger.d(
+        'SUMMARY: FunctionException status=${e.status} code=${errorCode ?? 'unknown'} message=${errorMessage ?? 'unknown'}',
+        error: errorDetails,
+      );
+
+      // Check if this is a rate limit error
+      if (e.status == 429) {
+        return const BookSummaryResult(
+          rateLimitExceeded: true,
+          errorType: 'rate_limited',
+          errorStatus: 429,
+          errorCode: 'rate_limit_exceeded',
+        );
+      }
+
+      // Log error for debugging
+      AppLogger.e('SUMMARY: Edge Function error - status=${e.status}', error: e.details);
+      return BookSummaryResult(
+        error: true,
+        errorType: _mapErrorType(e.status, errorCode),
+        errorStatus: e.status,
+        errorCode: errorCode,
+      );
     } catch (e) {
-      AppLogger.e('BookSummary: Unexpected error for audiobook $audiobookId', error: e);
-      return const BookSummaryResult(error: true);
+      AppLogger.e('SUMMARY: Unexpected error', error: e);
+      return const BookSummaryResult(error: true, errorType: 'unknown');
     }
   }
 
@@ -144,6 +172,52 @@ class BookSummaryService {
   }
 }
 
+Map<String, dynamic>? _parseErrorDetails(dynamic details) {
+  if (details == null) return null;
+  if (details is Map<String, dynamic>) return details;
+  if (details is Map) {
+    return Map<String, dynamic>.from(details);
+  }
+  if (details is String) {
+    try {
+      final decoded = jsonDecode(details);
+      if (decoded is Map<String, dynamic>) return decoded;
+      if (decoded is Map) return Map<String, dynamic>.from(decoded);
+    } catch (_) {
+      return null;
+    }
+  }
+  return null;
+}
+
+String? _extractErrorCode(Map<String, dynamic>? details) {
+  if (details == null) return null;
+  final error = details['error'] ?? details['code'];
+  return error?.toString();
+}
+
+String? _extractErrorMessage(Map<String, dynamic>? details) {
+  if (details == null) return null;
+  final message = details['message'] ?? details['error_description'];
+  return message?.toString();
+}
+
+String _mapErrorType(int? status, String? errorCode) {
+  if (errorCode != null && errorCode.isNotEmpty) return errorCode;
+  switch (status) {
+    case 400:
+      return 'invalid_request';
+    case 401:
+      return 'unauthorized';
+    case 404:
+      return 'not_found';
+    case 503:
+      return 'service_unavailable';
+    default:
+      return 'unknown';
+  }
+}
+
 /// Custom exception for timeout handling
 class TimeoutException implements Exception {
   final String message;
diff --git a/lib/services/download_service.dart b/lib/services/download_service.dart
index 0aeac94..86cfafb 100644
--- a/lib/services/download_service.dart
+++ b/lib/services/download_service.dart
@@ -104,25 +104,52 @@ class DownloadService {
   String _getKey(int audiobookId, int chapterId) => '${audiobookId}_$chapterId';
 
   /// Load downloaded chapters from persistent storage
+  /// PERFORMANCE: Loads metadata first, verifies files in background
   Future<void> _loadDownloadedChapters() async {
     try {
       final prefs = await SharedPreferences.getInstance();
       final jsonString = prefs.getString(_storageKey);
       if (jsonString != null) {
         final List<dynamic> jsonList = json.decode(jsonString) as List<dynamic>;
+
+        // PERFORMANCE: Load all metadata immediately (no file I/O)
+        final chaptersToVerify = <String, DownloadedChapter>{};
         for (final item in jsonList) {
           final chapter = DownloadedChapter.fromJson(item as Map<String, dynamic>);
-          // Verify file still exists
-          if (await File(chapter.localPath).exists()) {
-            _downloadedChapters[_getKey(chapter.audiobookId, chapter.chapterId)] = chapter;
-          }
+          chaptersToVerify[_getKey(chapter.audiobookId, chapter.chapterId)] = chapter;
         }
+
+        // Add all chapters first (assume they exist)
+        _downloadedChapters.addAll(chaptersToVerify);
+
+        // PERFORMANCE: Verify files exist in background (non-blocking)
+        // If a file is missing, it will be removed when user tries to play
+        _verifyFilesInBackground(chaptersToVerify);
       }
     } catch (e) {
       AppLogger.e('Error loading downloaded chapters', error: e);
     }
   }
 
+  /// Verify downloaded files exist in background
+  void _verifyFilesInBackground(Map<String, DownloadedChapter> chapters) {
+    Future.microtask(() async {
+      final keysToRemove = <String>[];
+      for (final entry in chapters.entries) {
+        if (!await File(entry.value.localPath).exists()) {
+          keysToRemove.add(entry.key);
+        }
+      }
+      if (keysToRemove.isNotEmpty) {
+        for (final key in keysToRemove) {
+          _downloadedChapters.remove(key);
+        }
+        await _saveDownloadedChapters();
+        AppLogger.d('Removed ${keysToRemove.length} missing downloads');
+      }
+    });
+  }
+
   /// Save downloaded chapters to persistent storage
   Future<void> _saveDownloadedChapters() async {
     try {
diff --git a/lib/services/payment_service.dart b/lib/services/payment_service.dart
index dabb860..a93e519 100644
--- a/lib/services/payment_service.dart
+++ b/lib/services/payment_service.dart
@@ -2,9 +2,11 @@ import 'dart:async';
 import 'package:flutter/material.dart';
 import 'package:flutter/foundation.dart' show kIsWeb;
 import 'package:flutter_stripe/flutter_stripe.dart';
+import 'package:flutter_riverpod/flutter_riverpod.dart';
 import 'package:supabase_flutter/supabase_flutter.dart';
 import 'package:myna/config/env.dart';
 import 'package:myna/utils/app_logger.dart';
+import 'package:myna/providers/audio_provider.dart';
 
 /// Payment result types
 enum PaymentResult {
@@ -68,6 +70,7 @@ class PaymentService {
   ///
   /// [audiobookId] - The audiobook to purchase
   /// [audiobookTitle] - Title for display in payment sheet
+  /// [ref] - Optional WidgetRef to suspend audio position updates during payment
   ///
   /// Returns:
   /// - [PaymentResult.success] if entitlement is confirmed
@@ -78,6 +81,7 @@ class PaymentService {
     required BuildContext context,
     required int audiobookId,
     required String audiobookTitle,
+    WidgetRef? ref,
   }) async {
     if (!Env.isStripeConfigured) {
       AppLogger.w('Payment attempted but Stripe not configured');
@@ -120,8 +124,17 @@ class PaymentService {
         ),
       );
 
-      // Step 3: Present payment sheet
-      await Stripe.instance.presentPaymentSheet();
+      // Step 3: Suspend position updates to reduce CPU while payment sheet is open
+      // This improves typing responsiveness in the native Stripe UI
+      ref?.read(audioProvider.notifier).suspendPositionUpdates();
+
+      // Step 4: Present payment sheet
+      try {
+        await Stripe.instance.presentPaymentSheet();
+      } finally {
+        // Always resume position updates, even if payment fails/cancels
+        ref?.read(audioProvider.notifier).resumePositionUpdates();
+      }
 
       // Step 4: Payment sheet completed - poll for entitlement
       // The webhook should create the entitlement, we just wait for it
@@ -186,6 +199,7 @@ class PaymentService {
 
     for (int attempt = 0; attempt < _maxPollingAttempts; attempt++) {
       try {
+        // PERFORMANCE: Only select 'id' - we just need to check existence
         final response = await Supabase.instance.client
             .from('entitlements')
             .select('id')
diff --git a/lib/services/purchase_service.dart b/lib/services/purchase_service.dart
index 1438970..0797f0e 100644
--- a/lib/services/purchase_service.dart
+++ b/lib/services/purchase_service.dart
@@ -88,8 +88,12 @@ class PurchaseService {
     required String userId,
     required int audiobookId,
   }) async {
+    AppLogger.i('=== FREE ENTITLEMENT FLOW START ===');
+    AppLogger.i('User: $userId, Audiobook: $audiobookId');
+
     try {
       // Check if already owned
+      AppLogger.d('Checking for existing entitlement...');
       final existing = await _supabase
           .from('entitlements')
           .select('id')
@@ -98,21 +102,71 @@ class PurchaseService {
           .maybeSingle();
 
       if (existing != null) {
-        AppLogger.d('User already has entitlement');
+        AppLogger.i('User already has entitlement for audiobook $audiobookId - SUCCESS');
         return PurchaseResult.success;
       }
+      AppLogger.d('No existing entitlement found, proceeding with claim...');
+
+      // Verify the audiobook is actually free and approved before attempting insert
+      AppLogger.d('Verifying audiobook is free and approved...');
+      final audiobook = await _supabase
+          .from('audiobooks')
+          .select('is_free, status')
+          .eq('id', audiobookId)
+          .maybeSingle();
+
+      if (audiobook == null) {
+        AppLogger.e('Audiobook $audiobookId not found in database');
+        return PurchaseResult.error;
+      }
+
+      AppLogger.d('Audiobook data: is_free=${audiobook['is_free']}, status=${audiobook['status']}');
+
+      if (audiobook['is_free'] != true) {
+        AppLogger.w('Audiobook $audiobookId is not free (is_free=${audiobook['is_free']})');
+        return PurchaseResult.paymentRequired;
+      }
+
+      if (audiobook['status'] != 'approved') {
+        AppLogger.w('Audiobook $audiobookId is not approved (status=${audiobook['status']})');
+        return PurchaseResult.error;
+      }
 
       // Create entitlement for free content
+      AppLogger.i('Inserting entitlement: user_id=$userId, audiobook_id=$audiobookId, source=free');
       await _supabase.from('entitlements').insert({
         'user_id': userId,
         'audiobook_id': audiobookId,
         'source': 'free',
       });
 
-      AppLogger.i('Free entitlement granted');
+      AppLogger.i('=== FREE ENTITLEMENT GRANTED SUCCESSFULLY ===');
       return PurchaseResult.success;
-    } catch (e) {
-      AppLogger.e('Error granting free entitlement', error: e);
+    } on PostgrestException catch (e) {
+      // Handle specific Postgres errors
+      AppLogger.e('=== POSTGRES EXCEPTION ===');
+      AppLogger.e('Code: ${e.code}');
+      AppLogger.e('Message: ${e.message}');
+      AppLogger.e('Details: ${e.details}');
+      AppLogger.e('Hint: ${e.hint}');
+
+      if (e.code == '23505') {
+        // Unique constraint violation - entitlement already exists
+        AppLogger.i('Entitlement already exists (concurrent insert) - treating as SUCCESS');
+        return PurchaseResult.success;
+      }
+
+      // RLS policy violation typically shows as 42501 or returns empty/error
+      if (e.code == '42501') {
+        AppLogger.e('RLS POLICY VIOLATION - Check entitlements INSERT policy');
+      }
+
+      return PurchaseResult.error;
+    } catch (e, stackTrace) {
+      AppLogger.e('=== UNEXPECTED ERROR ===');
+      AppLogger.e('Error type: ${e.runtimeType}');
+      AppLogger.e('Error: $e');
+      AppLogger.e('Stack trace: $stackTrace');
       return PurchaseResult.error;
     }
   }
diff --git a/lib/theme/app_theme.dart b/lib/theme/app_theme.dart
index fbb01d6..821e441 100644
--- a/lib/theme/app_theme.dart
+++ b/lib/theme/app_theme.dart
@@ -1,123 +1,1004 @@
 import 'package:flutter/material.dart';
 
-/// Myna Color System
-/// Inspired by the myna bird: dark head, warm brown body, white wing patches,
-/// yellow beak/eye ring. Premium, calm, intelligent - never cheap or noisy.
+/// ═══════════════════════════════════════════════════════════════════════════
+/// PARASTO (پرستو) DESIGN SYSTEM
+/// ═══════════════════════════════════════════════════════════════════════════
+///
+/// Inspired by the Parasto app icon:
+/// - Background: warm cream/beige with soft vignette
+/// - Two barn swallows (پرستو) facing each other:
+///   • Deep navy-blue wings and back
+///   • Warm orange chest/throat
+///   • Clean white belly
+/// - Golden sound-wave in the middle
+///
+/// Design Philosophy:
+/// - Warm, poetic, Persian, premium
+/// - Never gloomy, not techy-neon, not "AI-ish"
+/// - Comfortable for extended reading/listening sessions
+/// ═══════════════════════════════════════════════════════════════════════════
+
 class AppColors {
-  // === Core Palette ===
+  // ══════════════════════════════════════════════════════════════════════════
+  // CORE BRAND COLORS (derived from app icon)
+  // ══════════════════════════════════════════════════════════════════════════
+
+  /// Primary accent - warm amber-gold from the sound wave
+  /// Use for: CTAs, active indicators, progress bars, prices, highlights
+  static const Color primary = Color(0xFFF2B544);        // Sound Wave Gold
+  static const Color primaryDark = Color(0xFFE5A020);    // Gold pressed/active
+  static const Color primaryLight = Color(0xFFF6CB7A);   // Gold soft/hover
+  static const Color primaryMuted = Color(0x33F2B544);   // Gold 20% for backgrounds
+
+  /// Secondary accent - warm orange from swallow's chest
+  /// Use for: secondary CTAs, tags, chapter badges, narrator highlights
+  static const Color secondary = Color(0xFFE67634);      // Swallow Chest Orange
+  static const Color secondaryLight = Color(0xFFEF8F4D); // Orange soft
+  static const Color secondaryMuted = Color(0x33E67634); // Orange 20% for backgrounds
+
+  /// Tertiary - deep navy from swallow's wings
+  /// Use for: badges, special indicators, premium features
+  static const Color navy = Color(0xFF1E3A5F);           // Swallow Wing Navy
+  static const Color navyLight = Color(0xFF2A4A73);      // Navy lighter
+
+  // ══════════════════════════════════════════════════════════════════════════
+  // BACKGROUNDS & SURFACES (Dark Mode - Primary)
+  // ══════════════════════════════════════════════════════════════════════════
+
+  /// Primary background - rich warm navy (NOT black, NOT cold)
+  /// Inspired by night sky but warmer
+  static const Color background = Color(0xFF0F1825);     // Parasto Night
+
+  /// Card/surface color - slightly lighter navy with warmth
+  static const Color surface = Color(0xFF181F2C);        // Parasto Surface
+
+  /// Elevated surfaces - dialogs, bottom sheets, player card
+  static const Color surfaceLight = Color(0xFF202737);   // Parasto Elevated
+
+  /// Extra elevated - for nested cards, overlays, popovers
+  static const Color surfaceElevated = Color(0xFF2A3344); // Parasto Overlay
+
+  /// Highest elevation - modals, important dialogs
+  static const Color surfaceTop = Color(0xFF323B4F);     // Parasto Top
+
+  // ══════════════════════════════════════════════════════════════════════════
+  // BACKGROUNDS & SURFACES (Light Mode - Future)
+  // ══════════════════════════════════════════════════════════════════════════
+
+  /// Light mode - warm cream like icon background
+  static const Color backgroundLight = Color(0xFFFAF7F2); // Parasto Cream
+  static const Color surfaceLightMode = Color(0xFFFFFFFF); // Pure White
+  static const Color surfaceLightElevated = Color(0xFFF5F2ED); // Cream Elevated
+
+  // ══════════════════════════════════════════════════════════════════════════
+  // TYPOGRAPHY COLORS
+  // ══════════════════════════════════════════════════════════════════════════
+
+  /// Primary text - warm off-white (not pure white, easier on eyes)
+  static const Color textPrimary = Color(0xFFF9F5F0);    // Warm White
+
+  /// Secondary text - muted blue-grey for descriptions, subtitles
+  static const Color textSecondary = Color(0xFFB8BCC8);  // Muted Grey (improved)
+
+  /// Tertiary text - labels, timestamps, meta info
+  static const Color textTertiary = Color(0xFF8B92A5);   // Stone Grey
+
+  /// Disabled text - clearly inactive but still readable
+  static const Color textDisabled = Color(0xFF5A6275);   // Disabled Grey
+
+  /// Text on primary color (gold button text)
+  static const Color textOnPrimary = Color(0xFF1A1A1A);  // Near black for contrast
+
+  /// Text on secondary color (orange button text)
+  static const Color textOnSecondary = Color(0xFFFFFFFF); // White
+
+  // ══════════════════════════════════════════════════════════════════════════
+  // SEMANTIC COLORS
+  // ══════════════════════════════════════════════════════════════════════════
+
+  /// Success - fresh green (purchases, completed, saved)
+  static const Color success = Color(0xFF4ADE80);        // Success Green
+  static const Color successMuted = Color(0x334ADE80);   // Success background
 
-  /// Primary accent - warm amber-gold inspired by the beak
-  /// Use sparingly: CTAs, active indicators, progress bars, prices
-  static const Color primary = Color(0xFFE5A93D);       // Beak Gold
-  static const Color primaryDark = Color(0xFFD4942F);   // Beak Gold pressed
-  static const Color primaryLight = Color(0xFFF5C861); // Beak Glow (hover)
+  /// Warning - amber (close to primary family for harmony)
+  static const Color warning = Color(0xFFFBBF24);        // Warning Amber
+  static const Color warningMuted = Color(0x33FBBF24);   // Warning background
 
-  /// Secondary - muted warm tone for less prominent actions
-  static const Color secondary = Color(0xFF78716C);     // Stone Grey
+  /// Error - warm coral (not harsh red)
+  static const Color error = Color(0xFFF97070);          // Error Coral
+  static const Color errorMuted = Color(0x33F97070);     // Error background
 
-  // === Backgrounds & Surfaces ===
+  /// Info - cool blue for informational messages
+  static const Color info = Color(0xFF60A5FA);           // Info Blue
+  static const Color infoMuted = Color(0x3360A5FA);      // Info background
 
-  /// Primary background - deep night, like the bird's dark head
-  static const Color background = Color(0xFF0F1114);    // Myna Night
+  // ══════════════════════════════════════════════════════════════════════════
+  // BORDERS & DIVIDERS
+  // ══════════════════════════════════════════════════════════════════════════
 
-  /// Card/surface color - warm brown undertone from plumage
-  static const Color surface = Color(0xFF1C1917);       // Feather Brown
+  /// Standard borders and dividers
+  static const Color border = Color(0xFF2A3344);         // Border Navy
 
-  /// Elevated surfaces, hover states
-  static const Color surfaceLight = Color(0xFF292524);  // Feather Light
+  /// Subtle border (8% opacity of textPrimary)
+  static const Color borderSubtle = Color(0x14F9F5F0);   // Border Subtle
 
-  // === Typography ===
+  /// Focused border (for inputs)
+  static const Color borderFocused = primary;            // Gold when focused
 
-  /// Primary text - warm white, not harsh blue-white
-  static const Color textPrimary = Color(0xFFFAFAF9);   // Wing White
+  // ══════════════════════════════════════════════════════════════════════════
+  // ICON COLORS
+  // ══════════════════════════════════════════════════════════════════════════
 
-  /// Secondary text - supporting information
-  static const Color textSecondary = Color(0xFFA8A29E); // Plume Grey
+  /// Muted icons (inactive state)
+  static const Color iconMuted = Color(0xFF8B92A5);      // Same as textTertiary
 
-  /// Tertiary text - labels, timestamps, disabled
-  /// Brightened for better visibility on dark backgrounds
-  static const Color textTertiary = Color(0xFF78716C);  // Stone Grey (was Shadow Grey)
+  /// Active icons
+  static const Color iconActive = primary;               // Gold when active
 
-  // === Semantic Colors (Harmonized) ===
+  // ══════════════════════════════════════════════════════════════════════════
+  // SPECIAL PURPOSE COLORS
+  // ══════════════════════════════════════════════════════════════════════════
 
-  /// Success - softer sage green
-  static const Color success = Color(0xFF4ADE80);       // Success Sage
+  /// Player gradient colors
+  static const Color playerGradientStart = Color(0xFF1A2332);
+  static const Color playerGradientEnd = Color(0xFF0F1825);
 
-  /// Warning - amber, close to Beak Gold family
-  static const Color warning = Color(0xFFFBBF24);       // Warning Amber
+  /// Premium/Pro badge
+  static const Color premium = Color(0xFFFFD700);        // Gold
 
-  /// Error - warm coral, not harsh red
-  static const Color error = Color(0xFFF87171);         // Error Coral
+  /// Free badge
+  static const Color free = success;
 
-  // === Borders & Dividers ===
+  /// Locked content overlay
+  static const Color locked = Color(0x99000000);         // 60% black
 
-  /// Borders, subtle separators
-  static const Color border = Color(0xFF3D3835);        // Border Stone
+  /// Shimmer effect colors
+  static const Color shimmerBase = Color(0xFF1E2530);
+  static const Color shimmerHighlight = Color(0xFF2A3344);
+
+  // ══════════════════════════════════════════════════════════════════════════
+  // RATING COLORS (kept semantic for star ratings)
+  // ══════════════════════════════════════════════════════════════════════════
+
+  static const Color rating1 = Color(0xFFEF4444);        // 1 star - Red
+  static const Color rating2 = Color(0xFFF97316);        // 2 stars - Orange
+  static const Color rating3 = Color(0xFFFBBF24);        // 3 stars - Amber
+  static const Color rating4 = Color(0xFF84CC16);        // 4 stars - Lime
+  static const Color rating5 = Color(0xFF22C55E);        // 5 stars - Green
+  static const Color ratingEmpty = Color(0xFF4B5563);    // Empty star
 }
 
+// ════════════════════════════════════════════════════════════════════════════
+// TYPOGRAPHY SCALE
+// ════════════════════════════════════════════════════════════════════════════
+
+class AppTypography {
+  static const String fontFamily = 'Vazirmatn';
+
+  // ═══════════════════════════════════════════════════════════════════════════
+  // DISPLAY - Hero titles, splash screens
+  // ═══════════════════════════════════════════════════════════════════════════
+
+  static const TextStyle displayLarge = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 32,
+    fontWeight: FontWeight.bold,
+    height: 1.2,
+    color: AppColors.textPrimary,
+  );
+
+  static const TextStyle displayMedium = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 28,
+    fontWeight: FontWeight.bold,
+    height: 1.25,
+    color: AppColors.textPrimary,
+  );
+
+  // ═══════════════════════════════════════════════════════════════════════════
+  // HEADLINE - Page titles, section headers
+  // ═══════════════════════════════════════════════════════════════════════════
+
+  static const TextStyle headlineLarge = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 24,
+    fontWeight: FontWeight.w700,
+    height: 1.3,
+    color: AppColors.textPrimary,
+  );
+
+  static const TextStyle headlineMedium = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 20,
+    fontWeight: FontWeight.w600,
+    height: 1.35,
+    color: AppColors.textPrimary,
+  );
+
+  static const TextStyle headlineSmall = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 18,
+    fontWeight: FontWeight.w600,
+    height: 1.4,
+    color: AppColors.textPrimary,
+  );
+
+  // ═══════════════════════════════════════════════════════════════════════════
+  // TITLE - Card titles, list item titles
+  // ═══════════════════════════════════════════════════════════════════════════
+
+  static const TextStyle titleLarge = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 16,
+    fontWeight: FontWeight.w600,
+    height: 1.4,
+    color: AppColors.textPrimary,
+  );
+
+  static const TextStyle titleMedium = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 14,
+    fontWeight: FontWeight.w600,
+    height: 1.4,
+    color: AppColors.textPrimary,
+  );
+
+  static const TextStyle titleSmall = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 13,
+    fontWeight: FontWeight.w500,
+    height: 1.4,
+    color: AppColors.textPrimary,
+  );
+
+  // ═══════════════════════════════════════════════════════════════════════════
+  // BODY - Regular content text
+  // ═══════════════════════════════════════════════════════════════════════════
+
+  static const TextStyle bodyLarge = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 15,
+    fontWeight: FontWeight.normal,
+    height: 1.5,
+    color: AppColors.textPrimary,
+  );
+
+  static const TextStyle bodyMedium = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 14,
+    fontWeight: FontWeight.normal,
+    height: 1.5,
+    color: AppColors.textSecondary,
+  );
+
+  static const TextStyle bodySmall = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 13,
+    fontWeight: FontWeight.normal,
+    height: 1.5,
+    color: AppColors.textSecondary,
+  );
+
+  // ═══════════════════════════════════════════════════════════════════════════
+  // LABEL - Buttons, chips, small UI elements
+  // ═══════════════════════════════════════════════════════════════════════════
+
+  static const TextStyle labelLarge = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 14,
+    fontWeight: FontWeight.w600,
+    height: 1.4,
+    letterSpacing: 0.1,
+    color: AppColors.textPrimary,
+  );
+
+  static const TextStyle labelMedium = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 12,
+    fontWeight: FontWeight.w500,
+    height: 1.4,
+    letterSpacing: 0.1,
+    color: AppColors.textSecondary,
+  );
+
+  static const TextStyle labelSmall = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 11,
+    fontWeight: FontWeight.w500,
+    height: 1.4,
+    letterSpacing: 0.1,
+    color: AppColors.textTertiary,
+  );
+
+  // ═══════════════════════════════════════════════════════════════════════════
+  // SPECIAL PURPOSE
+  // ═══════════════════════════════════════════════════════════════════════════
+
+  /// Price text (gold color)
+  static const TextStyle price = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 16,
+    fontWeight: FontWeight.w700,
+    height: 1.2,
+    color: AppColors.primary,
+  );
+
+  /// Free badge text
+  static const TextStyle freeBadge = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 10,
+    fontWeight: FontWeight.w600,
+    height: 1.2,
+    color: AppColors.success,
+  );
+
+  /// Duration/time text
+  static const TextStyle duration = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 12,
+    fontWeight: FontWeight.w500,
+    height: 1.2,
+    color: AppColors.textTertiary,
+  );
+
+  /// Button text
+  static const TextStyle button = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 15,
+    fontWeight: FontWeight.w600,
+    height: 1.2,
+  );
+
+  // ═══════════════════════════════════════════════════════════════════════════
+  // SEMANTIC STYLES (for specific UI contexts)
+  // ═══════════════════════════════════════════════════════════════════════════
+
+  /// Section header title (home screen sections like "پیشنهاد شده")
+  static const TextStyle sectionTitle = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 20,
+    fontWeight: FontWeight.bold,
+    height: 1.3,
+    color: AppColors.textPrimary,
+    letterSpacing: -0.3,
+  );
+
+  /// Card title (audiobook cards, list items)
+  static const TextStyle cardTitle = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 14,
+    fontWeight: FontWeight.w600,
+    height: 1.3,
+    color: AppColors.textPrimary,
+  );
+
+  /// Card subtitle (author, narrator names)
+  static const TextStyle cardSubtitle = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 12,
+    fontWeight: FontWeight.normal,
+    height: 1.4,
+    color: AppColors.textSecondary,
+  );
+
+  /// Chip/tag text
+  static const TextStyle chip = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 13,
+    fontWeight: FontWeight.w500,
+    height: 1.3,
+    color: AppColors.textPrimary,
+  );
+
+  /// Meta info (timestamps, chapter counts, durations)
+  static const TextStyle meta = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 12,
+    fontWeight: FontWeight.w500,
+    height: 1.3,
+    color: AppColors.textTertiary,
+  );
+
+  /// Small badge text (free, price badges)
+  static const TextStyle badge = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 11,
+    fontWeight: FontWeight.w600,
+    height: 1.2,
+  );
+
+  /// App bar title
+  static const TextStyle appBarTitle = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 18,
+    fontWeight: FontWeight.w600,
+    height: 1.3,
+    color: AppColors.textPrimary,
+  );
+
+  /// Hero title (large prominent titles)
+  static const TextStyle heroTitle = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 26,
+    fontWeight: FontWeight.bold,
+    height: 1.2,
+    color: AppColors.textPrimary,
+  );
+
+  /// Banner title overlay
+  static const TextStyle bannerTitle = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 18,
+    fontWeight: FontWeight.bold,
+    height: 1.3,
+    color: Colors.white,
+    shadows: [
+      Shadow(
+        color: Colors.black54,
+        blurRadius: 8,
+      ),
+    ],
+  );
+
+  /// Banner subtitle overlay
+  static const TextStyle bannerSubtitle = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 14,
+    fontWeight: FontWeight.normal,
+    height: 1.4,
+    color: Colors.white,
+  );
+
+  /// Form field label
+  static const TextStyle fieldLabel = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 14,
+    fontWeight: FontWeight.w500,
+    height: 1.4,
+    color: AppColors.textSecondary,
+  );
+
+  /// Form helper/hint text
+  static const TextStyle fieldHint = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 13,
+    fontWeight: FontWeight.normal,
+    height: 1.4,
+    color: AppColors.textTertiary,
+  );
+
+  /// Error message text
+  static const TextStyle errorText = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 13,
+    fontWeight: FontWeight.w500,
+    height: 1.4,
+    color: AppColors.error,
+  );
+
+  /// Success message text
+  static const TextStyle successText = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 13,
+    fontWeight: FontWeight.w500,
+    height: 1.4,
+    color: AppColors.success,
+  );
+
+  /// Empty state message
+  static const TextStyle emptyState = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 15,
+    fontWeight: FontWeight.w500,
+    height: 1.5,
+    color: AppColors.textSecondary,
+  );
+
+  /// Progress percentage text
+  static const TextStyle progressText = TextStyle(
+    fontFamily: fontFamily,
+    fontSize: 12,
+    fontWeight: FontWeight.w600,
+    height: 1.2,
+    color: AppColors.primary,
+  );
+}
+
+// ════════════════════════════════════════════════════════════════════════════
+// SPACING & SIZING CONSTANTS
+// ════════════════════════════════════════════════════════════════════════════
+
+class AppSpacing {
+  // Base unit: 4px
+  static const double xs = 4;
+  static const double sm = 8;
+  static const double md = 12;
+  static const double lg = 16;
+  static const double xl = 24;
+  static const double xxl = 32;
+  static const double xxxl = 48;
+
+  // Section spacing
+  static const double sectionPaddingHorizontal = 16;
+  static const double sectionPaddingVertical = 24;
+  static const double sectionGap = 32;
+
+  // Card spacing
+  static const double cardPadding = 16;
+  static const double cardGap = 12;
+
+  // List spacing
+  static const double listItemGap = 8;
+  static const double listPadding = 16;
+}
+
+// ════════════════════════════════════════════════════════════════════════════
+// BORDER RADIUS
+// ════════════════════════════════════════════════════════════════════════════
+
+class AppRadius {
+  static const double xs = 4;
+  static const double sm = 8;
+  static const double md = 12;
+  static const double lg = 16;
+  static const double xl = 20;
+  static const double xxl = 24;
+  static const double full = 999;
+
+  // Preset BorderRadius objects
+  static final BorderRadius small = BorderRadius.circular(sm);
+  static final BorderRadius medium = BorderRadius.circular(md);
+  static final BorderRadius large = BorderRadius.circular(lg);
+  static final BorderRadius extraLarge = BorderRadius.circular(xl);
+  static final BorderRadius pill = BorderRadius.circular(full);
+}
+
+// ════════════════════════════════════════════════════════════════════════════
+// SHADOWS
+// ════════════════════════════════════════════════════════════════════════════
+
+class AppShadows {
+  static List<BoxShadow> get small => [
+    BoxShadow(
+      color: Colors.black.withOpacity(0.15),
+      blurRadius: 4,
+      offset: const Offset(0, 2),
+    ),
+  ];
+
+  static List<BoxShadow> get medium => [
+    BoxShadow(
+      color: Colors.black.withOpacity(0.2),
+      blurRadius: 8,
+      offset: const Offset(0, 4),
+    ),
+  ];
+
+  static List<BoxShadow> get large => [
+    BoxShadow(
+      color: Colors.black.withOpacity(0.25),
+      blurRadius: 16,
+      offset: const Offset(0, 8),
+    ),
+  ];
+
+  static List<BoxShadow> get glow => [
+    BoxShadow(
+      color: AppColors.primary.withOpacity(0.3),
+      blurRadius: 16,
+      offset: const Offset(0, 4),
+    ),
+  ];
+}
+
+// ════════════════════════════════════════════════════════════════════════════
+// THEME DATA
+// ════════════════════════════════════════════════════════════════════════════
+
 class AppTheme {
   static ThemeData get darkTheme {
     return ThemeData(
+      useMaterial3: true,
       brightness: Brightness.dark,
       primaryColor: AppColors.primary,
       scaffoldBackgroundColor: AppColors.background,
-      fontFamily: 'Vazirmatn',
-      
+      fontFamily: AppTypography.fontFamily,
+      canvasColor: AppColors.surface,
+
+      // ════════════════════════════════════════════════════════════════════════
+      // APP BAR
+      // ════════════════════════════════════════════════════════════════════════
       appBarTheme: const AppBarTheme(
         backgroundColor: AppColors.background,
+        surfaceTintColor: Colors.transparent,
         elevation: 0,
         centerTitle: true,
-        titleTextStyle: TextStyle(
+        titleTextStyle: AppTypography.headlineSmall,
+        iconTheme: IconThemeData(
           color: AppColors.textPrimary,
-          fontSize: 18,
-          fontWeight: FontWeight.w600,
+          size: 24,
         ),
-        iconTheme: IconThemeData(color: AppColors.textPrimary),
       ),
-      
+
+      // ════════════════════════════════════════════════════════════════════════
+      // CARD
+      // ════════════════════════════════════════════════════════════════════════
       cardTheme: CardTheme(
         color: AppColors.surface,
+        surfaceTintColor: Colors.transparent,
         elevation: 0,
         shape: RoundedRectangleBorder(
-          borderRadius: BorderRadius.circular(12),
+          borderRadius: AppRadius.medium,
         ),
+        margin: EdgeInsets.zero,
       ),
-      
+
+      // ════════════════════════════════════════════════════════════════════════
+      // ELEVATED BUTTON (Primary CTA)
+      // ════════════════════════════════════════════════════════════════════════
       elevatedButtonTheme: ElevatedButtonThemeData(
         style: ElevatedButton.styleFrom(
           backgroundColor: AppColors.primary,
-          foregroundColor: AppColors.background, // Dark text on gold for contrast
+          foregroundColor: AppColors.textOnPrimary,
+          disabledBackgroundColor: AppColors.surfaceLight,
+          disabledForegroundColor: AppColors.textDisabled,
           elevation: 0,
-          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
+          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 14),
+          minimumSize: const Size(44, 48),
+          shape: RoundedRectangleBorder(
+            borderRadius: AppRadius.medium,
+          ),
+          textStyle: AppTypography.button,
+        ),
+      ),
+
+      // ════════════════════════════════════════════════════════════════════════
+      // OUTLINED BUTTON (Secondary CTA)
+      // ════════════════════════════════════════════════════════════════════════
+      outlinedButtonTheme: OutlinedButtonThemeData(
+        style: OutlinedButton.styleFrom(
+          foregroundColor: AppColors.primary,
+          side: const BorderSide(color: AppColors.primary, width: 1.5),
+          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 14),
+          minimumSize: const Size(44, 48),
           shape: RoundedRectangleBorder(
-            borderRadius: BorderRadius.circular(12), // Slightly more rounded
+            borderRadius: AppRadius.medium,
           ),
+          textStyle: AppTypography.button,
         ),
       ),
-      
+
+      // ════════════════════════════════════════════════════════════════════════
+      // TEXT BUTTON (Tertiary action)
+      // ════════════════════════════════════════════════════════════════════════
+      textButtonTheme: TextButtonThemeData(
+        style: TextButton.styleFrom(
+          foregroundColor: AppColors.primary,
+          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
+          minimumSize: const Size(44, 44),
+          textStyle: AppTypography.button,
+        ),
+      ),
+
+      // ════════════════════════════════════════════════════════════════════════
+      // INPUT DECORATION (Text fields)
+      // ════════════════════════════════════════════════════════════════════════
       inputDecorationTheme: InputDecorationTheme(
         filled: true,
         fillColor: AppColors.surface,
+        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
         border: OutlineInputBorder(
-          borderRadius: BorderRadius.circular(8),
+          borderRadius: AppRadius.small,
           borderSide: BorderSide.none,
         ),
         enabledBorder: OutlineInputBorder(
-          borderRadius: BorderRadius.circular(8),
-          borderSide: const BorderSide(color: AppColors.border),
+          borderRadius: AppRadius.small,
+          borderSide: const BorderSide(color: AppColors.border, width: 1),
         ),
         focusedBorder: OutlineInputBorder(
-          borderRadius: BorderRadius.circular(8),
-          borderSide: const BorderSide(color: AppColors.primary),
+          borderRadius: AppRadius.small,
+          borderSide: const BorderSide(color: AppColors.primary, width: 2),
+        ),
+        errorBorder: OutlineInputBorder(
+          borderRadius: AppRadius.small,
+          borderSide: const BorderSide(color: AppColors.error, width: 1),
+        ),
+        focusedErrorBorder: OutlineInputBorder(
+          borderRadius: AppRadius.small,
+          borderSide: const BorderSide(color: AppColors.error, width: 2),
+        ),
+        hintStyle: AppTypography.bodyMedium.copyWith(color: AppColors.textTertiary),
+        labelStyle: AppTypography.bodyMedium,
+        errorStyle: AppTypography.labelSmall.copyWith(color: AppColors.error),
+      ),
+
+      // ════════════════════════════════════════════════════════════════════════
+      // BOTTOM NAVIGATION
+      // ════════════════════════════════════════════════════════════════════════
+      bottomNavigationBarTheme: const BottomNavigationBarThemeData(
+        backgroundColor: AppColors.surface,
+        selectedItemColor: AppColors.primary,
+        unselectedItemColor: AppColors.textTertiary,
+        selectedLabelStyle: TextStyle(
+          fontFamily: AppTypography.fontFamily,
+          fontSize: 11,
+          fontWeight: FontWeight.w600,
+        ),
+        unselectedLabelStyle: TextStyle(
+          fontFamily: AppTypography.fontFamily,
+          fontSize: 11,
+          fontWeight: FontWeight.w500,
+        ),
+        type: BottomNavigationBarType.fixed,
+        elevation: 0,
+      ),
+
+      // ════════════════════════════════════════════════════════════════════════
+      // TAB BAR
+      // ════════════════════════════════════════════════════════════════════════
+      tabBarTheme: const TabBarTheme(
+        labelColor: AppColors.primary,
+        unselectedLabelColor: AppColors.textTertiary,
+        indicatorColor: AppColors.primary,
+        labelStyle: AppTypography.labelLarge,
+        unselectedLabelStyle: AppTypography.labelMedium,
+        indicatorSize: TabBarIndicatorSize.label,
+      ),
+
+      // ════════════════════════════════════════════════════════════════════════
+      // SNACKBAR
+      // ════════════════════════════════════════════════════════════════════════
+      snackBarTheme: SnackBarThemeData(
+        backgroundColor: AppColors.surfaceElevated,
+        contentTextStyle: AppTypography.bodyMedium.copyWith(
+          color: AppColors.textPrimary,
+        ),
+        actionTextColor: AppColors.primary,
+        behavior: SnackBarBehavior.floating,
+        shape: RoundedRectangleBorder(
+          borderRadius: AppRadius.small,
+        ),
+      ),
+
+      // ════════════════════════════════════════════════════════════════════════
+      // DIALOG
+      // ════════════════════════════════════════════════════════════════════════
+      dialogTheme: DialogTheme(
+        backgroundColor: AppColors.surfaceLight,
+        surfaceTintColor: Colors.transparent,
+        elevation: 8,
+        shape: RoundedRectangleBorder(
+          borderRadius: AppRadius.large,
+        ),
+        titleTextStyle: AppTypography.headlineSmall,
+        contentTextStyle: AppTypography.bodyMedium,
+      ),
+
+      // ════════════════════════════════════════════════════════════════════════
+      // BOTTOM SHEET
+      // ════════════════════════════════════════════════════════════════════════
+      bottomSheetTheme: const BottomSheetThemeData(
+        backgroundColor: AppColors.surfaceLight,
+        surfaceTintColor: Colors.transparent,
+        elevation: 8,
+        shape: RoundedRectangleBorder(
+          borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
+        ),
+        dragHandleColor: AppColors.border,
+        dragHandleSize: Size(40, 4),
+      ),
+
+      // ════════════════════════════════════════════════════════════════════════
+      // CHIP
+      // ════════════════════════════════════════════════════════════════════════
+      chipTheme: ChipThemeData(
+        backgroundColor: AppColors.surface,
+        selectedColor: AppColors.primaryMuted,
+        disabledColor: AppColors.surfaceLight,
+        labelStyle: AppTypography.labelMedium,
+        secondaryLabelStyle: AppTypography.labelMedium.copyWith(
+          color: AppColors.primary,
+        ),
+        side: const BorderSide(color: AppColors.border),
+        shape: RoundedRectangleBorder(
+          borderRadius: AppRadius.small,
+        ),
+        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
+      ),
+
+      // ════════════════════════════════════════════════════════════════════════
+      // PROGRESS INDICATOR
+      // ════════════════════════════════════════════════════════════════════════
+      progressIndicatorTheme: const ProgressIndicatorThemeData(
+        color: AppColors.primary,
+        linearTrackColor: AppColors.border,
+        circularTrackColor: AppColors.border,
+      ),
+
+      // ════════════════════════════════════════════════════════════════════════
+      // SLIDER
+      // ════════════════════════════════════════════════════════════════════════
+      sliderTheme: SliderThemeData(
+        activeTrackColor: AppColors.primary,
+        inactiveTrackColor: AppColors.border,
+        thumbColor: AppColors.primary,
+        overlayColor: AppColors.primary.withOpacity(0.2),
+        trackHeight: 4,
+        thumbShape: const RoundSliderThumbShape(enabledThumbRadius: 8),
+        overlayShape: const RoundSliderOverlayShape(overlayRadius: 16),
+      ),
+
+      // ════════════════════════════════════════════════════════════════════════
+      // SWITCH
+      // ════════════════════════════════════════════════════════════════════════
+      switchTheme: SwitchThemeData(
+        thumbColor: WidgetStateProperty.resolveWith((states) {
+          if (states.contains(WidgetState.selected)) {
+            return AppColors.primary;
+          }
+          return AppColors.textTertiary;
+        }),
+        trackColor: WidgetStateProperty.resolveWith((states) {
+          if (states.contains(WidgetState.selected)) {
+            return AppColors.primary.withOpacity(0.5);
+          }
+          return AppColors.border;
+        }),
+        trackOutlineColor: WidgetStateProperty.all(Colors.transparent),
+      ),
+
+      // ════════════════════════════════════════════════════════════════════════
+      // CHECKBOX
+      // ════════════════════════════════════════════════════════════════════════
+      checkboxTheme: CheckboxThemeData(
+        fillColor: WidgetStateProperty.resolveWith((states) {
+          if (states.contains(WidgetState.selected)) {
+            return AppColors.primary;
+          }
+          return Colors.transparent;
+        }),
+        checkColor: WidgetStateProperty.all(AppColors.textOnPrimary),
+        side: const BorderSide(color: AppColors.border, width: 2),
+        shape: RoundedRectangleBorder(
+          borderRadius: BorderRadius.circular(4),
+        ),
+      ),
+
+      // ════════════════════════════════════════════════════════════════════════
+      // RADIO
+      // ════════════════════════════════════════════════════════════════════════
+      radioTheme: RadioThemeData(
+        fillColor: WidgetStateProperty.resolveWith((states) {
+          if (states.contains(WidgetState.selected)) {
+            return AppColors.primary;
+          }
+          return AppColors.textTertiary;
+        }),
+      ),
+
+      // ════════════════════════════════════════════════════════════════════════
+      // DIVIDER
+      // ════════════════════════════════════════════════════════════════════════
+      dividerTheme: const DividerThemeData(
+        color: AppColors.border,
+        thickness: 1,
+        space: 1,
+      ),
+
+      // ════════════════════════════════════════════════════════════════════════
+      // LIST TILE
+      // ════════════════════════════════════════════════════════════════════════
+      listTileTheme: ListTileThemeData(
+        iconColor: AppColors.textSecondary,
+        textColor: AppColors.textPrimary,
+        tileColor: Colors.transparent,
+        selectedTileColor: AppColors.primaryMuted,
+        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
+        shape: RoundedRectangleBorder(
+          borderRadius: AppRadius.small,
         ),
-        hintStyle: const TextStyle(color: AppColors.textTertiary),
+        titleTextStyle: AppTypography.titleMedium,
+        subtitleTextStyle: AppTypography.bodySmall,
+        leadingAndTrailingTextStyle: AppTypography.labelMedium,
       ),
-      
+
+      // ════════════════════════════════════════════════════════════════════════
+      // ICON
+      // ════════════════════════════════════════════════════════════════════════
+      iconTheme: const IconThemeData(
+        color: AppColors.textSecondary,
+        size: 24,
+      ),
+
+      // ════════════════════════════════════════════════════════════════════════
+      // FAB
+      // ════════════════════════════════════════════════════════════════════════
+      floatingActionButtonTheme: FloatingActionButtonThemeData(
+        backgroundColor: AppColors.primary,
+        foregroundColor: AppColors.textOnPrimary,
+        elevation: 4,
+        shape: RoundedRectangleBorder(
+          borderRadius: AppRadius.large,
+        ),
+      ),
+
+      // ════════════════════════════════════════════════════════════════════════
+      // POPUP MENU
+      // ════════════════════════════════════════════════════════════════════════
+      popupMenuTheme: PopupMenuThemeData(
+        color: AppColors.surfaceLight,
+        surfaceTintColor: Colors.transparent,
+        elevation: 8,
+        shape: RoundedRectangleBorder(
+          borderRadius: AppRadius.small,
+        ),
+        textStyle: AppTypography.bodyMedium,
+      ),
+
+      // ════════════════════════════════════════════════════════════════════════
+      // TOOLTIP
+      // ════════════════════════════════════════════════════════════════════════
+      tooltipTheme: TooltipThemeData(
+        decoration: BoxDecoration(
+          color: AppColors.surfaceElevated,
+          borderRadius: AppRadius.small,
+        ),
+        textStyle: AppTypography.labelSmall.copyWith(
+          color: AppColors.textPrimary,
+        ),
+        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
+      ),
+
+      // ════════════════════════════════════════════════════════════════════════
+      // COLOR SCHEME
+      // ════════════════════════════════════════════════════════════════════════
       colorScheme: const ColorScheme.dark(
         primary: AppColors.primary,
+        onPrimary: AppColors.textOnPrimary,
+        primaryContainer: AppColors.primaryMuted,
+        onPrimaryContainer: AppColors.primary,
         secondary: AppColors.secondary,
-        surface: AppColors.surface,
+        onSecondary: AppColors.textOnSecondary,
+        secondaryContainer: AppColors.secondaryMuted,
+        onSecondaryContainer: AppColors.secondary,
+        tertiary: AppColors.navy,
+        onTertiary: AppColors.textPrimary,
         error: AppColors.error,
+        onError: AppColors.textPrimary,
+        errorContainer: AppColors.errorMuted,
+        onErrorContainer: AppColors.error,
+        surface: AppColors.surface,
+        onSurface: AppColors.textPrimary,
+        surfaceContainerHighest: AppColors.surfaceElevated,
+        onSurfaceVariant: AppColors.textSecondary,
+        outline: AppColors.border,
+        outlineVariant: AppColors.borderSubtle,
+        shadow: Colors.black,
+        scrim: Colors.black54,
+        inverseSurface: AppColors.textPrimary,
+        onInverseSurface: AppColors.background,
+        inversePrimary: AppColors.primaryDark,
+        brightness: Brightness.dark,
+      ),
+
+      // ════════════════════════════════════════════════════════════════════════
+      // TEXT THEME
+      // ════════════════════════════════════════════════════════════════════════
+      textTheme: const TextTheme(
+        displayLarge: AppTypography.displayLarge,
+        displayMedium: AppTypography.displayMedium,
+        headlineLarge: AppTypography.headlineLarge,
+        headlineMedium: AppTypography.headlineMedium,
+        headlineSmall: AppTypography.headlineSmall,
+        titleLarge: AppTypography.titleLarge,
+        titleMedium: AppTypography.titleMedium,
+        titleSmall: AppTypography.titleSmall,
+        bodyLarge: AppTypography.bodyLarge,
+        bodyMedium: AppTypography.bodyMedium,
+        bodySmall: AppTypography.bodySmall,
+        labelLarge: AppTypography.labelLarge,
+        labelMedium: AppTypography.labelMedium,
+        labelSmall: AppTypography.labelSmall,
       ),
     );
   }
diff --git a/lib/utils/app_logger.dart b/lib/utils/app_logger.dart
index f226310..7f053e4 100644
--- a/lib/utils/app_logger.dart
+++ b/lib/utils/app_logger.dart
@@ -77,4 +77,20 @@ class AppLogger {
       _logger.d('AUDIO: $event ${chapter ?? ''} $posStr');
     }
   }
+
+  /// Log Android notification diagnostic events.
+  /// Uses [AUDIO_NOTIF] tag for easy logcat filtering:
+  ///   adb logcat | grep AUDIO_NOTIF
+  ///
+  /// This is specifically for debugging why Android media notifications
+  /// or lockscreen controls might not appear.
+  static void audioNotif(String message) {
+    // Always print with [AUDIO_NOTIF] tag for logcat filtering, even in release
+    // ignore: avoid_print
+    print('[AUDIO_NOTIF] $message');
+    // Also log via logger in debug mode for pretty output
+    if (kDebugMode) {
+      _logger.i('[AUDIO_NOTIF] $message');
+    }
+  }
 }
diff --git a/lib/utils/audio_validator.dart b/lib/utils/audio_validator.dart
index 3852ad1..2028686 100644
--- a/lib/utils/audio_validator.dart
+++ b/lib/utils/audio_validator.dart
@@ -3,8 +3,11 @@
 // Requirements:
 // - Accepted formats: MP3, M4A (AAC) only
 // - Recommended: Mono, 44.1 kHz, 64-96 kbps
-// - Max chapter length: 60 minutes
-// - Max file size: 50 MB per chapter
+// - Max chapter length: 240 minutes (4 hours)
+// - Max file size: 500 MB per chapter (Supabase Pro plan)
+//
+// NOTE: The file size limit is determined by Supabase Storage configuration.
+// If you change the limit in Supabase dashboard, update kServerMaxFileSizeMB below.
 
 /// Result of audio file validation.
 class AudioValidationResult {
@@ -28,9 +31,28 @@ class AudioValidationResult {
 }
 
 class AudioValidator {
-  // Constants
-  static const int maxFileSizeBytes = 50 * 1024 * 1024; // 50 MB
-  static const int maxDurationSeconds = 60 * 60; // 60 minutes
+  // ==========================================================================
+  // UPLOAD LIMITS - Single source of truth
+  // ==========================================================================
+  // These limits MUST match your Supabase Storage configuration.
+  // Supabase Pro plan allows up to 5GB. We set 500 MB as the app limit.
+  // If you change the limit in Supabase dashboard, update kServerMaxFileSizeMB.
+  // ==========================================================================
+
+  /// Server-side file size limit in MB (matches Supabase Storage config)
+  /// IMPORTANT: Update this if you change Supabase Storage file size limit
+  static const int kServerMaxFileSizeMB = 500;
+
+  /// Maximum file size in bytes (derived from kServerMaxFileSizeMB)
+  static const int maxFileSizeBytes = kServerMaxFileSizeMB * 1024 * 1024;
+
+  /// Warning threshold - show warning for files above this size (400 MB = 80% of limit)
+  static const int warnFileSizeBytes = 400 * 1024 * 1024;
+
+  /// Maximum chapter duration in seconds (240 minutes = 4 hours)
+  static const int maxDurationSeconds = 240 * 60;
+
+  /// Recommended bitrate for optimal file size
   static const int recommendedBitrateKbps = 64; // 64-96 kbps recommended
 
   // Accepted formats
@@ -76,18 +98,18 @@ class AudioValidator {
       }
     }
 
-    // 3. Check file size
+    // 3. Check file size against server limit
     if (fileSizeBytes > maxFileSizeBytes) {
       final sizeMB = (fileSizeBytes / (1024 * 1024)).toStringAsFixed(1);
       return AudioValidationResult.invalid(
-        'حجم فایل بیش از حد مجاز است ($sizeMB مگابایت).\n\n'
-        'حداکثر حجم مجاز: ۵۰ مگابایت\n\n'
-        'راهنمای فشرده‌سازی:\n'
+        'حجم فایل از حد مجاز بیشتر است ($sizeMB مگابایت).\n\n'
+        'حداکثر حجم مجاز: $kServerMaxFileSizeMB مگابایت\n\n'
+        'برای کاهش حجم فایل:\n'
         '• فرمت: MP3 یا M4A\n'
         '• کانال: مونو (Mono)\n'
         '• نرخ نمونه‌برداری: 44.1 kHz\n'
         '• بیت‌ریت: 64-96 kbps\n\n'
-        'با این تنظیمات، هر ساعت صدا حدود ۳۰ مگابایت خواهد شد.',
+        'یا فصل را به چند بخش کوچک‌تر تقسیم کنید.',
       );
     }
 
@@ -96,18 +118,18 @@ class AudioValidator {
       final durationMin = (durationSeconds / 60).toStringAsFixed(0);
       return AudioValidationResult.invalid(
         'مدت زمان فصل بیش از حد مجاز است ($durationMin دقیقه).\n\n'
-        'حداکثر مدت هر فصل: ۶۰ دقیقه\n\n'
+        'حداکثر مدت هر فصل: ۲۴۰ دقیقه (۴ ساعت)\n\n'
         'لطفاً فصل‌های طولانی‌تر را به بخش‌های کوچک‌تر تقسیم کنید.',
       );
     }
 
-    // 5. Warning for potentially large files (estimate duration from size)
-    // At 64 kbps, 1 minute ≈ 0.5 MB, so 50 MB ≈ 100 minutes
-    // If file is close to limit, show warning
-    if (fileSizeBytes > maxFileSizeBytes * 0.8) {
+    // 5. Warning for files approaching the limit
+    // Large files may take longer to upload and could fail on slow connections
+    if (fileSizeBytes > warnFileSizeBytes) {
+      final sizeMB = (fileSizeBytes / (1024 * 1024)).toStringAsFixed(0);
       return AudioValidationResult.valid(
-        warning: 'حجم فایل به حداکثر مجاز نزدیک است. '
-            'برای فصل‌های بعدی، تنظیمات فشرده‌سازی را بررسی کنید.',
+        warning: 'حجم فایل شما $sizeMB مگابایت است (حداکثر $kServerMaxFileSizeMB مگابایت). '
+            'آپلود ممکن است زمان‌بر باشد.',
       );
     }
 
@@ -143,8 +165,8 @@ class AudioValidator {
       'کانال: مونو (Mono)',
       'نرخ نمونه‌برداری: 44.1 kHz',
       'بیت‌ریت: 64-96 kbps',
-      'حداکثر مدت هر فصل: 60 دقیقه',
-      'حداکثر حجم هر فصل: 50 مگابایت',
+      'حداکثر مدت هر فصل: ${maxDurationSeconds ~/ 60} دقیقه',
+      'حداکثر حجم هر فصل: $kServerMaxFileSizeMB مگابایت',
     ];
   }
 
@@ -152,4 +174,47 @@ class AudioValidator {
   static List<String> getAllowedExtensions() {
     return acceptedExtensions;
   }
+
+  /// Parse upload error and return a user-friendly Farsi message.
+  /// Handles 413 Payload Too Large and other common storage errors.
+  static String getUploadErrorMessage(Object error) {
+    final errorStr = error.toString().toLowerCase();
+
+    // Check for 413 Payload Too Large (file size exceeded server limit)
+    if (errorStr.contains('413') ||
+        errorStr.contains('payload too large') ||
+        errorStr.contains('exceeded the maximum allowed size') ||
+        errorStr.contains('entity too large')) {
+      return 'حجم فایل از حد مجاز سرور بیشتر است.\n\n'
+          'حداکثر حجم مجاز: $kServerMaxFileSizeMB مگابایت\n\n'
+          'لطفاً فایل را با حجم کمتر آپلود کنید.';
+    }
+
+    // Check for network/timeout errors
+    if (errorStr.contains('timeout') || errorStr.contains('timed out')) {
+      return 'زمان آپلود به پایان رسید.\n\n'
+          'لطفاً اتصال اینترنت خود را بررسی کرده و دوباره تلاش کنید.';
+    }
+
+    // Check for connection errors
+    if (errorStr.contains('connection') ||
+        errorStr.contains('network') ||
+        errorStr.contains('socket')) {
+      return 'خطا در اتصال به سرور.\n\n'
+          'لطفاً اتصال اینترنت خود را بررسی کرده و دوباره تلاش کنید.';
+    }
+
+    // Check for authentication errors
+    if (errorStr.contains('unauthorized') ||
+        errorStr.contains('401') ||
+        errorStr.contains('403') ||
+        errorStr.contains('forbidden')) {
+      return 'خطا در احراز هویت.\n\n'
+          'لطفاً از برنامه خارج شده و دوباره وارد شوید.';
+    }
+
+    // Default error message - don't expose raw error to user
+    return 'خطا در آپلود فایل.\n\n'
+        'لطفاً دوباره تلاش کنید. اگر مشکل ادامه داشت، با پشتیبانی تماس بگیرید.';
+  }
 }
diff --git a/lib/widgets/error_view.dart b/lib/widgets/error_view.dart
index 3b1bdda..dcf65e4 100644
--- a/lib/widgets/error_view.dart
+++ b/lib/widgets/error_view.dart
@@ -108,7 +108,7 @@ class ErrorView extends StatelessWidget {
               const SizedBox(height: 8),
               Text(
                 details!,
-                style: TextStyle(
+                style: const TextStyle(
                   color: AppColors.textSecondary,
                   fontSize: 14,
                 ),
diff --git a/lib/widgets/loading_view.dart b/lib/widgets/loading_view.dart
index 3a20cc1..8fe1c6a 100644
--- a/lib/widgets/loading_view.dart
+++ b/lib/widgets/loading_view.dart
@@ -60,7 +60,7 @@ class LoadingView extends StatelessWidget {
     );
 
     if (overlay) {
-      return Container(
+      return ColoredBox(
         color: AppColors.background.withOpacity(0.8),
         child: content,
       );
diff --git a/lib/widgets/mini_player.dart b/lib/widgets/mini_player.dart
index 202e4de..dcd1e49 100644
--- a/lib/widgets/mini_player.dart
+++ b/lib/widgets/mini_player.dart
@@ -3,39 +3,54 @@ import 'package:flutter_riverpod/flutter_riverpod.dart';
 import 'package:myna/theme/app_theme.dart';
 import 'package:myna/providers/audio_provider.dart';
 import 'package:myna/screens/player/player_screen.dart';
+import 'package:myna/utils/app_logger.dart';
 
 class MiniPlayer extends ConsumerWidget {
   const MiniPlayer({super.key});
 
   @override
   Widget build(BuildContext context, WidgetRef ref) {
-    final audio = ref.watch(audioProvider);
+    final audioUi = ref.watch(
+      audioProvider.select(
+        (state) => (
+          audiobook: state.audiobook,
+          chapters: state.chapters,
+          currentChapterIndex: state.currentChapterIndex,
+          isPlaying: state.isPlaying,
+          isLoading: state.isLoading,
+          isBuffering: state.isBuffering,
+          hasError: state.hasError,
+        ),
+      ),
+    );
 
-    if (!audio.hasAudio) return const SizedBox.shrink();
+    if (audioUi.audiobook == null) return const SizedBox.shrink();
 
-    final book = audio.audiobook!;
-    final chapter = audio.chapters.isNotEmpty && audio.currentChapterIndex < audio.chapters.length
-        ? audio.chapters[audio.currentChapterIndex]
+    final book = audioUi.audiobook!;
+    final chapter = audioUi.chapters.isNotEmpty &&
+            audioUi.currentChapterIndex < audioUi.chapters.length
+        ? audioUi.chapters[audioUi.currentChapterIndex]
         : null;
 
-    // Calculate progress
-    final progress = audio.duration.inMilliseconds > 0
-        ? (audio.position.inMilliseconds / audio.duration.inMilliseconds).clamp(0.0, 1.0)
-        : 0.0;
-
-    return GestureDetector(
-      onTap: () {
-        Navigator.push(
-          context,
-          MaterialPageRoute<void>(
-            builder: (_) => PlayerScreen(
-              audiobook: book,
-              chapters: audio.chapters,
-              initialChapterIndex: audio.currentChapterIndex,
+    // FIX: Use Material + InkWell for the container instead of GestureDetector
+    // This allows child buttons to properly absorb their tap events
+    return Material(
+      color: Colors.transparent,
+      child: InkWell(
+        onTap: () {
+          AppLogger.audio('MINI: Container tapped - opening player');
+          Navigator.push(
+            context,
+            MaterialPageRoute<void>(
+              builder: (_) => PlayerScreen(
+                audiobook: book,
+                chapters: audioUi.chapters,
+                initialChapterIndex: audioUi.currentChapterIndex,
+              ),
             ),
-          ),
-        );
-      },
+          );
+        },
+        borderRadius: BorderRadius.circular(16),
       child: Container(
         margin: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
         decoration: BoxDecoration(
@@ -63,11 +78,22 @@ class MiniPlayer extends ConsumerWidget {
 
                   // Title & Chapter info
                   Expanded(
-                    child: _buildInfo(book, chapter, audio),
+                    child: _buildInfo(
+                      book,
+                      chapter,
+                      audioUi.currentChapterIndex,
+                      audioUi.hasError,
+                      audioUi.isBuffering,
+                    ),
                   ),
 
                   // Play/Pause button
-                  _buildPlayPauseButton(audio, ref),
+                  _buildPlayPauseButton(
+                    isPlaying: audioUi.isPlaying,
+                    isLoading: audioUi.isLoading,
+                    hasError: audioUi.hasError,
+                    ref: ref,
+                  ),
 
                   // Close button
                   _buildCloseButton(ref),
@@ -76,11 +102,30 @@ class MiniPlayer extends ConsumerWidget {
             ),
 
             // Progress bar
-            _buildProgressBar(progress, audio.hasError),
+            Consumer(
+              builder: (context, ref, _) {
+                final progressState = ref.watch(
+                  audioProvider.select(
+                    (state) => (
+                      position: state.position,
+                      duration: state.duration,
+                      hasError: state.hasError,
+                    ),
+                  ),
+                );
+                final progress = progressState.duration.inMilliseconds > 0
+                    ? (progressState.position.inMilliseconds /
+                            progressState.duration.inMilliseconds)
+                        .clamp(0.0, 1.0)
+                    : 0.0;
+                return _buildProgressBar(progress, progressState.hasError);
+              },
+            ),
           ],
         ),
       ),
-    );
+      ), // Close InkWell
+    ); // Close Material
   }
 
   Widget _buildCover(Map<String, dynamic> book) {
@@ -114,7 +159,13 @@ class MiniPlayer extends ConsumerWidget {
     );
   }
 
-  Widget _buildInfo(Map<String, dynamic> book, Map<String, dynamic>? chapter, AudioState audio) {
+  Widget _buildInfo(
+    Map<String, dynamic> book,
+    Map<String, dynamic>? chapter,
+    int currentChapterIndex,
+    bool hasError,
+    bool isBuffering,
+  ) {
     final title = (book['title'] as String?) ?? (book['title_fa'] as String?) ?? '';
 
     return Column(
@@ -124,25 +175,25 @@ class MiniPlayer extends ConsumerWidget {
         // Title
         Text(
           title,
-          style: const TextStyle(
-            color: AppColors.textPrimary,
-            fontWeight: FontWeight.w600,
-            fontSize: 14,
-            height: 1.2,
-          ),
+          style: AppTypography.cardTitle,
           maxLines: 1,
           overflow: TextOverflow.ellipsis,
         ),
         const SizedBox(height: 4),
 
         // Status / Chapter info
-        _buildStatusRow(chapter, audio),
+        _buildStatusRow(chapter, currentChapterIndex, hasError, isBuffering),
       ],
     );
   }
 
-  Widget _buildStatusRow(Map<String, dynamic>? chapter, AudioState audio) {
-    if (audio.hasError) {
+  Widget _buildStatusRow(
+    Map<String, dynamic>? chapter,
+    int currentChapterIndex,
+    bool hasError,
+    bool isBuffering,
+  ) {
+    if (hasError) {
       return Row(
         children: [
           Container(
@@ -154,14 +205,10 @@ class MiniPlayer extends ConsumerWidget {
             ),
           ),
           const SizedBox(width: 6),
-          const Expanded(
+          Expanded(
             child: Text(
               'خطا در پخش',
-              style: TextStyle(
-                color: AppColors.error,
-                fontSize: 12,
-                fontWeight: FontWeight.w500,
-              ),
+              style: AppTypography.labelMedium.copyWith(color: AppColors.error),
               maxLines: 1,
               overflow: TextOverflow.ellipsis,
             ),
@@ -170,7 +217,7 @@ class MiniPlayer extends ConsumerWidget {
       );
     }
 
-    if (audio.isBuffering) {
+    if (isBuffering) {
       return Row(
         children: [
           SizedBox(
@@ -182,12 +229,9 @@ class MiniPlayer extends ConsumerWidget {
             ),
           ),
           const SizedBox(width: 6),
-          const Text(
+          Text(
             'در حال بارگذاری...',
-            style: TextStyle(
-              color: AppColors.textTertiary,
-              fontSize: 12,
-            ),
+            style: AppTypography.cardSubtitle,
           ),
         ],
       );
@@ -195,42 +239,47 @@ class MiniPlayer extends ConsumerWidget {
 
     // Show chapter name
     return Text(
-      (chapter?['title_fa'] as String?) ?? 'فصل ${audio.currentChapterIndex + 1}',
-      style: const TextStyle(
-        color: AppColors.textSecondary,
-        fontSize: 12,
-      ),
+      (chapter?['title_fa'] as String?) ?? 'فصل ${currentChapterIndex + 1}',
+      style: AppTypography.cardSubtitle,
       maxLines: 1,
       overflow: TextOverflow.ellipsis,
     );
   }
 
-  Widget _buildPlayPauseButton(AudioState audio, WidgetRef ref) {
+  Widget _buildPlayPauseButton({
+    required bool isPlaying,
+    required bool isLoading,
+    required bool hasError,
+    required WidgetRef ref,
+  }) {
     final notifier = ref.read(audioProvider.notifier);
 
-    if (audio.hasError) {
-      // Retry button
-      return Container(
-        width: 44,
-        height: 44,
-        margin: const EdgeInsets.symmetric(horizontal: 4),
-        decoration: BoxDecoration(
-          color: AppColors.error.withOpacity(0.15),
-          shape: BoxShape.circle,
-        ),
-        child: IconButton(
-          icon: const Icon(
+    if (hasError) {
+      // Retry button - GestureDetector for guaranteed tap handling
+      return GestureDetector(
+        behavior: HitTestBehavior.opaque,
+        onTap: () {
+          AppLogger.audio('MINI: Retry tapped (hasError=true)');
+          notifier.retry();
+        },
+        child: Container(
+          width: 44,
+          height: 44,
+          margin: const EdgeInsets.symmetric(horizontal: 4),
+          decoration: BoxDecoration(
+            color: AppColors.error.withOpacity(0.15),
+            shape: BoxShape.circle,
+          ),
+          child: const Icon(
             Icons.refresh_rounded,
             color: AppColors.error,
             size: 24,
           ),
-          padding: EdgeInsets.zero,
-          onPressed: notifier.retry,
         ),
       );
     }
 
-    if (audio.isLoading) {
+    if (isLoading) {
       // Loading spinner
       return Container(
         width: 44,
@@ -248,67 +297,84 @@ class MiniPlayer extends ConsumerWidget {
       );
     }
 
-    // Play/Pause button
-    return Container(
-      width: 44,
-      height: 44,
-      margin: const EdgeInsets.symmetric(horizontal: 4),
-      decoration: BoxDecoration(
-        color: AppColors.primary,
-        shape: BoxShape.circle,
-        boxShadow: [
-          BoxShadow(
-            color: AppColors.primary.withOpacity(0.3),
-            blurRadius: 8,
-            offset: const Offset(0, 2),
+    // Play/Pause button - Use GestureDetector with opaque behavior for reliable tap handling
+    return GestureDetector(
+      behavior: HitTestBehavior.opaque,
+      onTap: () {
+        AppLogger.audio('MINI: Play/Pause tapped, isPlaying=$isPlaying');
+        notifier.togglePlayPause();
+      },
+      child: Container(
+        width: 48,
+        height: 48,
+        margin: const EdgeInsets.symmetric(horizontal: 4),
+        decoration: BoxDecoration(
+          color: AppColors.primary,
+          shape: BoxShape.circle,
+          boxShadow: [
+            BoxShadow(
+              color: AppColors.primary.withOpacity(0.3),
+              blurRadius: 8,
+              offset: const Offset(0, 2),
+            ),
+          ],
+        ),
+        child: Center(
+          child: Icon(
+            isPlaying ? Icons.pause_rounded : Icons.play_arrow_rounded,
+            color: Colors.white,
+            size: 28,
           ),
-        ],
-      ),
-      child: IconButton(
-        icon: Icon(
-          audio.isPlaying ? Icons.pause_rounded : Icons.play_arrow_rounded,
-          color: Colors.white,
-          size: 26,
         ),
-        padding: EdgeInsets.zero,
-        onPressed: notifier.togglePlayPause,
       ),
     );
   }
 
   Widget _buildCloseButton(WidgetRef ref) {
-    return SizedBox(
-      width: 36,
-      height: 36,
-      child: IconButton(
-        icon: const Icon(
+    // Use GestureDetector for reliable tap handling on all devices
+    return GestureDetector(
+      behavior: HitTestBehavior.opaque,
+      onTap: () {
+        AppLogger.audio('MINI: Close button tapped');
+        ref.read(audioProvider.notifier).stop();
+      },
+      child: const SizedBox(
+        width: 36,
+        height: 36,
+        child: Icon(
           Icons.close_rounded,
           color: AppColors.textTertiary,
           size: 20,
         ),
-        padding: EdgeInsets.zero,
-        onPressed: () => ref.read(audioProvider.notifier).stop(),
       ),
     );
   }
 
   Widget _buildProgressBar(double progress, bool hasError) {
     return Container(
-      height: 3,
+      height: 4, // Slightly thicker for better visibility
       margin: const EdgeInsets.only(left: 12, right: 12, bottom: 8),
       decoration: BoxDecoration(
         color: AppColors.surfaceLight,
-        borderRadius: BorderRadius.circular(1.5),
+        borderRadius: BorderRadius.circular(2),
       ),
-      child: FractionallySizedBox(
-        alignment: Alignment.centerRight,
-        widthFactor: progress,
-        child: Container(
-          decoration: BoxDecoration(
-            color: hasError ? AppColors.error : AppColors.primary,
-            borderRadius: BorderRadius.circular(1.5),
-          ),
-        ),
+      child: LayoutBuilder(
+        builder: (context, constraints) {
+          // Use Directionality.of to respect RTL but progress always fills left-to-right
+          return Directionality(
+            textDirection: TextDirection.ltr, // Progress always left-to-right
+            child: FractionallySizedBox(
+              alignment: Alignment.centerLeft,
+              widthFactor: progress.clamp(0.0, 1.0),
+              child: Container(
+                decoration: BoxDecoration(
+                  color: hasError ? AppColors.error : AppColors.primary,
+                  borderRadius: BorderRadius.circular(2),
+                ),
+              ),
+            ),
+          );
+        },
       ),
     );
   }
diff --git a/lib/widgets/review/review_card.dart b/lib/widgets/review/review_card.dart
index c5c0213..29645df 100644
--- a/lib/widgets/review/review_card.dart
+++ b/lib/widgets/review/review_card.dart
@@ -43,14 +43,20 @@ class ReviewCard extends StatelessWidget {
             Text(userName, style: const TextStyle(fontWeight: FontWeight.bold, color: AppColors.textPrimary)),
             const SizedBox(height: 4),
             Row(children: [RatingStars(rating: rating.toDouble(), size: 14), const SizedBox(width: 8),
-              Text(_formatDate(createdAt), style: TextStyle(fontSize: 11, color: AppColors.textTertiary))])])),
-          if (isOwn) PopupMenuButton<String>(icon: Icon(Icons.more_vert, color: AppColors.textTertiary), color: AppColors.surface,
-            onSelected: (v) { if (v == 'edit' && onEdit != null) onEdit!(); else if (v == 'delete' && onDelete != null) onDelete!(); },
+              Text(_formatDate(createdAt), style: const TextStyle(fontSize: 11, color: AppColors.textTertiary))])])),
+          if (isOwn) PopupMenuButton<String>(icon: const Icon(Icons.more_vert, color: AppColors.textTertiary), color: AppColors.surface,
+            onSelected: (v) {
+              if (v == 'edit' && onEdit != null) {
+                onEdit!();
+              } else if (v == 'delete' && onDelete != null) {
+                onDelete!();
+              }
+            },
             itemBuilder: (context) => [
               const PopupMenuItem(value: 'edit', child: Row(children: [Icon(Icons.edit, size: 18, color: AppColors.primary), SizedBox(width: 8), Text('ویرایش')])),
               const PopupMenuItem(value: 'delete', child: Row(children: [Icon(Icons.delete, size: 18, color: AppColors.error), SizedBox(width: 8), Text('حذف', style: TextStyle(color: AppColors.error))]))])]),
         if (title != null && title.isNotEmpty) ...[const SizedBox(height: 12), Text(title, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 15, color: AppColors.textPrimary))],
-        if (content != null && content.isNotEmpty) ...[const SizedBox(height: 8), Text(content, style: TextStyle(color: AppColors.textSecondary, height: 1.5))],
+        if (content != null && content.isNotEmpty) ...[const SizedBox(height: 8), Text(content, style: const TextStyle(color: AppColors.textSecondary, height: 1.5))],
       ])));
   }
 }
diff --git a/lib/widgets/skeleton_loaders.dart b/lib/widgets/skeleton_loaders.dart
index d719b3c..f8383a3 100644
--- a/lib/widgets/skeleton_loaders.dart
+++ b/lib/widgets/skeleton_loaders.dart
@@ -176,7 +176,7 @@ class _GridBookSkeleton extends StatelessWidget {
       baseColor: _ShimmerConfig.baseColor,
       highlightColor: _ShimmerConfig.highlightColor,
       period: _ShimmerConfig.duration,
-      child: Container(
+      child: DecoratedBox(
         decoration: BoxDecoration(
           color: _ShimmerConfig.baseColor,
           borderRadius: BorderRadius.circular(12),
@@ -187,9 +187,9 @@ class _GridBookSkeleton extends StatelessWidget {
             Expanded(
               flex: 3,
               child: Container(
-                decoration: BoxDecoration(
+                decoration: const BoxDecoration(
                   color: _ShimmerConfig.baseColor,
-                  borderRadius: const BorderRadius.vertical(top: Radius.circular(12)),
+                  borderRadius: BorderRadius.vertical(top: Radius.circular(12)),
                 ),
               ),
             ),
diff --git a/macos/Flutter/GeneratedPluginRegistrant.swift b/macos/Flutter/GeneratedPluginRegistrant.swift
index 75ee460..831118d 100644
--- a/macos/Flutter/GeneratedPluginRegistrant.swift
+++ b/macos/Flutter/GeneratedPluginRegistrant.swift
@@ -8,11 +8,9 @@ import Foundation
 import app_links
 import audio_service
 import audio_session
-import connectivity_plus
 import file_selector_macos
 import just_audio
 import path_provider_foundation
-import share_plus
 import shared_preferences_foundation
 import sqflite_darwin
 import url_launcher_macos
@@ -21,11 +19,9 @@ func RegisterGeneratedPlugins(registry: FlutterPluginRegistry) {
   AppLinksMacosPlugin.register(with: registry.registrar(forPlugin: "AppLinksMacosPlugin"))
   AudioServicePlugin.register(with: registry.registrar(forPlugin: "AudioServicePlugin"))
   AudioSessionPlugin.register(with: registry.registrar(forPlugin: "AudioSessionPlugin"))
-  ConnectivityPlugin.register(with: registry.registrar(forPlugin: "ConnectivityPlugin"))
   FileSelectorPlugin.register(with: registry.registrar(forPlugin: "FileSelectorPlugin"))
   JustAudioPlugin.register(with: registry.registrar(forPlugin: "JustAudioPlugin"))
   PathProviderPlugin.register(with: registry.registrar(forPlugin: "PathProviderPlugin"))
-  SharePlusMacosPlugin.register(with: registry.registrar(forPlugin: "SharePlusMacosPlugin"))
   SharedPreferencesPlugin.register(with: registry.registrar(forPlugin: "SharedPreferencesPlugin"))
   SqflitePlugin.register(with: registry.registrar(forPlugin: "SqflitePlugin"))
   UrlLauncherPlugin.register(with: registry.registrar(forPlugin: "UrlLauncherPlugin"))
diff --git a/macos/Runner.xcodeproj/project.pbxproj b/macos/Runner.xcodeproj/project.pbxproj
index ad2b3cc..d87798d 100644
--- a/macos/Runner.xcodeproj/project.pbxproj
+++ b/macos/Runner.xcodeproj/project.pbxproj
@@ -27,6 +27,8 @@
 		33CC10F32044A3C60003C045 /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 33CC10F22044A3C60003C045 /* Assets.xcassets */; };
 		33CC10F62044A3C60003C045 /* MainMenu.xib in Resources */ = {isa = PBXBuildFile; fileRef = 33CC10F42044A3C60003C045 /* MainMenu.xib */; };
 		33CC11132044BFA00003C045 /* MainFlutterWindow.swift in Sources */ = {isa = PBXBuildFile; fileRef = 33CC11122044BFA00003C045 /* MainFlutterWindow.swift */; };
+		51AC2E22238D67569B3C6E95 /* Pods_RunnerTests.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = C0E610E07AEE2335DD2356C0 /* Pods_RunnerTests.framework */; };
+		8C4B6BA4700AE4F329D6B480 /* Pods_Runner.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 22C769210A0096C727F0C490 /* Pods_Runner.framework */; };
 /* End PBXBuildFile section */
 
 /* Begin PBXContainerItemProxy section */
@@ -60,11 +62,14 @@
 /* End PBXCopyFilesBuildPhase section */
 
 /* Begin PBXFileReference section */
+		1F82911E7B6E4A78FCA8E274 /* Pods-Runner.profile.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.profile.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.profile.xcconfig"; sourceTree = "<group>"; };
+		22C769210A0096C727F0C490 /* Pods_Runner.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_Runner.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+		255CB0EBBD4E966DC1B3B669 /* Pods-RunnerTests.profile.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.profile.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.profile.xcconfig"; sourceTree = "<group>"; };
 		331C80D5294CF71000263BE5 /* RunnerTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = RunnerTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
 		331C80D7294CF71000263BE5 /* RunnerTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RunnerTests.swift; sourceTree = "<group>"; };
 		333000ED22D3DE5D00554162 /* Warnings.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = Warnings.xcconfig; sourceTree = "<group>"; };
 		335BBD1A22A9A15E00E9071D /* GeneratedPluginRegistrant.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = GeneratedPluginRegistrant.swift; sourceTree = "<group>"; };
-		33CC10ED2044A3C60003C045 /* myna.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = "myna.app"; sourceTree = BUILT_PRODUCTS_DIR; };
+		33CC10ED2044A3C60003C045 /* myna.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = myna.app; sourceTree = BUILT_PRODUCTS_DIR; };
 		33CC10F02044A3C60003C045 /* AppDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
 		33CC10F22044A3C60003C045 /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; name = Assets.xcassets; path = Runner/Assets.xcassets; sourceTree = "<group>"; };
 		33CC10F52044A3C60003C045 /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = Base; path = Base.lproj/MainMenu.xib; sourceTree = "<group>"; };
@@ -76,8 +81,13 @@
 		33E51913231747F40026EE4D /* DebugProfile.entitlements */ = {isa = PBXFileReference; lastKnownFileType = text.plist.entitlements; path = DebugProfile.entitlements; sourceTree = "<group>"; };
 		33E51914231749380026EE4D /* Release.entitlements */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.entitlements; path = Release.entitlements; sourceTree = "<group>"; };
 		33E5194F232828860026EE4D /* AppInfo.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = AppInfo.xcconfig; sourceTree = "<group>"; };
+		743FA5B06A63D2642138232C /* Pods-Runner.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.release.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig"; sourceTree = "<group>"; };
+		757A183F4F6D961D2C2A82CC /* Pods-RunnerTests.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.release.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.release.xcconfig"; sourceTree = "<group>"; };
 		7AFA3C8E1D35360C0083082E /* Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = Release.xcconfig; sourceTree = "<group>"; };
 		9740EEB21CF90195004384FC /* Debug.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; path = Debug.xcconfig; sourceTree = "<group>"; };
+		C0E610E07AEE2335DD2356C0 /* Pods_RunnerTests.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_RunnerTests.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+		C65A7588BB78E9FCAC06A028 /* Pods-Runner.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.debug.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.debug.xcconfig"; sourceTree = "<group>"; };
+		CE035A698CDB0A9302A572F2 /* Pods-RunnerTests.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.debug.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.debug.xcconfig"; sourceTree = "<group>"; };
 /* End PBXFileReference section */
 
 /* Begin PBXFrameworksBuildPhase section */
@@ -85,6 +95,7 @@
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
+				51AC2E22238D67569B3C6E95 /* Pods_RunnerTests.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -92,6 +103,7 @@
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
+				8C4B6BA4700AE4F329D6B480 /* Pods_Runner.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -125,6 +137,7 @@
 				331C80D6294CF71000263BE5 /* RunnerTests */,
 				33CC10EE2044A3C60003C045 /* Products */,
 				D73912EC22F37F3D000D13A0 /* Frameworks */,
+				84DCFD661F68AF9C817C4943 /* Pods */,
 			);
 			sourceTree = "<group>";
 		};
@@ -172,9 +185,25 @@
 			path = Runner;
 			sourceTree = "<group>";
 		};
+		84DCFD661F68AF9C817C4943 /* Pods */ = {
+			isa = PBXGroup;
+			children = (
+				C65A7588BB78E9FCAC06A028 /* Pods-Runner.debug.xcconfig */,
+				743FA5B06A63D2642138232C /* Pods-Runner.release.xcconfig */,
+				1F82911E7B6E4A78FCA8E274 /* Pods-Runner.profile.xcconfig */,
+				CE035A698CDB0A9302A572F2 /* Pods-RunnerTests.debug.xcconfig */,
+				757A183F4F6D961D2C2A82CC /* Pods-RunnerTests.release.xcconfig */,
+				255CB0EBBD4E966DC1B3B669 /* Pods-RunnerTests.profile.xcconfig */,
+			);
+			name = Pods;
+			path = Pods;
+			sourceTree = "<group>";
+		};
 		D73912EC22F37F3D000D13A0 /* Frameworks */ = {
 			isa = PBXGroup;
 			children = (
+				22C769210A0096C727F0C490 /* Pods_Runner.framework */,
+				C0E610E07AEE2335DD2356C0 /* Pods_RunnerTests.framework */,
 			);
 			name = Frameworks;
 			sourceTree = "<group>";
@@ -186,6 +215,7 @@
 			isa = PBXNativeTarget;
 			buildConfigurationList = 331C80DE294CF71000263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */;
 			buildPhases = (
+				0B2822D380F9888C249696E2 /* [CP] Check Pods Manifest.lock */,
 				331C80D1294CF70F00263BE5 /* Sources */,
 				331C80D2294CF70F00263BE5 /* Frameworks */,
 				331C80D3294CF70F00263BE5 /* Resources */,
@@ -204,11 +234,13 @@
 			isa = PBXNativeTarget;
 			buildConfigurationList = 33CC10FB2044A3C60003C045 /* Build configuration list for PBXNativeTarget "Runner" */;
 			buildPhases = (
+				C427E1B20A1B4BD79F992DE2 /* [CP] Check Pods Manifest.lock */,
 				33CC10E92044A3C60003C045 /* Sources */,
 				33CC10EA2044A3C60003C045 /* Frameworks */,
 				33CC10EB2044A3C60003C045 /* Resources */,
 				33CC110E2044A8840003C045 /* Bundle Framework */,
 				3399D490228B24CF009A79C7 /* ShellScript */,
+				AFCB9B053D494CDDA495F350 /* [CP] Embed Pods Frameworks */,
 			);
 			buildRules = (
 			);
@@ -291,6 +323,28 @@
 /* End PBXResourcesBuildPhase section */
 
 /* Begin PBXShellScriptBuildPhase section */
+		0B2822D380F9888C249696E2 /* [CP] Check Pods Manifest.lock */ = {
+			isa = PBXShellScriptBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			inputFileListPaths = (
+			);
+			inputPaths = (
+				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
+				"${PODS_ROOT}/Manifest.lock",
+			);
+			name = "[CP] Check Pods Manifest.lock";
+			outputFileListPaths = (
+			);
+			outputPaths = (
+				"$(DERIVED_FILE_DIR)/Pods-RunnerTests-checkManifestLockResult.txt",
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+			shellPath = /bin/sh;
+			shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n    exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
+			showEnvVarsInLog = 0;
+		};
 		3399D490228B24CF009A79C7 /* ShellScript */ = {
 			isa = PBXShellScriptBuildPhase;
 			alwaysOutOfDate = 1;
@@ -329,6 +383,45 @@
 			shellPath = /bin/sh;
 			shellScript = "\"$FLUTTER_ROOT\"/packages/flutter_tools/bin/macos_assemble.sh && touch Flutter/ephemeral/tripwire";
 		};
+		AFCB9B053D494CDDA495F350 /* [CP] Embed Pods Frameworks */ = {
+			isa = PBXShellScriptBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			inputFileListPaths = (
+				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-frameworks-${CONFIGURATION}-input-files.xcfilelist",
+			);
+			name = "[CP] Embed Pods Frameworks";
+			outputFileListPaths = (
+				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-frameworks-${CONFIGURATION}-output-files.xcfilelist",
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+			shellPath = /bin/sh;
+			shellScript = "\"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-frameworks.sh\"\n";
+			showEnvVarsInLog = 0;
+		};
+		C427E1B20A1B4BD79F992DE2 /* [CP] Check Pods Manifest.lock */ = {
+			isa = PBXShellScriptBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			inputFileListPaths = (
+			);
+			inputPaths = (
+				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
+				"${PODS_ROOT}/Manifest.lock",
+			);
+			name = "[CP] Check Pods Manifest.lock";
+			outputFileListPaths = (
+			);
+			outputPaths = (
+				"$(DERIVED_FILE_DIR)/Pods-Runner-checkManifestLockResult.txt",
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+			shellPath = /bin/sh;
+			shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n    exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
+			showEnvVarsInLog = 0;
+		};
 /* End PBXShellScriptBuildPhase section */
 
 /* Begin PBXSourcesBuildPhase section */
@@ -380,6 +473,7 @@
 /* Begin XCBuildConfiguration section */
 		331C80DB294CF71000263BE5 /* Debug */ = {
 			isa = XCBuildConfiguration;
+			baseConfigurationReference = CE035A698CDB0A9302A572F2 /* Pods-RunnerTests.debug.xcconfig */;
 			buildSettings = {
 				BUNDLE_LOADER = "$(TEST_HOST)";
 				CURRENT_PROJECT_VERSION = 1;
@@ -394,6 +488,7 @@
 		};
 		331C80DC294CF71000263BE5 /* Release */ = {
 			isa = XCBuildConfiguration;
+			baseConfigurationReference = 757A183F4F6D961D2C2A82CC /* Pods-RunnerTests.release.xcconfig */;
 			buildSettings = {
 				BUNDLE_LOADER = "$(TEST_HOST)";
 				CURRENT_PROJECT_VERSION = 1;
@@ -408,6 +503,7 @@
 		};
 		331C80DD294CF71000263BE5 /* Profile */ = {
 			isa = XCBuildConfiguration;
+			baseConfigurationReference = 255CB0EBBD4E966DC1B3B669 /* Pods-RunnerTests.profile.xcconfig */;
 			buildSettings = {
 				BUNDLE_LOADER = "$(TEST_HOST)";
 				CURRENT_PROJECT_VERSION = 1;
diff --git a/macos/Runner.xcworkspace/contents.xcworkspacedata b/macos/Runner.xcworkspace/contents.xcworkspacedata
index 1d526a1..21a3cc1 100644
--- a/macos/Runner.xcworkspace/contents.xcworkspacedata
+++ b/macos/Runner.xcworkspace/contents.xcworkspacedata
@@ -4,4 +4,7 @@
    <FileRef
       location = "group:Runner.xcodeproj">
    </FileRef>
+   <FileRef
+      location = "group:Pods/Pods.xcodeproj">
+   </FileRef>
 </Workspace>
diff --git a/pubspec.lock b/pubspec.lock
index 9438afb..306e1fa 100644
--- a/pubspec.lock
+++ b/pubspec.lock
@@ -2,13 +2,21 @@
 # See https://dart.dev/tools/pub/glossary#lockfile
 packages:
   app_links:
-    dependency: "direct main"
+    dependency: transitive
     description:
       name: app_links
       sha256: c7b2c4466992ed824da0d994a293670b704c13ec9f1f4f3c8c4b4fc2869a0cc1
       url: "https://pub.dev"
     source: hosted
     version: "6.1.0"
+  archive:
+    dependency: transitive
+    description:
+      name: archive
+      sha256: "2fde1607386ab523f7a36bb3e7edb43bd58e6edaf2ffb29d8a6d578b297fdbbd"
+      url: "https://pub.dev"
+    source: hosted
+    version: "4.0.7"
   args:
     dependency: transitive
     description:
@@ -97,6 +105,22 @@ packages:
       url: "https://pub.dev"
     source: hosted
     version: "1.3.0"
+  checked_yaml:
+    dependency: transitive
+    description:
+      name: checked_yaml
+      sha256: feb6bed21949061731a7a75fc5d2aa727cf160b91af9a3e464c5e3a32e28b5ff
+      url: "https://pub.dev"
+    source: hosted
+    version: "2.0.3"
+  cli_util:
+    dependency: transitive
+    description:
+      name: cli_util
+      sha256: ff6785f7e9e3c38ac98b2fb035701789de90154024a75b6cb926445e83197d1c
+      url: "https://pub.dev"
+    source: hosted
+    version: "0.4.2"
   clock:
     dependency: transitive
     description:
@@ -113,22 +137,6 @@ packages:
       url: "https://pub.dev"
     source: hosted
     version: "1.18.0"
-  connectivity_plus:
-    dependency: "direct main"
-    description:
-      name: connectivity_plus
-      sha256: "224a77051d52a11fbad53dd57827594d3bd24f945af28bd70bab376d68d437f0"
-      url: "https://pub.dev"
-    source: hosted
-    version: "5.0.2"
-  connectivity_plus_platform_interface:
-    dependency: transitive
-    description:
-      name: connectivity_plus_platform_interface
-      sha256: cf1d1c28f4416f8c654d7dc3cd638ec586076255d407cef3ddbdaf178272a71a
-      url: "https://pub.dev"
-    source: hosted
-    version: "1.2.4"
   cross_file:
     dependency: transitive
     description:
@@ -145,14 +153,6 @@ packages:
       url: "https://pub.dev"
     source: hosted
     version: "3.0.7"
-  dbus:
-    dependency: transitive
-    description:
-      name: dbus
-      sha256: "79e0c23480ff85dc68de79e2cd6334add97e48f7f4865d17686dd6ea81a47e8c"
-      url: "https://pub.dev"
-    source: hosted
-    version: "0.7.11"
   dio:
     dependency: "direct main"
     description:
@@ -262,6 +262,14 @@ packages:
       url: "https://pub.dev"
     source: hosted
     version: "5.2.1"
+  flutter_launcher_icons:
+    dependency: "direct dev"
+    description:
+      name: flutter_launcher_icons
+      sha256: "526faf84284b86a4cb36d20a5e45147747b7563d921373d4ee0559c54fcdbcea"
+      url: "https://pub.dev"
+    source: hosted
+    version: "0.13.1"
   flutter_lints:
     dependency: "direct dev"
     description:
@@ -299,14 +307,6 @@ packages:
       url: "https://pub.dev"
     source: hosted
     version: "10.2.0"
-  flutter_svg:
-    dependency: "direct main"
-    description:
-      name: flutter_svg
-      sha256: d44bf546b13025ec7353091516f6881f1d4c633993cb109c3916c3a0159dadf1
-      url: "https://pub.dev"
-    source: hosted
-    version: "2.1.0"
   flutter_test:
     dependency: "direct dev"
     description: flutter
@@ -333,14 +333,6 @@ packages:
       url: "https://pub.dev"
     source: hosted
     version: "2.4.4"
-  go_router:
-    dependency: "direct main"
-    description:
-      name: go_router
-      sha256: b465e99ce64ba75e61c8c0ce3d87b66d8ac07f0b35d0a7e0263fcfc10f99e836
-      url: "https://pub.dev"
-    source: hosted
-    version: "13.2.5"
   gotrue:
     dependency: transitive
     description:
@@ -373,6 +365,14 @@ packages:
       url: "https://pub.dev"
     source: hosted
     version: "4.0.2"
+  image:
+    dependency: transitive
+    description:
+      name: image
+      sha256: "51555e36056541237b15b57afc31a0f53d4f9aefd9bd00873a6dc0090e54e332"
+      url: "https://pub.dev"
+    source: hosted
+    version: "4.6.0"
   image_picker:
     dependency: "direct main"
     description:
@@ -438,7 +438,7 @@ packages:
     source: hosted
     version: "0.2.1+1"
   intl:
-    dependency: "direct main"
+    dependency: transitive
     description:
       name: intl
       sha256: d6f56758b7d3014a48af9701c085700aac781a92a87a62b1333b46d8879661cf
@@ -573,14 +573,6 @@ packages:
       url: "https://pub.dev"
     source: hosted
     version: "1.0.6"
-  nm:
-    dependency: transitive
-    description:
-      name: nm
-      sha256: "2c9aae4127bdc8993206464fcc063611e0e36e72018696cd9631023a31b24254"
-      url: "https://pub.dev"
-    source: hosted
-    version: "0.5.0"
   octo_image:
     dependency: transitive
     description:
@@ -597,14 +589,6 @@ packages:
       url: "https://pub.dev"
     source: hosted
     version: "1.9.0"
-  path_parsing:
-    dependency: transitive
-    description:
-      name: path_parsing
-      sha256: "883402936929eac138ee0a45da5b0f2c80f89913e6dc3bf77eb65b84b409c6ca"
-      url: "https://pub.dev"
-    source: hosted
-    version: "1.1.0"
   path_provider:
     dependency: "direct main"
     description:
@@ -653,6 +637,54 @@ packages:
       url: "https://pub.dev"
     source: hosted
     version: "2.3.0"
+  permission_handler:
+    dependency: "direct main"
+    description:
+      name: permission_handler
+      sha256: "59adad729136f01ea9e35a48f5d1395e25cba6cea552249ddbe9cf950f5d7849"
+      url: "https://pub.dev"
+    source: hosted
+    version: "11.4.0"
+  permission_handler_android:
+    dependency: transitive
+    description:
+      name: permission_handler_android
+      sha256: d3971dcdd76182a0c198c096b5db2f0884b0d4196723d21a866fc4cdea057ebc
+      url: "https://pub.dev"
+    source: hosted
+    version: "12.1.0"
+  permission_handler_apple:
+    dependency: transitive
+    description:
+      name: permission_handler_apple
+      sha256: f000131e755c54cf4d84a5d8bd6e4149e262cc31c5a8b1d698de1ac85fa41023
+      url: "https://pub.dev"
+    source: hosted
+    version: "9.4.7"
+  permission_handler_html:
+    dependency: transitive
+    description:
+      name: permission_handler_html
+      sha256: "38f000e83355abb3392140f6bc3030660cfaef189e1f87824facb76300b4ff24"
+      url: "https://pub.dev"
+    source: hosted
+    version: "0.1.3+5"
+  permission_handler_platform_interface:
+    dependency: transitive
+    description:
+      name: permission_handler_platform_interface
+      sha256: eb99b295153abce5d683cac8c02e22faab63e50679b937fa1bf67d58bb282878
+      url: "https://pub.dev"
+    source: hosted
+    version: "4.3.0"
+  permission_handler_windows:
+    dependency: transitive
+    description:
+      name: permission_handler_windows
+      sha256: "1a790728016f79a41216d88672dbc5df30e686e811ad4e698bfc51f76ad91f1e"
+      url: "https://pub.dev"
+    source: hosted
+    version: "0.2.1"
   petitparser:
     dependency: transitive
     description:
@@ -677,6 +709,14 @@ packages:
       url: "https://pub.dev"
     source: hosted
     version: "2.1.8"
+  posix:
+    dependency: transitive
+    description:
+      name: posix
+      sha256: "6323a5b0fa688b6a010df4905a56b00181479e6d10534cecfecede2aa55add61"
+      url: "https://pub.dev"
+    source: hosted
+    version: "6.0.3"
   postgrest:
     dependency: transitive
     description:
@@ -717,22 +757,6 @@ packages:
       url: "https://pub.dev"
     source: hosted
     version: "0.28.0"
-  share_plus:
-    dependency: "direct main"
-    description:
-      name: share_plus
-      sha256: "3ef39599b00059db0990ca2e30fca0a29d8b37aae924d60063f8e0184cf20900"
-      url: "https://pub.dev"
-    source: hosted
-    version: "7.2.2"
-  share_plus_platform_interface:
-    dependency: transitive
-    description:
-      name: share_plus_platform_interface
-      sha256: "251eb156a8b5fa9ce033747d73535bf53911071f8d3b6f4f0b578505ce0d4496"
-      url: "https://pub.dev"
-    source: hosted
-    version: "3.4.0"
   shared_preferences:
     dependency: "direct main"
     description:
@@ -963,7 +987,7 @@ packages:
     source: hosted
     version: "1.4.0"
   url_launcher:
-    dependency: "direct main"
+    dependency: transitive
     description:
       name: url_launcher
       sha256: "9d06212b1362abc2f0f0d78e6f09f726608c74e3b9462e8368bb03314aa8d603"
@@ -1034,30 +1058,6 @@ packages:
       url: "https://pub.dev"
     source: hosted
     version: "4.5.2"
-  vector_graphics:
-    dependency: transitive
-    description:
-      name: vector_graphics
-      sha256: "44cc7104ff32563122a929e4620cf3efd584194eec6d1d913eb5ba593dbcf6de"
-      url: "https://pub.dev"
-    source: hosted
-    version: "1.1.18"
-  vector_graphics_codec:
-    dependency: transitive
-    description:
-      name: vector_graphics_codec
-      sha256: "99fd9fbd34d9f9a32efd7b6a6aae14125d8237b10403b422a6a6dfeac2806146"
-      url: "https://pub.dev"
-    source: hosted
-    version: "1.1.13"
-  vector_graphics_compiler:
-    dependency: transitive
-    description:
-      name: vector_graphics_compiler
-      sha256: "1b4b9e706a10294258727674a340ae0d6e64a7231980f9f9a3d12e4b42407aad"
-      url: "https://pub.dev"
-    source: hosted
-    version: "1.1.16"
   vector_math:
     dependency: transitive
     description:
@@ -1122,6 +1122,14 @@ packages:
       url: "https://pub.dev"
     source: hosted
     version: "6.5.0"
+  yaml:
+    dependency: transitive
+    description:
+      name: yaml
+      sha256: b9da305ac7c39faa3f030eccd175340f968459dae4af175130b3fc47e40d76ce
+      url: "https://pub.dev"
+    source: hosted
+    version: "3.1.3"
   yet_another_json_isolate:
     dependency: transitive
     description:
diff --git a/pubspec.yaml b/pubspec.yaml
index 5f8a7d1..ad685f1 100644
--- a/pubspec.yaml
+++ b/pubspec.yaml
@@ -14,13 +14,11 @@ dependencies:
   
   # Supabase - Backend as a Service
   supabase_flutter: ^2.8.0
-  app_links: 6.1.0
   
   # State Management
   flutter_riverpod: ^2.4.9
   
   # Navigation
-  go_router: ^13.0.0
   
   # Audio Player
   just_audio: ^0.9.36
@@ -39,14 +37,9 @@ dependencies:
   flutter_stripe: ^10.1.1
   
   # UI Components
-  flutter_svg: ^2.0.9
   shimmer: ^3.0.0
   
   # Utilities
-  intl: ^0.19.0
-  url_launcher: ^6.2.4
-  share_plus: ^7.2.2
-  connectivity_plus: ^5.0.2
 
   # Downloads
   dio: ^5.4.0
@@ -59,6 +52,9 @@ dependencies:
 
   # Local Storage
   shared_preferences: ^2.2.2
+
+  # Permissions - Required for Android 13+ POST_NOTIFICATIONS runtime permission
+  permission_handler: ^11.3.1
   
   # Persian/RTL Support
   flutter_localizations:
@@ -67,11 +63,41 @@ dependencies:
 dev_dependencies:
   flutter_test:
     sdk: flutter
-  
+
   flutter_lints: ^3.0.1
+  flutter_launcher_icons: ^0.13.1
+
+# App Icon Configuration
+flutter_launcher_icons:
+  android: true
+  ios: true
+  image_path: "assets/icons/app_icon.png"
+  # Android adaptive icon settings
+  # NOTE: adaptive_icon_foreground uses a PADDED version of the icon.
+  # Android adaptive icons crop ~18% from each edge, so the foreground
+  # must have the logo centered in the inner 66% "safe zone".
+  # The foreground asset should be 1024x1024 with ~170px padding on all sides.
+  adaptive_icon_background: "#1a1a2e"
+  adaptive_icon_foreground: "assets/icons/app_icon_foreground_android.png"
+  # Remove alpha channel for iOS (required)
+  remove_alpha_ios: true
 
 flutter:
   uses-material-design: true
 
   assets:
-    - .env
\ No newline at end of file
+    - .env
+
+  # Vazirmatn - Primary Farsi font for Parasto app
+  # Place font files in: assets/fonts/Vazirmatn/
+  fonts:
+    - family: Vazirmatn
+      fonts:
+        - asset: assets/fonts/Vazirmatn/Vazirmatn-Regular.ttf
+          weight: 400
+        - asset: assets/fonts/Vazirmatn/Vazirmatn-Medium.ttf
+          weight: 500
+        - asset: assets/fonts/Vazirmatn/Vazirmatn-SemiBold.ttf
+          weight: 600
+        - asset: assets/fonts/Vazirmatn/Vazirmatn-Bold.ttf
+          weight: 700
diff --git a/supabase/functions/book-summary/index.ts b/supabase/functions/book-summary/index.ts
index aa5ad5a..c304235 100644
--- a/supabase/functions/book-summary/index.ts
+++ b/supabase/functions/book-summary/index.ts
@@ -46,6 +46,7 @@ serve(async (req) => {
     // Get and verify JWT from Authorization header
     const authHeader = req.headers.get("Authorization");
     if (!authHeader || !authHeader.startsWith("Bearer ")) {
+      console.error("Unauthorized request: missing or invalid Authorization header");
       return new Response(
         JSON.stringify({ error: "unauthorized" }),
         { status: 401, headers: { ...corsHeaders, "Content-Type": "application/json" } }
@@ -83,10 +84,23 @@ serve(async (req) => {
     const userId = user.id;
 
     // Parse request body
-    const { audiobook_id, force_refresh }: SummaryRequest = await req.json();
+    let requestBody: SummaryRequest;
+    try {
+      requestBody = await req.json();
+    } catch (parseError) {
+      console.error("Failed to parse request body:", parseError);
+      return new Response(
+        JSON.stringify({ error: "invalid_request_body" }),
+        { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
+      );
+    }
+
+    const { audiobook_id, force_refresh } = requestBody;
+    console.log(`Request: audiobook_id=${audiobook_id}, force_refresh=${force_refresh}, user=${userId}`);
 
     // Validate input
     if (!audiobook_id || typeof audiobook_id !== "number" || audiobook_id <= 0) {
+      console.error(`Invalid audiobook_id: ${audiobook_id} (type: ${typeof audiobook_id})`);
       return new Response(
         JSON.stringify({ error: "invalid_audiobook_id" }),
         { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
@@ -94,19 +108,26 @@ serve(async (req) => {
     }
 
     // Check cache first (unless force_refresh)
+    console.log(`Checking cache for audiobook ${audiobook_id} (force_refresh=${force_refresh})`);
     if (!force_refresh) {
-      const { data: cachedSummary } = await supabase
+      const { data: cachedSummary, error: cacheError } = await supabase
         .from("book_summaries")
         .select("summary_fa")
         .eq("audiobook_id", audiobook_id)
         .maybeSingle();
 
+      if (cacheError) {
+        console.error(`Cache lookup error for audiobook ${audiobook_id}:`, cacheError);
+      }
+
       if (cachedSummary?.summary_fa) {
-        console.log(`Cache hit for audiobook ${audiobook_id}`);
+        console.log(`CACHE HIT for audiobook ${audiobook_id}, returning cached summary`);
         return new Response(
           JSON.stringify({ summary_fa: cachedSummary.summary_fa, cached: true }),
           { status: 200, headers: { ...corsHeaders, "Content-Type": "application/json" } }
         );
+      } else {
+        console.log(`CACHE MISS for audiobook ${audiobook_id}`);
       }
     }
 
@@ -133,6 +154,7 @@ serve(async (req) => {
     }
 
     // Fetch audiobook details
+    console.log(`Fetching audiobook details for id=${audiobook_id}`);
     const { data: audiobook, error: dbError } = await supabase
       .from("audiobooks")
       .select("id, title_fa, description_fa, author_fa")
@@ -140,12 +162,13 @@ serve(async (req) => {
       .single();
 
     if (dbError || !audiobook) {
-      console.error("Audiobook not found:", dbError);
+      console.error(`Audiobook not found for id=${audiobook_id}:`, dbError);
       return new Response(
         JSON.stringify({ error: "audiobook_not_found" }),
         { status: 404, headers: { ...corsHeaders, "Content-Type": "application/json" } }
       );
     }
+    console.log(`Found audiobook: title="${audiobook.title_fa?.substring(0, 30)}..."`)
 
     // Validate we have enough data to summarize
     const title = audiobook.title_fa || "";
@@ -153,6 +176,7 @@ serve(async (req) => {
     const author = audiobook.author_fa || "";
 
     if (!title && !description) {
+      console.error(`Insufficient data to summarize audiobook ${audiobook_id}`);
       return new Response(
         JSON.stringify({ error: "insufficient_data" }),
         { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
@@ -160,7 +184,7 @@ serve(async (req) => {
     }
 
     // Build the prompt for Claude
-    const systemPrompt = `تو یک دستیار کتاب صوتی فارسی هستی که برای اپلیکیشن مینا (Mina) کار می‌کنی.
+    const systemPrompt = `تو یک دستیار کتاب صوتی فارسی هستی که برای اپلیکیشن پرستو (Parasto) کار می‌کنی.
 وظیفه‌ات این است که خلاصه‌ای کوتاه و جذاب از کتاب‌ها بنویسی.
 
 قوانین:
@@ -179,6 +203,7 @@ ${author ? `نویسنده: ${author}` : ""}
 ${description ? `توضیحات: ${description}` : ""}`;
 
     // Call Anthropic API with timeout
+    console.log(`Calling Anthropic API for audiobook ${audiobook_id}...`);
     const controller = new AbortController();
     const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout
 
@@ -218,8 +243,13 @@ ${description ? `توضیحات: ${description}` : ""}`;
     if (!anthropicResponse.ok) {
       const errorBody = await anthropicResponse.text();
       console.error("Anthropic API error:", anthropicResponse.status, errorBody);
+      // Return more specific error based on status
+      const errorCode = anthropicResponse.status === 401 ? "ai_auth_failed"
+        : anthropicResponse.status === 429 ? "ai_rate_limit"
+        : anthropicResponse.status >= 500 ? "ai_server_error"
+        : "ai_request_failed";
       return new Response(
-        JSON.stringify({ error: "ai_unavailable" }),
+        JSON.stringify({ error: errorCode, status: anthropicResponse.status, debug: errorBody.substring(0, 200) }),
         { status: 503, headers: { ...corsHeaders, "Content-Type": "application/json" } }
       );
     }
@@ -278,6 +308,7 @@ ${description ? `توضیحات: ${description}` : ""}`;
       console.error("Failed to cache summary:", upsertError);
     }
 
+    console.log(`=== SUCCESS: Returning summary for audiobook ${audiobook_id} ===`);
     return new Response(
       JSON.stringify({ summary_fa: summaryText, cached: false }),
       { status: 200, headers: { ...corsHeaders, "Content-Type": "application/json" } }
@@ -285,8 +316,12 @@ ${description ? `توضیحات: ${description}` : ""}`;
 
   } catch (error) {
     console.error("Unexpected error in book-summary:", error);
+    // Include error details for debugging
+    const errorMessage = error instanceof Error ? error.message : String(error);
+    const errorStack = error instanceof Error ? error.stack : undefined;
+    console.error("Error details:", { message: errorMessage, stack: errorStack });
     return new Response(
-      JSON.stringify({ error: "ai_unavailable" }),
+      JSON.stringify({ error: "internal_error", debug: errorMessage }),
       { status: 503, headers: { ...corsHeaders, "Content-Type": "application/json" } }
     );
   }
diff --git a/supabase/functions/create-payment-intent/index.ts b/supabase/functions/create-payment-intent/index.ts
index 161a75c..6959605 100644
--- a/supabase/functions/create-payment-intent/index.ts
+++ b/supabase/functions/create-payment-intent/index.ts
@@ -36,6 +36,10 @@ serve(async (req) => {
     return new Response("ok", { headers: corsHeaders });
   }
 
+  // [DIAGNOSTIC] Log request timestamp for tracing
+  console.log("=== CREATE-PAYMENT-INTENT REQUEST ===");
+  console.log("[DIAGNOSTIC] Timestamp:", new Date().toISOString());
+
   try {
     // Get and verify JWT from Authorization header
     const authHeader = req.headers.get("Authorization");
@@ -147,7 +151,13 @@ serve(async (req) => {
       },
     });
 
-    console.log(`PaymentIntent created: ${paymentIntent.id} for user ${user.id}, audiobook ${audiobook_id}`);
+    // [DIAGNOSTIC] Detailed logging for payment intent creation
+    console.log("[DIAGNOSTIC] PaymentIntent created successfully:");
+    console.log("[DIAGNOSTIC]   - PaymentIntent ID:", paymentIntent.id);
+    console.log("[DIAGNOSTIC]   - User ID:", user.id);
+    console.log("[DIAGNOSTIC]   - Audiobook ID:", audiobook_id);
+    console.log("[DIAGNOSTIC]   - Amount (cents):", amountUsdCents);
+    console.log("[DIAGNOSTIC]   - Metadata:", JSON.stringify(paymentIntent.metadata));
 
     // Return only client_secret (client doesn't need payment intent ID)
     return new Response(
diff --git a/supabase/functions/stripe-webhook/index.ts b/supabase/functions/stripe-webhook/index.ts
index 841d304..54d9b3a 100644
--- a/supabase/functions/stripe-webhook/index.ts
+++ b/supabase/functions/stripe-webhook/index.ts
@@ -14,6 +14,9 @@
 // Configure webhook in Stripe Dashboard:
 //   URL: https://<project>.supabase.co/functions/v1/stripe-webhook
 //   Events: payment_intent.succeeded, payment_intent.payment_failed
+//
+// IMPORTANT: This function MUST return 2xx for all valid webhook calls
+// to prevent Stripe from retrying. Errors are logged but don't cause 500s.
 
 import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
 import { createClient } from "https://esm.sh/@supabase/supabase-js@2.39.0";
@@ -26,30 +29,71 @@ const stripe = new Stripe(Deno.env.get("STRIPE_SECRET_KEY") || "", {
 
 const webhookSecret = Deno.env.get("STRIPE_WEBHOOK_SECRET") || "";
 
-// Create Supabase client with service role for entitlement creation
-const supabaseUrl = Deno.env.get("SUPABASE_URL") ?? "";
-const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "";
-const supabase = createClient(supabaseUrl, supabaseServiceKey);
+// Create Supabase client INSIDE handler to ensure fresh env vars on each request
+function getSupabaseClient() {
+  const supabaseUrl = Deno.env.get("SUPABASE_URL") ?? "";
+  const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "";
+  return {
+    client: createClient(supabaseUrl, supabaseServiceKey),
+    url: supabaseUrl,
+    hasKey: !!supabaseServiceKey,
+  };
+}
+
+// Helper: Return 200 OK response (always use this to acknowledge receipt)
+function ok(message = "ok"): Response {
+  return new Response(JSON.stringify({ received: true, message }), {
+    status: 200,
+    headers: { "Content-Type": "application/json" },
+  });
+}
+
+// Helper: Return 400 Bad Request (only for signature failures)
+function badRequest(message: string): Response {
+  return new Response(JSON.stringify({ error: message }), {
+    status: 400,
+    headers: { "Content-Type": "application/json" },
+  });
+}
 
 serve(async (req) => {
+  // ========================================
+  // REQUEST LOGGING
+  // ========================================
+  const requestId = crypto.randomUUID().substring(0, 8);
+  console.log(`[${requestId}] === STRIPE-WEBHOOK REQUEST ===`);
+  console.log(`[${requestId}] Timestamp: ${new Date().toISOString()}`);
+  console.log(`[${requestId}] Method: ${req.method}`);
+
+  const { client: supabase, url: supabaseUrl, hasKey: hasServiceKey } = getSupabaseClient();
+
+  console.log(`[${requestId}] Supabase URL configured: ${!!supabaseUrl}`);
+  console.log(`[${requestId}] Service Key configured: ${hasServiceKey}`);
+  console.log(`[${requestId}] Webhook Secret configured: ${!!webhookSecret}`);
+
   // Only accept POST requests
   if (req.method !== "POST") {
+    console.log(`[${requestId}] Rejected: Method not allowed (${req.method})`);
     return new Response("Method not allowed", { status: 405 });
   }
 
+  // ========================================
+  // SIGNATURE VERIFICATION
+  // ========================================
   try {
-    // Get raw body for signature verification
     const body = await req.text();
     const signature = req.headers.get("stripe-signature");
 
     if (!signature) {
-      console.error("Missing stripe-signature header");
-      return new Response("Missing signature", { status: 400 });
+      console.error(`[${requestId}] ERROR: Missing stripe-signature header`);
+      return badRequest("Missing stripe-signature header");
     }
 
     if (!webhookSecret) {
-      console.error("STRIPE_WEBHOOK_SECRET not configured");
-      return new Response("Webhook secret not configured", { status: 500 });
+      console.error(`[${requestId}] ERROR: STRIPE_WEBHOOK_SECRET not configured`);
+      // Return 200 anyway - we don't want Stripe to keep retrying if config is wrong
+      // Admin should check logs and fix the secret
+      return ok("Webhook secret not configured - please check server logs");
     }
 
     // Verify webhook signature
@@ -61,175 +105,272 @@ serve(async (req) => {
         webhookSecret
       );
     } catch (err) {
-      console.error("Webhook signature verification failed:", err);
-      return new Response(`Webhook signature verification failed: ${err}`, { status: 400 });
+      // Signature verification failed - this IS a valid reason to return 400
+      // because it might be a malicious request, not a real Stripe event
+      console.error(`[${requestId}] ERROR: Signature verification failed:`, err);
+      return badRequest(`Webhook signature verification failed`);
     }
 
-    console.log(`Received event: ${event.type}, ID: ${event.id}`);
+    console.log(`[${requestId}] Event verified: ${event.type} (ID: ${event.id})`);
 
-    // Handle the event
+    // ========================================
+    // EVENT HANDLING
+    // ========================================
     switch (event.type) {
       case "payment_intent.succeeded": {
         const paymentIntent = event.data.object as Stripe.PaymentIntent;
-        await handlePaymentSuccess(paymentIntent);
+        console.log(`[${requestId}] Processing payment_intent.succeeded: ${paymentIntent.id}`);
+
+        // Handle payment - errors are caught and logged, never thrown
+        await handlePaymentSuccess(requestId, paymentIntent, supabase);
         break;
       }
 
       case "payment_intent.payment_failed": {
         const paymentIntent = event.data.object as Stripe.PaymentIntent;
-        await handlePaymentFailure(paymentIntent);
+        console.log(`[${requestId}] Processing payment_intent.payment_failed: ${paymentIntent.id}`);
+
+        // Log failure - no entitlement created
+        await handlePaymentFailure(requestId, paymentIntent, supabase);
         break;
       }
 
       default:
-        console.log(`Unhandled event type: ${event.type}`);
+        // Unknown event type - acknowledge receipt but ignore
+        console.log(`[${requestId}] Ignoring unhandled event type: ${event.type}`);
     }
 
-    // Return 200 to acknowledge receipt
-    return new Response(JSON.stringify({ received: true }), {
-      status: 200,
-      headers: { "Content-Type": "application/json" },
-    });
+    // ========================================
+    // ALWAYS RETURN 200
+    // ========================================
+    console.log(`[${requestId}] Returning 200 OK`);
+    return ok();
+
   } catch (error) {
-    console.error("Webhook error:", error);
-    return new Response(`Webhook error: ${error}`, { status: 500 });
+    // ========================================
+    // TOP-LEVEL ERROR HANDLER
+    // ========================================
+    // Log the error but STILL return 200 to prevent Stripe retries
+    // This is intentional - we'd rather miss one event than have Stripe
+    // keep retrying forever
+    console.error(`[${requestId}] UNEXPECTED ERROR (returning 200 anyway):`, error);
+    return ok("Error logged - see server logs for details");
   }
 });
 
 /**
  * Handle successful payment - create entitlement
+ *
+ * IMPORTANT: This function catches all errors internally and never throws.
+ * The webhook must always return 200 to prevent Stripe retries.
  */
-async function handlePaymentSuccess(paymentIntent: Stripe.PaymentIntent) {
-  console.log(`Processing successful payment: ${paymentIntent.id}`);
+async function handlePaymentSuccess(
+  requestId: string,
+  paymentIntent: Stripe.PaymentIntent,
+  supabase: ReturnType<typeof createClient>
+): Promise<void> {
+  console.log(`[${requestId}] === HANDLE PAYMENT SUCCESS ===`);
+  console.log(`[${requestId}] Payment ID: ${paymentIntent.id}`);
+  console.log(`[${requestId}] Amount: ${paymentIntent.amount} ${paymentIntent.currency}`);
+  console.log(`[${requestId}] Status: ${paymentIntent.status}`);
+  console.log(`[${requestId}] Metadata: ${JSON.stringify(paymentIntent.metadata)}`);
 
-  // Extract metadata
-  const userId = paymentIntent.metadata?.user_id;
-  const audiobookIdStr = paymentIntent.metadata?.audiobook_id;
-  // Support both old (price_toman) and new (price_usd) metadata keys
-  const priceUsd = paymentIntent.metadata?.price_usd || paymentIntent.metadata?.price_toman;
+  try {
+    // ========================================
+    // VALIDATE METADATA
+    // ========================================
+    const userId = paymentIntent.metadata?.user_id;
+    const audiobookIdStr = paymentIntent.metadata?.audiobook_id;
+    const priceUsd = paymentIntent.metadata?.price_usd || paymentIntent.metadata?.price_toman;
+
+    console.log(`[${requestId}] Extracted user_id: ${userId || 'MISSING'}`);
+    console.log(`[${requestId}] Extracted audiobook_id: ${audiobookIdStr || 'MISSING'}`);
+
+    if (!userId) {
+      console.error(`[${requestId}] ERROR: Missing user_id in metadata`);
+      console.error(`[${requestId}] This payment cannot be processed. Manual intervention required.`);
+      console.error(`[${requestId}] PaymentIntent ID: ${paymentIntent.id}`);
+      return; // Don't throw - return gracefully
+    }
 
-  if (!userId || !audiobookIdStr) {
-    console.error("Missing metadata in payment intent:", paymentIntent.id);
-    console.error("Metadata received:", JSON.stringify(paymentIntent.metadata));
-    return;
-  }
+    if (!audiobookIdStr) {
+      console.error(`[${requestId}] ERROR: Missing audiobook_id in metadata`);
+      console.error(`[${requestId}] This payment cannot be processed. Manual intervention required.`);
+      console.error(`[${requestId}] PaymentIntent ID: ${paymentIntent.id}`);
+      return; // Don't throw - return gracefully
+    }
 
-  const audiobookId = parseInt(audiobookIdStr, 10);
-  if (isNaN(audiobookId)) {
-    console.error("Invalid audiobook_id in metadata:", audiobookIdStr);
-    return;
-  }
+    const audiobookId = parseInt(audiobookIdStr, 10);
+    if (isNaN(audiobookId)) {
+      console.error(`[${requestId}] ERROR: Invalid audiobook_id: ${audiobookIdStr}`);
+      return; // Don't throw - return gracefully
+    }
 
-  try {
-    // IDEMPOTENCY CHECK 1: Check if this exact payment was already processed
-    const { data: existingByPaymentId } = await supabase
+    // ========================================
+    // IDEMPOTENCY CHECK 1: By payment_id
+    // ========================================
+    console.log(`[${requestId}] Checking if payment already processed...`);
+    const { data: existingByPaymentId, error: checkError1 } = await supabase
       .from("entitlements")
       .select("id")
       .eq("payment_id", paymentIntent.id)
       .maybeSingle();
 
+    if (checkError1) {
+      console.error(`[${requestId}] ERROR checking existing payment:`, checkError1);
+      // Continue anyway - we'll try to insert
+    }
+
     if (existingByPaymentId) {
-      console.log(`Payment ${paymentIntent.id} already processed (entitlement exists)`);
+      console.log(`[${requestId}] Payment ${paymentIntent.id} already processed (entitlement exists)`);
       return;
     }
 
-    // IDEMPOTENCY CHECK 2: Check if user already owns this audiobook
-    const { data: existingEntitlement } = await supabase
+    // ========================================
+    // IDEMPOTENCY CHECK 2: By user+audiobook
+    // ========================================
+    console.log(`[${requestId}] Checking if user already owns audiobook...`);
+    const { data: existingEntitlement, error: checkError2 } = await supabase
       .from("entitlements")
       .select("id, payment_id")
       .eq("user_id", userId)
       .eq("audiobook_id", audiobookId)
       .maybeSingle();
 
+    if (checkError2) {
+      console.error(`[${requestId}] ERROR checking existing entitlement:`, checkError2);
+      // Continue anyway - we'll try to insert
+    }
+
     if (existingEntitlement) {
-      console.log(`Entitlement already exists for user ${userId}, audiobook ${audiobookId} (payment_id: ${existingEntitlement.payment_id})`);
+      console.log(`[${requestId}] User ${userId.substring(0, 8)}... already owns audiobook ${audiobookId}`);
       return;
     }
 
-    // Create entitlement
-    const { error: entitlementError } = await supabase
+    // ========================================
+    // CREATE ENTITLEMENT
+    // ========================================
+    console.log(`[${requestId}] Creating entitlement...`);
+    console.log(`[${requestId}]   user_id: ${userId}`);
+    console.log(`[${requestId}]   audiobook_id: ${audiobookId}`);
+    console.log(`[${requestId}]   source: purchase`);
+    console.log(`[${requestId}]   payment_id: ${paymentIntent.id}`);
+
+    const { data: insertedData, error: entitlementError } = await supabase
       .from("entitlements")
       .insert({
         user_id: userId,
         audiobook_id: audiobookId,
         source: "purchase",
         payment_id: paymentIntent.id,
-      });
+      })
+      .select()
+      .single();
 
     if (entitlementError) {
       // Handle unique constraint violation gracefully (race condition)
       if (entitlementError.code === "23505") {
-        console.log(`Entitlement already exists (concurrent insert) for user ${userId}, audiobook ${audiobookId}`);
+        console.log(`[${requestId}] Entitlement already exists (concurrent insert) - OK`);
         return;
       }
-      console.error("Failed to create entitlement:", entitlementError);
-      throw entitlementError;
-    }
-
-    console.log(`Entitlement created for user ${userId}, audiobook ${audiobookId}, payment ${paymentIntent.id}`);
-
-    // Increment purchase count on audiobook
-    const { error: rpcError } = await supabase.rpc("increment_purchase_count", {
-      audiobook_id: audiobookId,
-    });
 
-    if (rpcError) {
-      console.error("Failed to increment purchase count:", rpcError);
-      // Don't throw - entitlement was created successfully
+      console.error(`[${requestId}] ERROR creating entitlement:`, entitlementError);
+      console.error(`[${requestId}] Error code: ${entitlementError.code}`);
+      console.error(`[${requestId}] Error message: ${entitlementError.message}`);
+      console.error(`[${requestId}] Error details: ${JSON.stringify(entitlementError.details)}`);
+      // Don't throw - we've logged the error, admin can investigate
+      return;
     }
 
-    // Create purchase record for audit trail
-    // Note: price_toman field now stores USD (legacy field name)
-    const { error: purchaseError } = await supabase
-      .from("purchases")
-      .insert({
-        user_id: userId,
+    console.log(`[${requestId}] SUCCESS: Entitlement created!`);
+    console.log(`[${requestId}] Entitlement ID: ${insertedData?.id}`);
+
+    // ========================================
+    // INCREMENT PURCHASE COUNT (optional)
+    // ========================================
+    try {
+      const { error: rpcError } = await supabase.rpc("increment_purchase_count", {
         audiobook_id: audiobookId,
-        amount: priceUsd ? parseInt(priceUsd, 10) : 0,
-        price_toman: priceUsd ? parseInt(priceUsd, 10) : 0,
-        payment_method: "stripe",
-        payment_reference: paymentIntent.id,
-        status: "completed",
       });
 
-    if (purchaseError) {
-      console.error("Failed to create purchase record:", purchaseError);
-      // Don't throw - entitlement was created successfully
+      if (rpcError) {
+        console.warn(`[${requestId}] WARN: Failed to increment purchase count:`, rpcError);
+        // Don't throw - entitlement was created successfully
+      } else {
+        console.log(`[${requestId}] Purchase count incremented`);
+      }
+    } catch (rpcErr) {
+      console.warn(`[${requestId}] WARN: RPC call failed:`, rpcErr);
     }
 
-    console.log(`Payment ${paymentIntent.id} processed successfully`);
+    // ========================================
+    // CREATE PURCHASE RECORD (optional audit trail)
+    // ========================================
+    try {
+      const { error: purchaseError } = await supabase
+        .from("purchases")
+        .insert({
+          user_id: userId,
+          audiobook_id: audiobookId,
+          amount: priceUsd ? parseInt(priceUsd, 10) : 0,
+          price_toman: priceUsd ? parseInt(priceUsd, 10) : 0,
+          payment_method: "stripe",
+          payment_reference: paymentIntent.id,
+          status: "completed",
+        });
+
+      if (purchaseError) {
+        console.warn(`[${requestId}] WARN: Purchase record not created:`, purchaseError.message);
+      } else {
+        console.log(`[${requestId}] Purchase record created`);
+      }
+    } catch (purchaseErr) {
+      console.warn(`[${requestId}] WARN: Purchases table may not exist:`, purchaseErr);
+    }
+
+    console.log(`[${requestId}] === PAYMENT PROCESSING COMPLETE ===`);
+
   } catch (error) {
-    console.error("Error processing payment success:", error);
-    throw error;
+    // ========================================
+    // CATCH-ALL ERROR HANDLER
+    // ========================================
+    // Log but don't throw - webhook must return 200
+    console.error(`[${requestId}] UNEXPECTED ERROR in handlePaymentSuccess:`, error);
+    console.error(`[${requestId}] PaymentIntent ID: ${paymentIntent.id}`);
+    console.error(`[${requestId}] This payment may need manual processing.`);
   }
 }
 
 /**
  * Handle failed payment - log for debugging
+ *
+ * IMPORTANT: This function catches all errors internally and never throws.
  */
-async function handlePaymentFailure(paymentIntent: Stripe.PaymentIntent) {
-  console.log(`Payment failed: ${paymentIntent.id}`);
+async function handlePaymentFailure(
+  requestId: string,
+  paymentIntent: Stripe.PaymentIntent,
+  supabase: ReturnType<typeof createClient>
+): Promise<void> {
+  console.log(`[${requestId}] === HANDLE PAYMENT FAILURE ===`);
+  console.log(`[${requestId}] Payment ID: ${paymentIntent.id}`);
 
   const userId = paymentIntent.metadata?.user_id;
   const audiobookIdStr = paymentIntent.metadata?.audiobook_id;
-  // Support both old (price_toman) and new (price_usd) metadata keys
   const priceUsd = paymentIntent.metadata?.price_usd || paymentIntent.metadata?.price_toman;
 
-  // Log failure for debugging - no entitlement created
-  console.log(`Failed payment details:`, {
+  console.log(`[${requestId}] Failed payment details:`, {
     paymentIntentId: paymentIntent.id,
-    userId,
-    audiobookId: audiobookIdStr,
+    userId: userId || 'unknown',
+    audiobookId: audiobookIdStr || 'unknown',
     amount: paymentIntent.amount,
     currency: paymentIntent.currency,
     lastPaymentError: paymentIntent.last_payment_error?.message,
   });
 
-  // Optionally create a failed purchase record
+  // Optionally create a failed purchase record for audit
   if (userId && audiobookIdStr) {
     try {
-      // Note: price_toman field now stores USD (legacy field name)
-      await supabase.from("purchases").insert({
+      const { error: purchaseError } = await supabase.from("purchases").insert({
         user_id: userId,
         audiobook_id: parseInt(audiobookIdStr, 10),
         amount: priceUsd ? parseInt(priceUsd, 10) : 0,
@@ -238,8 +379,80 @@ async function handlePaymentFailure(paymentIntent: Stripe.PaymentIntent) {
         payment_reference: paymentIntent.id,
         status: "failed",
       });
+
+      if (purchaseError) {
+        console.warn(`[${requestId}] WARN: Failed purchase record not created:`, purchaseError.message);
+      }
     } catch (error) {
-      console.error("Failed to record failed purchase:", error);
+      console.warn(`[${requestId}] WARN: Purchases table may not exist:`, error);
     }
   }
+
+  console.log(`[${requestId}] === PAYMENT FAILURE LOGGED ===`);
 }
+
+// ========================================
+// TEST PLAN
+// ========================================
+/*
+MANUAL TEST PLAN FOR STRIPE WEBHOOK
+
+1. STRIPE TEST PURCHASE FLOW:
+   a. Create a test user in the app (or use existing)
+   b. Select a PAID audiobook and initiate purchase
+   c. Use Stripe test card: 4242 4242 4242 4242
+   d. Complete payment in Stripe Payment Sheet
+
+   VERIFY IN STRIPE DASHBOARD:
+   - Go to Developers > Events
+   - Find the payment_intent.succeeded event
+   - Check that it shows "Delivered" (2xx response)
+   - Click to see the webhook response
+
+   VERIFY IN SUPABASE:
+   - Go to Database > entitlements table
+   - Look for new row with:
+     - user_id matching your test user
+     - audiobook_id matching the book you bought
+     - source = 'purchase'
+     - payment_id = the Stripe PaymentIntent ID
+
+   VERIFY IN APP:
+   - Go to کتابخانه (Library)
+   - The purchased audiobook should appear
+   - You should be able to play all chapters
+
+2. FREE BOOK FLOW:
+   a. Find a free audiobook (is_free = true)
+   b. Tap "افزودن به کتابخانه" (Add to Library)
+
+   VERIFY IN SUPABASE:
+   - New entitlements row with source = 'free'
+
+   VERIFY IN APP:
+   - Book appears in کتابخانه
+   - All chapters playable
+
+3. ERROR HANDLING:
+   a. Cancel payment in Stripe sheet
+   - No entitlement should be created
+   - App should show appropriate message
+
+   b. Use failing test card: 4000 0000 0000 9995
+   - payment_intent.payment_failed event sent
+   - No entitlement created
+   - Failure logged in Supabase Edge Function logs
+
+4. CHECK LOGS:
+   - Go to Supabase Dashboard > Edge Functions > stripe-webhook > Logs
+   - Look for [requestId] prefixed log lines
+   - Verify each step is logged
+   - Check for any ERROR lines
+
+5. VERIFY WEBHOOK SECRET:
+   - In Stripe Dashboard > Developers > Webhooks
+   - Find the webhook for luhmoqbtscutheafetlr.supabase.co
+   - Click to reveal signing secret (starts with whsec_)
+   - In Supabase, verify STRIPE_WEBHOOK_SECRET matches exactly
+   - Make sure it's the TEST mode secret (not live)
+*/
diff --git a/windows/flutter/generated_plugin_registrant.cc b/windows/flutter/generated_plugin_registrant.cc
index fa63091..89c8493 100644
--- a/windows/flutter/generated_plugin_registrant.cc
+++ b/windows/flutter/generated_plugin_registrant.cc
@@ -7,20 +7,17 @@
 #include "generated_plugin_registrant.h"
 
 #include <app_links/app_links_plugin_c_api.h>
-#include <connectivity_plus/connectivity_plus_windows_plugin.h>
 #include <file_selector_windows/file_selector_windows.h>
-#include <share_plus/share_plus_windows_plugin_c_api.h>
+#include <permission_handler_windows/permission_handler_windows_plugin.h>
 #include <url_launcher_windows/url_launcher_windows.h>
 
 void RegisterPlugins(flutter::PluginRegistry* registry) {
   AppLinksPluginCApiRegisterWithRegistrar(
       registry->GetRegistrarForPlugin("AppLinksPluginCApi"));
-  ConnectivityPlusWindowsPluginRegisterWithRegistrar(
-      registry->GetRegistrarForPlugin("ConnectivityPlusWindowsPlugin"));
   FileSelectorWindowsRegisterWithRegistrar(
       registry->GetRegistrarForPlugin("FileSelectorWindows"));
-  SharePlusWindowsPluginCApiRegisterWithRegistrar(
-      registry->GetRegistrarForPlugin("SharePlusWindowsPluginCApi"));
+  PermissionHandlerWindowsPluginRegisterWithRegistrar(
+      registry->GetRegistrarForPlugin("PermissionHandlerWindowsPlugin"));
   UrlLauncherWindowsRegisterWithRegistrar(
       registry->GetRegistrarForPlugin("UrlLauncherWindows"));
 }
diff --git a/windows/flutter/generated_plugins.cmake b/windows/flutter/generated_plugins.cmake
index 3963776..2dfad4f 100644
--- a/windows/flutter/generated_plugins.cmake
+++ b/windows/flutter/generated_plugins.cmake
@@ -4,9 +4,8 @@
 
 list(APPEND FLUTTER_PLUGIN_LIST
   app_links
-  connectivity_plus
   file_selector_windows
-  share_plus
+  permission_handler_windows
   url_launcher_windows
 )
 
diff --git a/ios/Runner.xcodeproj/project.pbxproj b/ios/Runner.xcodeproj/project.pbxproj
deleted file mode 100644
index f042b35..0000000
--- a/ios/Runner.xcodeproj/project.pbxproj
+++ /dev/null
@@ -1,736 +0,0 @@
-// !$*UTF8*$!
-{
-	archiveVersion = 1;
-	classes = {
-	};
-	objectVersion = 54;
-	objects = {
-
-/* Begin PBXBuildFile section */
-		0869EEB0DAE32E53740966C3 /* Pods_RunnerTests.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 18B86E2E9D26430BBF6602B7 /* Pods_RunnerTests.framework */; };
-		1498D2341E8E89220040F4C2 /* GeneratedPluginRegistrant.m in Sources */ = {isa = PBXBuildFile; fileRef = 1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */; };
-		331C808B294A63AB00263BE5 /* RunnerTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 331C807B294A618700263BE5 /* RunnerTests.swift */; };
-		3B3967161E833CAA004F5970 /* AppFrameworkInfo.plist in Resources */ = {isa = PBXBuildFile; fileRef = 3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */; };
-		74858FAF1ED2DC5600515810 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 74858FAE1ED2DC5600515810 /* AppDelegate.swift */; };
-		948B25BEDF63D283F89A2CF6 /* Pods_Runner.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = D02C95E99157848F7EAD5A65 /* Pods_Runner.framework */; };
-		97C146FC1CF9000F007C117D /* Main.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FA1CF9000F007C117D /* Main.storyboard */; };
-		97C146FE1CF9000F007C117D /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FD1CF9000F007C117D /* Assets.xcassets */; };
-		97C147011CF9000F007C117D /* LaunchScreen.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */; };
-/* End PBXBuildFile section */
-
-/* Begin PBXContainerItemProxy section */
-		331C8085294A63A400263BE5 /* PBXContainerItemProxy */ = {
-			isa = PBXContainerItemProxy;
-			containerPortal = 97C146E61CF9000F007C117D /* Project object */;
-			proxyType = 1;
-			remoteGlobalIDString = 97C146ED1CF9000F007C117D;
-			remoteInfo = Runner;
-		};
-/* End PBXContainerItemProxy section */
-
-/* Begin PBXCopyFilesBuildPhase section */
-		9705A1C41CF9048500538489 /* Embed Frameworks */ = {
-			isa = PBXCopyFilesBuildPhase;
-			buildActionMask = 2147483647;
-			dstPath = "";
-			dstSubfolderSpec = 10;
-			files = (
-			);
-			name = "Embed Frameworks";
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-/* End PBXCopyFilesBuildPhase section */
-
-/* Begin PBXFileReference section */
-		1498D2321E8E86230040F4C2 /* GeneratedPluginRegistrant.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = GeneratedPluginRegistrant.h; sourceTree = "<group>"; };
-		1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GeneratedPluginRegistrant.m; sourceTree = "<group>"; };
-		18B86E2E9D26430BBF6602B7 /* Pods_RunnerTests.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_RunnerTests.framework; sourceTree = BUILT_PRODUCTS_DIR; };
-		331C807B294A618700263BE5 /* RunnerTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RunnerTests.swift; sourceTree = "<group>"; };
-		331C8081294A63A400263BE5 /* RunnerTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = RunnerTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
-		3645C644C856DBC71EDF01F4 /* Pods-RunnerTests.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.release.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.release.xcconfig"; sourceTree = "<group>"; };
-		3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; name = AppFrameworkInfo.plist; path = Flutter/AppFrameworkInfo.plist; sourceTree = "<group>"; };
-		4E4AD11DDB7B40701BF88FD4 /* Pods-RunnerTests.profile.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.profile.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.profile.xcconfig"; sourceTree = "<group>"; };
-		74858FAD1ED2DC5600515810 /* Runner-Bridging-Header.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "Runner-Bridging-Header.h"; sourceTree = "<group>"; };
-		74858FAE1ED2DC5600515810 /* AppDelegate.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
-		7AFA3C8E1D35360C0083082E /* Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; name = Release.xcconfig; path = Flutter/Release.xcconfig; sourceTree = "<group>"; };
-		88528BC8073C2798D82F5CEE /* Pods-RunnerTests.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.debug.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.debug.xcconfig"; sourceTree = "<group>"; };
-		8B0E2D5DD727B5FFDC8A499A /* Pods-Runner.profile.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.profile.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.profile.xcconfig"; sourceTree = "<group>"; };
-		9740EEB21CF90195004384FC /* Debug.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = Debug.xcconfig; path = Flutter/Debug.xcconfig; sourceTree = "<group>"; };
-		9740EEB31CF90195004384FC /* Generated.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = Generated.xcconfig; path = Flutter/Generated.xcconfig; sourceTree = "<group>"; };
-		97C146EE1CF9000F007C117D /* Runner.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = Runner.app; sourceTree = BUILT_PRODUCTS_DIR; };
-		97C146FB1CF9000F007C117D /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/Main.storyboard; sourceTree = "<group>"; };
-		97C146FD1CF9000F007C117D /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
-		97C147001CF9000F007C117D /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/LaunchScreen.storyboard; sourceTree = "<group>"; };
-		97C147021CF9000F007C117D /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
-		A0DB2761694682F416A2F13A /* Pods-Runner.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.release.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig"; sourceTree = "<group>"; };
-		D02C95E99157848F7EAD5A65 /* Pods_Runner.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_Runner.framework; sourceTree = BUILT_PRODUCTS_DIR; };
-		FFEA82001F12F48055DE555E /* Pods-Runner.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.debug.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.debug.xcconfig"; sourceTree = "<group>"; };
-/* End PBXFileReference section */
-
-/* Begin PBXFrameworksBuildPhase section */
-		50CD14B2CD0AE02176350387 /* Frameworks */ = {
-			isa = PBXFrameworksBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-				0869EEB0DAE32E53740966C3 /* Pods_RunnerTests.framework in Frameworks */,
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-		97C146EB1CF9000F007C117D /* Frameworks */ = {
-			isa = PBXFrameworksBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-				948B25BEDF63D283F89A2CF6 /* Pods_Runner.framework in Frameworks */,
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-/* End PBXFrameworksBuildPhase section */
-
-/* Begin PBXGroup section */
-		1DBED34958CB34E0E705F3F8 /* Pods */ = {
-			isa = PBXGroup;
-			children = (
-				FFEA82001F12F48055DE555E /* Pods-Runner.debug.xcconfig */,
-				A0DB2761694682F416A2F13A /* Pods-Runner.release.xcconfig */,
-				8B0E2D5DD727B5FFDC8A499A /* Pods-Runner.profile.xcconfig */,
-				88528BC8073C2798D82F5CEE /* Pods-RunnerTests.debug.xcconfig */,
-				3645C644C856DBC71EDF01F4 /* Pods-RunnerTests.release.xcconfig */,
-				4E4AD11DDB7B40701BF88FD4 /* Pods-RunnerTests.profile.xcconfig */,
-			);
-			path = Pods;
-			sourceTree = "<group>";
-		};
-		331C8082294A63A400263BE5 /* RunnerTests */ = {
-			isa = PBXGroup;
-			children = (
-				331C807B294A618700263BE5 /* RunnerTests.swift */,
-			);
-			path = RunnerTests;
-			sourceTree = "<group>";
-		};
-		9740EEB11CF90186004384FC /* Flutter */ = {
-			isa = PBXGroup;
-			children = (
-				3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */,
-				9740EEB21CF90195004384FC /* Debug.xcconfig */,
-				7AFA3C8E1D35360C0083082E /* Release.xcconfig */,
-				9740EEB31CF90195004384FC /* Generated.xcconfig */,
-			);
-			name = Flutter;
-			sourceTree = "<group>";
-		};
-		97C146E51CF9000F007C117D = {
-			isa = PBXGroup;
-			children = (
-				9740EEB11CF90186004384FC /* Flutter */,
-				97C146F01CF9000F007C117D /* Runner */,
-				97C146EF1CF9000F007C117D /* Products */,
-				331C8082294A63A400263BE5 /* RunnerTests */,
-				1DBED34958CB34E0E705F3F8 /* Pods */,
-				B3E75BFC41D105342B6C80C0 /* Frameworks */,
-			);
-			sourceTree = "<group>";
-		};
-		97C146EF1CF9000F007C117D /* Products */ = {
-			isa = PBXGroup;
-			children = (
-				97C146EE1CF9000F007C117D /* Runner.app */,
-				331C8081294A63A400263BE5 /* RunnerTests.xctest */,
-			);
-			name = Products;
-			sourceTree = "<group>";
-		};
-		97C146F01CF9000F007C117D /* Runner */ = {
-			isa = PBXGroup;
-			children = (
-				97C146FA1CF9000F007C117D /* Main.storyboard */,
-				97C146FD1CF9000F007C117D /* Assets.xcassets */,
-				97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */,
-				97C147021CF9000F007C117D /* Info.plist */,
-				1498D2321E8E86230040F4C2 /* GeneratedPluginRegistrant.h */,
-				1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */,
-				74858FAE1ED2DC5600515810 /* AppDelegate.swift */,
-				74858FAD1ED2DC5600515810 /* Runner-Bridging-Header.h */,
-			);
-			path = Runner;
-			sourceTree = "<group>";
-		};
-		B3E75BFC41D105342B6C80C0 /* Frameworks */ = {
-			isa = PBXGroup;
-			children = (
-				D02C95E99157848F7EAD5A65 /* Pods_Runner.framework */,
-				18B86E2E9D26430BBF6602B7 /* Pods_RunnerTests.framework */,
-			);
-			name = Frameworks;
-			sourceTree = "<group>";
-		};
-/* End PBXGroup section */
-
-/* Begin PBXNativeTarget section */
-		331C8080294A63A400263BE5 /* RunnerTests */ = {
-			isa = PBXNativeTarget;
-			buildConfigurationList = 331C8087294A63A400263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */;
-			buildPhases = (
-				084CAE7F5E9F3EAC49A4C9EE /* [CP] Check Pods Manifest.lock */,
-				331C807D294A63A400263BE5 /* Sources */,
-				331C807F294A63A400263BE5 /* Resources */,
-				50CD14B2CD0AE02176350387 /* Frameworks */,
-			);
-			buildRules = (
-			);
-			dependencies = (
-				331C8086294A63A400263BE5 /* PBXTargetDependency */,
-			);
-			name = RunnerTests;
-			productName = RunnerTests;
-			productReference = 331C8081294A63A400263BE5 /* RunnerTests.xctest */;
-			productType = "com.apple.product-type.bundle.unit-test";
-		};
-		97C146ED1CF9000F007C117D /* Runner */ = {
-			isa = PBXNativeTarget;
-			buildConfigurationList = 97C147051CF9000F007C117D /* Build configuration list for PBXNativeTarget "Runner" */;
-			buildPhases = (
-				17908016E0C71A7ABA28F16C /* [CP] Check Pods Manifest.lock */,
-				9740EEB61CF901F6004384FC /* Run Script */,
-				97C146EA1CF9000F007C117D /* Sources */,
-				97C146EB1CF9000F007C117D /* Frameworks */,
-				97C146EC1CF9000F007C117D /* Resources */,
-				9705A1C41CF9048500538489 /* Embed Frameworks */,
-				3B06AD1E1E4923F5004D2608 /* Thin Binary */,
-				A2E36C828E217049F00E56E8 /* [CP] Embed Pods Frameworks */,
-			);
-			buildRules = (
-			);
-			dependencies = (
-			);
-			name = Runner;
-			productName = Runner;
-			productReference = 97C146EE1CF9000F007C117D /* Runner.app */;
-			productType = "com.apple.product-type.application";
-		};
-/* End PBXNativeTarget section */
-
-/* Begin PBXProject section */
-		97C146E61CF9000F007C117D /* Project object */ = {
-			isa = PBXProject;
-			attributes = {
-				BuildIndependentTargetsInParallel = YES;
-				LastUpgradeCheck = 1510;
-				ORGANIZATIONNAME = "";
-				TargetAttributes = {
-					331C8080294A63A400263BE5 = {
-						CreatedOnToolsVersion = 14.0;
-						TestTargetID = 97C146ED1CF9000F007C117D;
-					};
-					97C146ED1CF9000F007C117D = {
-						CreatedOnToolsVersion = 7.3.1;
-						LastSwiftMigration = 1100;
-					};
-				};
-			};
-			buildConfigurationList = 97C146E91CF9000F007C117D /* Build configuration list for PBXProject "Runner" */;
-			compatibilityVersion = "Xcode 9.3";
-			developmentRegion = en;
-			hasScannedForEncodings = 0;
-			knownRegions = (
-				en,
-				Base,
-			);
-			mainGroup = 97C146E51CF9000F007C117D;
-			productRefGroup = 97C146EF1CF9000F007C117D /* Products */;
-			projectDirPath = "";
-			projectRoot = "";
-			targets = (
-				97C146ED1CF9000F007C117D /* Runner */,
-				331C8080294A63A400263BE5 /* RunnerTests */,
-			);
-		};
-/* End PBXProject section */
-
-/* Begin PBXResourcesBuildPhase section */
-		331C807F294A63A400263BE5 /* Resources */ = {
-			isa = PBXResourcesBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-		97C146EC1CF9000F007C117D /* Resources */ = {
-			isa = PBXResourcesBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-				97C147011CF9000F007C117D /* LaunchScreen.storyboard in Resources */,
-				3B3967161E833CAA004F5970 /* AppFrameworkInfo.plist in Resources */,
-				97C146FE1CF9000F007C117D /* Assets.xcassets in Resources */,
-				97C146FC1CF9000F007C117D /* Main.storyboard in Resources */,
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-/* End PBXResourcesBuildPhase section */
-
-/* Begin PBXShellScriptBuildPhase section */
-		084CAE7F5E9F3EAC49A4C9EE /* [CP] Check Pods Manifest.lock */ = {
-			isa = PBXShellScriptBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-			);
-			inputFileListPaths = (
-			);
-			inputPaths = (
-				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
-				"${PODS_ROOT}/Manifest.lock",
-			);
-			name = "[CP] Check Pods Manifest.lock";
-			outputFileListPaths = (
-			);
-			outputPaths = (
-				"$(DERIVED_FILE_DIR)/Pods-RunnerTests-checkManifestLockResult.txt",
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-			shellPath = /bin/sh;
-			shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n    exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
-			showEnvVarsInLog = 0;
-		};
-		17908016E0C71A7ABA28F16C /* [CP] Check Pods Manifest.lock */ = {
-			isa = PBXShellScriptBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-			);
-			inputFileListPaths = (
-			);
-			inputPaths = (
-				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
-				"${PODS_ROOT}/Manifest.lock",
-			);
-			name = "[CP] Check Pods Manifest.lock";
-			outputFileListPaths = (
-			);
-			outputPaths = (
-				"$(DERIVED_FILE_DIR)/Pods-Runner-checkManifestLockResult.txt",
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-			shellPath = /bin/sh;
-			shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n    exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
-			showEnvVarsInLog = 0;
-		};
-		3B06AD1E1E4923F5004D2608 /* Thin Binary */ = {
-			isa = PBXShellScriptBuildPhase;
-			alwaysOutOfDate = 1;
-			buildActionMask = 2147483647;
-			files = (
-			);
-			inputPaths = (
-				"${TARGET_BUILD_DIR}/${INFOPLIST_PATH}",
-			);
-			name = "Thin Binary";
-			outputPaths = (
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-			shellPath = /bin/sh;
-			shellScript = "/bin/sh \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" embed_and_thin";
-		};
-		9740EEB61CF901F6004384FC /* Run Script */ = {
-			isa = PBXShellScriptBuildPhase;
-			alwaysOutOfDate = 1;
-			buildActionMask = 2147483647;
-			files = (
-			);
-			inputPaths = (
-			);
-			name = "Run Script";
-			outputPaths = (
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-			shellPath = /bin/sh;
-			shellScript = "/bin/sh \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" build";
-		};
-		A2E36C828E217049F00E56E8 /* [CP] Embed Pods Frameworks */ = {
-			isa = PBXShellScriptBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-			);
-			inputFileListPaths = (
-				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-frameworks-${CONFIGURATION}-input-files.xcfilelist",
-			);
-			name = "[CP] Embed Pods Frameworks";
-			outputFileListPaths = (
-				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-frameworks-${CONFIGURATION}-output-files.xcfilelist",
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-			shellPath = /bin/sh;
-			shellScript = "\"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-frameworks.sh\"\n";
-			showEnvVarsInLog = 0;
-		};
-/* End PBXShellScriptBuildPhase section */
-
-/* Begin PBXSourcesBuildPhase section */
-		331C807D294A63A400263BE5 /* Sources */ = {
-			isa = PBXSourcesBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-				331C808B294A63AB00263BE5 /* RunnerTests.swift in Sources */,
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-		97C146EA1CF9000F007C117D /* Sources */ = {
-			isa = PBXSourcesBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-				74858FAF1ED2DC5600515810 /* AppDelegate.swift in Sources */,
-				1498D2341E8E89220040F4C2 /* GeneratedPluginRegistrant.m in Sources */,
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-/* End PBXSourcesBuildPhase section */
-
-/* Begin PBXTargetDependency section */
-		331C8086294A63A400263BE5 /* PBXTargetDependency */ = {
-			isa = PBXTargetDependency;
-			target = 97C146ED1CF9000F007C117D /* Runner */;
-			targetProxy = 331C8085294A63A400263BE5 /* PBXContainerItemProxy */;
-		};
-/* End PBXTargetDependency section */
-
-/* Begin PBXVariantGroup section */
-		97C146FA1CF9000F007C117D /* Main.storyboard */ = {
-			isa = PBXVariantGroup;
-			children = (
-				97C146FB1CF9000F007C117D /* Base */,
-			);
-			name = Main.storyboard;
-			sourceTree = "<group>";
-		};
-		97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */ = {
-			isa = PBXVariantGroup;
-			children = (
-				97C147001CF9000F007C117D /* Base */,
-			);
-			name = LaunchScreen.storyboard;
-			sourceTree = "<group>";
-		};
-/* End PBXVariantGroup section */
-
-/* Begin XCBuildConfiguration section */
-		249021D3217E4FDB00AE95B9 /* Profile */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-				ALWAYS_SEARCH_USER_PATHS = NO;
-				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
-				CLANG_ANALYZER_NONNULL = YES;
-				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
-				CLANG_CXX_LIBRARY = "libc++";
-				CLANG_ENABLE_MODULES = YES;
-				CLANG_ENABLE_OBJC_ARC = YES;
-				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
-				CLANG_WARN_BOOL_CONVERSION = YES;
-				CLANG_WARN_COMMA = YES;
-				CLANG_WARN_CONSTANT_CONVERSION = YES;
-				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
-				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
-				CLANG_WARN_EMPTY_BODY = YES;
-				CLANG_WARN_ENUM_CONVERSION = YES;
-				CLANG_WARN_INFINITE_RECURSION = YES;
-				CLANG_WARN_INT_CONVERSION = YES;
-				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
-				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
-				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
-				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
-				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
-				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
-				CLANG_WARN_STRICT_PROTOTYPES = YES;
-				CLANG_WARN_SUSPICIOUS_MOVE = YES;
-				CLANG_WARN_UNREACHABLE_CODE = YES;
-				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
-				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
-				COPY_PHASE_STRIP = NO;
-				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
-				ENABLE_NS_ASSERTIONS = NO;
-				ENABLE_STRICT_OBJC_MSGSEND = YES;
-				ENABLE_USER_SCRIPT_SANDBOXING = NO;
-				GCC_C_LANGUAGE_STANDARD = gnu99;
-				GCC_NO_COMMON_BLOCKS = YES;
-				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
-				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
-				GCC_WARN_UNDECLARED_SELECTOR = YES;
-				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
-				GCC_WARN_UNUSED_FUNCTION = YES;
-				GCC_WARN_UNUSED_VARIABLE = YES;
-				IPHONEOS_DEPLOYMENT_TARGET = 12.0;
-				MTL_ENABLE_DEBUG_INFO = NO;
-				SDKROOT = iphoneos;
-				STRING_CATALOG_GENERATE_SYMBOLS = YES;
-				SUPPORTED_PLATFORMS = iphoneos;
-				TARGETED_DEVICE_FAMILY = "1,2";
-				VALIDATE_PRODUCT = YES;
-			};
-			name = Profile;
-		};
-		249021D4217E4FDB00AE95B9 /* Profile */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
-			buildSettings = {
-				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
-				CLANG_ENABLE_MODULES = YES;
-				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
-				DEVELOPMENT_TEAM = M8KTVYAXGT;
-				ENABLE_BITCODE = NO;
-				INFOPLIST_FILE = Runner/Info.plist;
-				LD_RUNPATH_SEARCH_PATHS = (
-					"$(inherited)",
-					"@executable_path/Frameworks",
-				);
-				PRODUCT_BUNDLE_IDENTIFIER = com.myna.audiobook;
-				PRODUCT_NAME = "$(TARGET_NAME)";
-				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
-				SWIFT_VERSION = 5.0;
-				VERSIONING_SYSTEM = "apple-generic";
-			};
-			name = Profile;
-		};
-		331C8088294A63A400263BE5 /* Debug */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = 88528BC8073C2798D82F5CEE /* Pods-RunnerTests.debug.xcconfig */;
-			buildSettings = {
-				BUNDLE_LOADER = "$(TEST_HOST)";
-				CODE_SIGN_STYLE = Automatic;
-				CURRENT_PROJECT_VERSION = 1;
-				GENERATE_INFOPLIST_FILE = YES;
-				MARKETING_VERSION = 1.0;
-				PRODUCT_BUNDLE_IDENTIFIER = com.myna.audiobook.RunnerTests;
-				PRODUCT_NAME = "$(TARGET_NAME)";
-				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
-				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
-				SWIFT_VERSION = 5.0;
-				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
-			};
-			name = Debug;
-		};
-		331C8089294A63A400263BE5 /* Release */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = 3645C644C856DBC71EDF01F4 /* Pods-RunnerTests.release.xcconfig */;
-			buildSettings = {
-				BUNDLE_LOADER = "$(TEST_HOST)";
-				CODE_SIGN_STYLE = Automatic;
-				CURRENT_PROJECT_VERSION = 1;
-				GENERATE_INFOPLIST_FILE = YES;
-				MARKETING_VERSION = 1.0;
-				PRODUCT_BUNDLE_IDENTIFIER = com.myna.audiobook.RunnerTests;
-				PRODUCT_NAME = "$(TARGET_NAME)";
-				SWIFT_VERSION = 5.0;
-				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
-			};
-			name = Release;
-		};
-		331C808A294A63A400263BE5 /* Profile */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = 4E4AD11DDB7B40701BF88FD4 /* Pods-RunnerTests.profile.xcconfig */;
-			buildSettings = {
-				BUNDLE_LOADER = "$(TEST_HOST)";
-				CODE_SIGN_STYLE = Automatic;
-				CURRENT_PROJECT_VERSION = 1;
-				GENERATE_INFOPLIST_FILE = YES;
-				MARKETING_VERSION = 1.0;
-				PRODUCT_BUNDLE_IDENTIFIER = com.myna.audiobook.RunnerTests;
-				PRODUCT_NAME = "$(TARGET_NAME)";
-				SWIFT_VERSION = 5.0;
-				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
-			};
-			name = Profile;
-		};
-		97C147031CF9000F007C117D /* Debug */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-				ALWAYS_SEARCH_USER_PATHS = NO;
-				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
-				CLANG_ANALYZER_NONNULL = YES;
-				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
-				CLANG_CXX_LIBRARY = "libc++";
-				CLANG_ENABLE_MODULES = YES;
-				CLANG_ENABLE_OBJC_ARC = YES;
-				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
-				CLANG_WARN_BOOL_CONVERSION = YES;
-				CLANG_WARN_COMMA = YES;
-				CLANG_WARN_CONSTANT_CONVERSION = YES;
-				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
-				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
-				CLANG_WARN_EMPTY_BODY = YES;
-				CLANG_WARN_ENUM_CONVERSION = YES;
-				CLANG_WARN_INFINITE_RECURSION = YES;
-				CLANG_WARN_INT_CONVERSION = YES;
-				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
-				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
-				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
-				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
-				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
-				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
-				CLANG_WARN_STRICT_PROTOTYPES = YES;
-				CLANG_WARN_SUSPICIOUS_MOVE = YES;
-				CLANG_WARN_UNREACHABLE_CODE = YES;
-				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
-				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
-				COPY_PHASE_STRIP = NO;
-				DEBUG_INFORMATION_FORMAT = dwarf;
-				ENABLE_STRICT_OBJC_MSGSEND = YES;
-				ENABLE_TESTABILITY = YES;
-				ENABLE_USER_SCRIPT_SANDBOXING = NO;
-				GCC_C_LANGUAGE_STANDARD = gnu99;
-				GCC_DYNAMIC_NO_PIC = NO;
-				GCC_NO_COMMON_BLOCKS = YES;
-				GCC_OPTIMIZATION_LEVEL = 0;
-				GCC_PREPROCESSOR_DEFINITIONS = (
-					"DEBUG=1",
-					"$(inherited)",
-				);
-				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
-				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
-				GCC_WARN_UNDECLARED_SELECTOR = YES;
-				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
-				GCC_WARN_UNUSED_FUNCTION = YES;
-				GCC_WARN_UNUSED_VARIABLE = YES;
-				IPHONEOS_DEPLOYMENT_TARGET = 12.0;
-				MTL_ENABLE_DEBUG_INFO = YES;
-				ONLY_ACTIVE_ARCH = YES;
-				SDKROOT = iphoneos;
-				STRING_CATALOG_GENERATE_SYMBOLS = YES;
-				TARGETED_DEVICE_FAMILY = "1,2";
-			};
-			name = Debug;
-		};
-		97C147041CF9000F007C117D /* Release */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-				ALWAYS_SEARCH_USER_PATHS = NO;
-				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
-				CLANG_ANALYZER_NONNULL = YES;
-				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
-				CLANG_CXX_LIBRARY = "libc++";
-				CLANG_ENABLE_MODULES = YES;
-				CLANG_ENABLE_OBJC_ARC = YES;
-				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
-				CLANG_WARN_BOOL_CONVERSION = YES;
-				CLANG_WARN_COMMA = YES;
-				CLANG_WARN_CONSTANT_CONVERSION = YES;
-				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
-				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
-				CLANG_WARN_EMPTY_BODY = YES;
-				CLANG_WARN_ENUM_CONVERSION = YES;
-				CLANG_WARN_INFINITE_RECURSION = YES;
-				CLANG_WARN_INT_CONVERSION = YES;
-				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
-				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
-				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
-				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
-				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
-				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
-				CLANG_WARN_STRICT_PROTOTYPES = YES;
-				CLANG_WARN_SUSPICIOUS_MOVE = YES;
-				CLANG_WARN_UNREACHABLE_CODE = YES;
-				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
-				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
-				COPY_PHASE_STRIP = NO;
-				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
-				ENABLE_NS_ASSERTIONS = NO;
-				ENABLE_STRICT_OBJC_MSGSEND = YES;
-				ENABLE_USER_SCRIPT_SANDBOXING = NO;
-				GCC_C_LANGUAGE_STANDARD = gnu99;
-				GCC_NO_COMMON_BLOCKS = YES;
-				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
-				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
-				GCC_WARN_UNDECLARED_SELECTOR = YES;
-				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
-				GCC_WARN_UNUSED_FUNCTION = YES;
-				GCC_WARN_UNUSED_VARIABLE = YES;
-				IPHONEOS_DEPLOYMENT_TARGET = 12.0;
-				MTL_ENABLE_DEBUG_INFO = NO;
-				SDKROOT = iphoneos;
-				STRING_CATALOG_GENERATE_SYMBOLS = YES;
-				SUPPORTED_PLATFORMS = iphoneos;
-				SWIFT_COMPILATION_MODE = wholemodule;
-				SWIFT_OPTIMIZATION_LEVEL = "-O";
-				TARGETED_DEVICE_FAMILY = "1,2";
-				VALIDATE_PRODUCT = YES;
-			};
-			name = Release;
-		};
-		97C147061CF9000F007C117D /* Debug */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = 9740EEB21CF90195004384FC /* Debug.xcconfig */;
-			buildSettings = {
-				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
-				CLANG_ENABLE_MODULES = YES;
-				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
-				DEVELOPMENT_TEAM = M8KTVYAXGT;
-				ENABLE_BITCODE = NO;
-				INFOPLIST_FILE = Runner/Info.plist;
-				LD_RUNPATH_SEARCH_PATHS = (
-					"$(inherited)",
-					"@executable_path/Frameworks",
-				);
-				PRODUCT_BUNDLE_IDENTIFIER = com.myna.audiobook;
-				PRODUCT_NAME = "$(TARGET_NAME)";
-				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
-				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
-				SWIFT_VERSION = 5.0;
-				VERSIONING_SYSTEM = "apple-generic";
-			};
-			name = Debug;
-		};
-		97C147071CF9000F007C117D /* Release */ = {
-			isa = XCBuildConfiguration;
-			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
-			buildSettings = {
-				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
-				CLANG_ENABLE_MODULES = YES;
-				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
-				DEVELOPMENT_TEAM = M8KTVYAXGT;
-				ENABLE_BITCODE = NO;
-				INFOPLIST_FILE = Runner/Info.plist;
-				LD_RUNPATH_SEARCH_PATHS = (
-					"$(inherited)",
-					"@executable_path/Frameworks",
-				);
-				PRODUCT_BUNDLE_IDENTIFIER = com.myna.audiobook;
-				PRODUCT_NAME = "$(TARGET_NAME)";
-				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
-				SWIFT_VERSION = 5.0;
-				VERSIONING_SYSTEM = "apple-generic";
-			};
-			name = Release;
-		};
-/* End XCBuildConfiguration section */
-
-/* Begin XCConfigurationList section */
-		331C8087294A63A400263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */ = {
-			isa = XCConfigurationList;
-			buildConfigurations = (
-				331C8088294A63A400263BE5 /* Debug */,
-				331C8089294A63A400263BE5 /* Release */,
-				331C808A294A63A400263BE5 /* Profile */,
-			);
-			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Release;
-		};
-		97C146E91CF9000F007C117D /* Build configuration list for PBXProject "Runner" */ = {
-			isa = XCConfigurationList;
-			buildConfigurations = (
-				97C147031CF9000F007C117D /* Debug */,
-				97C147041CF9000F007C117D /* Release */,
-				249021D3217E4FDB00AE95B9 /* Profile */,
-			);
-			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Release;
-		};
-		97C147051CF9000F007C117D /* Build configuration list for PBXNativeTarget "Runner" */ = {
-			isa = XCConfigurationList;
-			buildConfigurations = (
-				97C147061CF9000F007C117D /* Debug */,
-				97C147071CF9000F007C117D /* Release */,
-				249021D4217E4FDB00AE95B9 /* Profile */,
-			);
-			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Release;
-		};
-/* End XCConfigurationList section */
-	};
-	rootObject = 97C146E61CF9000F007C117D /* Project object */;
-}
diff --git a/ios/Runner.xcodeproj/project.xcworkspace/contents.xcworkspacedata b/ios/Runner.xcodeproj/project.xcworkspace/contents.xcworkspacedata
deleted file mode 100644
index 919434a..0000000
--- a/ios/Runner.xcodeproj/project.xcworkspace/contents.xcworkspacedata
+++ /dev/null
@@ -1,7 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<Workspace
-   version = "1.0">
-   <FileRef
-      location = "self:">
-   </FileRef>
-</Workspace>
diff --git a/ios/Runner.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist b/ios/Runner.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist
deleted file mode 100644
index 18d9810..0000000
--- a/ios/Runner.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
-<plist version="1.0">
-<dict>
-	<key>IDEDidComputeMac32BitWarning</key>
-	<true/>
-</dict>
-</plist>
diff --git a/ios/Runner.xcodeproj/project.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings b/ios/Runner.xcodeproj/project.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings
deleted file mode 100644
index f9b0d7c..0000000
--- a/ios/Runner.xcodeproj/project.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
-<plist version="1.0">
-<dict>
-	<key>PreviewsEnabled</key>
-	<false/>
-</dict>
-</plist>
diff --git a/ios/Runner.xcodeproj/xcshareddata/xcschemes/Runner.xcscheme b/ios/Runner.xcodeproj/xcshareddata/xcschemes/Runner.xcscheme
deleted file mode 100644
index 6ce5b0b..0000000
--- a/ios/Runner.xcodeproj/xcshareddata/xcschemes/Runner.xcscheme
+++ /dev/null
@@ -1,98 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<Scheme
-   LastUpgradeVersion = "1510"
-   version = "1.3">
-   <BuildAction
-      parallelizeBuildables = "YES"
-      buildImplicitDependencies = "YES">
-      <BuildActionEntries>
-         <BuildActionEntry
-            buildForTesting = "YES"
-            buildForRunning = "YES"
-            buildForProfiling = "YES"
-            buildForArchiving = "YES"
-            buildForAnalyzing = "YES">
-            <BuildableReference
-               BuildableIdentifier = "primary"
-               BlueprintIdentifier = "97C146ED1CF9000F007C117D"
-               BuildableName = "Runner.app"
-               BlueprintName = "Runner"
-               ReferencedContainer = "container:Runner.xcodeproj">
-            </BuildableReference>
-         </BuildActionEntry>
-      </BuildActionEntries>
-   </BuildAction>
-   <TestAction
-      buildConfiguration = "Debug"
-      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
-      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
-      shouldUseLaunchSchemeArgsEnv = "YES">
-      <MacroExpansion>
-         <BuildableReference
-            BuildableIdentifier = "primary"
-            BlueprintIdentifier = "97C146ED1CF9000F007C117D"
-            BuildableName = "Runner.app"
-            BlueprintName = "Runner"
-            ReferencedContainer = "container:Runner.xcodeproj">
-         </BuildableReference>
-      </MacroExpansion>
-      <Testables>
-         <TestableReference
-            skipped = "NO"
-            parallelizable = "YES">
-            <BuildableReference
-               BuildableIdentifier = "primary"
-               BlueprintIdentifier = "331C8080294A63A400263BE5"
-               BuildableName = "RunnerTests.xctest"
-               BlueprintName = "RunnerTests"
-               ReferencedContainer = "container:Runner.xcodeproj">
-            </BuildableReference>
-         </TestableReference>
-      </Testables>
-   </TestAction>
-   <LaunchAction
-      buildConfiguration = "Release"
-      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
-      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
-      launchStyle = "0"
-      useCustomWorkingDirectory = "NO"
-      ignoresPersistentStateOnLaunch = "NO"
-      debugDocumentVersioning = "YES"
-      debugServiceExtension = "internal"
-      allowLocationSimulation = "YES">
-      <BuildableProductRunnable
-         runnableDebuggingMode = "0">
-         <BuildableReference
-            BuildableIdentifier = "primary"
-            BlueprintIdentifier = "97C146ED1CF9000F007C117D"
-            BuildableName = "Runner.app"
-            BlueprintName = "Runner"
-            ReferencedContainer = "container:Runner.xcodeproj">
-         </BuildableReference>
-      </BuildableProductRunnable>
-   </LaunchAction>
-   <ProfileAction
-      buildConfiguration = "Profile"
-      shouldUseLaunchSchemeArgsEnv = "YES"
-      savedToolIdentifier = ""
-      useCustomWorkingDirectory = "NO"
-      debugDocumentVersioning = "YES">
-      <BuildableProductRunnable
-         runnableDebuggingMode = "0">
-         <BuildableReference
-            BuildableIdentifier = "primary"
-            BlueprintIdentifier = "97C146ED1CF9000F007C117D"
-            BuildableName = "Runner.app"
-            BlueprintName = "Runner"
-            ReferencedContainer = "container:Runner.xcodeproj">
-         </BuildableReference>
-      </BuildableProductRunnable>
-   </ProfileAction>
-   <AnalyzeAction
-      buildConfiguration = "Debug">
-   </AnalyzeAction>
-   <ArchiveAction
-      buildConfiguration = "Release"
-      revealArchiveInOrganizer = "YES">
-   </ArchiveAction>
-</Scheme>
